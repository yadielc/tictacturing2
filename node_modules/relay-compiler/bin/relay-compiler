#!/usr/bin/env node
/**
 * Relay v1.6.0
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _asyncToGenerator2 = __webpack_require__(28);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	let run = (() => {
	  var _ref2 = (0, _asyncToGenerator3.default)(function* (options) {
	    var schemaPath = __webpack_require__(4).resolve(process.cwd(), options.schema);
	    if (!__webpack_require__(10).existsSync(schemaPath)) {
	      throw new Error('--schema path does not exist: ' + schemaPath + '.');
	    }
	    var srcDir = __webpack_require__(4).resolve(process.cwd(), options.src);
	    if (!__webpack_require__(10).existsSync(srcDir)) {
	      throw new Error('--source path does not exist: ' + srcDir + '.');
	    }
	    if (options.watch && !options.watchman) {
	      throw new Error('Watchman is required to watch for changes.');
	    }
	    if (options.watch && !hasWatchmanRootFile(srcDir)) {
	      throw new Error(('\n--watch requires that the src directory have a valid watchman "root" file.\n\nRoot files can include:\n- A .git/ Git folder\n- A .hg/ Mercurial folder\n- A .watchmanconfig file\n\nEnsure that one such file exists in ' + srcDir + ' or its parents.\n    ').trim());
	    }
	    if (options.verbose && options.quiet) {
	      throw new Error("I can't be quiet and verbose at the same time");
	    }

	    var reporter = new ConsoleReporter({
	      verbose: options.verbose,
	      quiet: options.quiet
	    });

	    var useWatchman = options.watchman && (yield WatchmanClient.isAvailable());

	    var schema = getSchema(schemaPath);

	    var graphqlSearchOptions = {
	      extensions: ['graphql'],
	      include: options.include,
	      exclude: [__webpack_require__(4).relative(srcDir, schemaPath)].concat(options.exclude)
	    };

	    var parserConfigs = {
	      js: {
	        baseDir: srcDir,
	        getFileFilter: __webpack_require__(36).getFileFilter,
	        getParser: __webpack_require__(36).getParser,
	        getSchema: function getSchema() {
	          return schema;
	        },
	        watchmanExpression: useWatchman ? buildWatchExpression(options) : null,
	        filepaths: useWatchman ? null : getFilepathsFromGlob(srcDir, options)
	      },
	      graphql: {
	        baseDir: srcDir,
	        getParser: DotGraphQLParser.getParser,
	        getSchema: function getSchema() {
	          return schema;
	        },
	        watchmanExpression: useWatchman ? buildWatchExpression(graphqlSearchOptions) : null,
	        filepaths: useWatchman ? null : getFilepathsFromGlob(srcDir, graphqlSearchOptions)
	      }
	    };
	    var writerConfigs = {
	      js: {
	        getWriter: getRelayFileWriter(srcDir, options.noFutureProofEnums),
	        isGeneratedFile: function isGeneratedFile(filePath) {
	          return filePath.endsWith('.js') && filePath.includes('__generated__');
	        },
	        parser: 'js',
	        baseParsers: ['graphql']
	      }
	    };
	    var codegenRunner = new CodegenRunner({
	      reporter: reporter,
	      parserConfigs: parserConfigs,
	      writerConfigs: writerConfigs,
	      onlyValidate: options.validate,
	      // TODO: allow passing in a flag or detect?
	      sourceControl: null
	    });
	    if (!options.validate && !options.watch && options.watchman) {
	      // eslint-disable-next-line no-console
	      console.log('HINT: pass --watch to keep watching for changes.');
	    }
	    var result = options.watch ? yield codegenRunner.watchAll() : yield codegenRunner.compileAll();

	    if (result === 'ERROR') {
	      process.exit(100);
	    }
	    if (options.validate && result !== 'NO_CHANGES') {
	      process.exit(101);
	    }
	  });

	  return function run(_x) {
	    return _ref2.apply(this, arguments);
	  };
	})();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	__webpack_require__(140);

	var _require = __webpack_require__(3),
	    CodegenRunner = _require.CodegenRunner,
	    ConsoleReporter = _require.ConsoleReporter,
	    WatchmanClient = _require.WatchmanClient,
	    DotGraphQLParser = _require.DotGraphQLParser;

	var _require2 = __webpack_require__(6),
	    buildASTSchema = _require2.buildASTSchema,
	    buildClientSchema = _require2.buildClientSchema,
	    parse = _require2.parse,
	    printSchema = _require2.printSchema;

	var commonTransforms = __webpack_require__(14).commonTransforms,
	    codegenTransforms = __webpack_require__(14).codegenTransforms,
	    fragmentTransforms = __webpack_require__(14).fragmentTransforms,
	    printTransforms = __webpack_require__(14).printTransforms,
	    queryTransforms = __webpack_require__(14).queryTransforms,
	    schemaExtensions = __webpack_require__(14).schemaExtensions;

	function buildWatchExpression(options) {
	  return ['allof', ['type', 'f'], ['anyof'].concat((0, _toConsumableArray3['default'])(options.extensions.map(function (ext) {
	    return ['suffix', ext];
	  }))), ['anyof'].concat((0, _toConsumableArray3['default'])(options.include.map(function (include) {
	    return ['match', include, 'wholename'];
	  })))].concat((0, _toConsumableArray3['default'])(options.exclude.map(function (exclude) {
	    return ['not', ['match', exclude, 'wholename']];
	  })));
	}

	function getFilepathsFromGlob(baseDir, options) {
	  var extensions = options.extensions,
	      include = options.include,
	      exclude = options.exclude;

	  var patterns = include.map(function (inc) {
	    return inc + '/*.+(' + extensions.join('|') + ')';
	  });

	  var glob = __webpack_require__(145);
	  return glob.sync(patterns, {
	    cwd: baseDir,
	    ignore: exclude
	  });
	}

	function getRelayFileWriter(baseDir, noFutureProofEnums) {
	  return function (_ref) {
	    var onlyValidate = _ref.onlyValidate,
	        schema = _ref.schema,
	        documents = _ref.documents,
	        baseDocuments = _ref.baseDocuments,
	        sourceControl = _ref.sourceControl,
	        reporter = _ref.reporter;
	    return new (__webpack_require__(69))({
	      config: {
	        baseDir: baseDir,
	        compilerTransforms: {
	          commonTransforms: commonTransforms,
	          codegenTransforms: codegenTransforms,
	          fragmentTransforms: fragmentTransforms,
	          printTransforms: printTransforms,
	          queryTransforms: queryTransforms
	        },
	        customScalars: {},
	        formatModule: __webpack_require__(77),
	        inputFieldWhiteListForFlow: [],
	        schemaExtensions: schemaExtensions,
	        useHaste: false,
	        noFutureProofEnums: noFutureProofEnums
	      },
	      onlyValidate: onlyValidate,
	      schema: schema,
	      baseDocuments: baseDocuments,
	      documents: documents,
	      reporter: reporter,
	      sourceControl: sourceControl
	    });
	  };
	}

	function getSchema(schemaPath) {
	  try {
	    var source = __webpack_require__(10).readFileSync(schemaPath, 'utf8');
	    if (__webpack_require__(4).extname(schemaPath) === '.json') {
	      source = printSchema(buildClientSchema(JSON.parse(source).data));
	    }
	    source = '\n  directive @include(if: Boolean) on FRAGMENT_SPREAD | FIELD\n  directive @skip(if: Boolean) on FRAGMENT_SPREAD | FIELD\n\n  ' + source + '\n  ';
	    return buildASTSchema(parse(source), { assumeValid: true });
	  } catch (error) {
	    throw new Error(('\nError loading schema. Expected the schema to be a .graphql or a .json\nfile, describing your GraphQL server\'s API. Error detail:\n\n' + error.stack + '\n    ').trim());
	  }
	}

	// Ensure that a watchman "root" file exists in the given directory
	// or a parent so that it can be watched
	var WATCHMAN_ROOT_FILES = ['.git', '.hg', '.watchmanconfig'];
	function hasWatchmanRootFile(testPath) {
	  while (__webpack_require__(4).dirname(testPath) !== testPath) {
	    if (WATCHMAN_ROOT_FILES.some(function (file) {
	      return __webpack_require__(10).existsSync(__webpack_require__(4).join(testPath, file));
	    })) {
	      return true;
	    }
	    testPath = __webpack_require__(4).dirname(testPath);
	  }
	  return false;
	}

	// Collect args
	var argv = __webpack_require__(158).usage('Create Relay generated files\n\n' + '$0 --schema <path> --src <path> [--watch]').options({
	  schema: {
	    describe: 'Path to schema.graphql or schema.json',
	    demandOption: true,
	    type: 'string'
	  },
	  src: {
	    describe: 'Root directory of application code',
	    demandOption: true,
	    type: 'string'
	  },
	  include: {
	    array: true,
	    'default': ['**'],
	    describe: 'Directories to include under src',
	    type: 'string'
	  },
	  exclude: {
	    array: true,
	    'default': ['**/node_modules/**', '**/__mocks__/**', '**/__tests__/**', '**/__generated__/**'],
	    describe: 'Directories to ignore under src',
	    type: 'string'
	  },
	  extensions: {
	    array: true,
	    'default': ['js'],
	    describe: 'File extensions to compile (--extensions js jsx)',
	    type: 'string'
	  },
	  verbose: {
	    describe: 'More verbose logging',
	    type: 'boolean'
	  },
	  quiet: {
	    describe: 'No output to stdout',
	    type: 'boolean'
	  },
	  watchman: {
	    describe: 'Use watchman when not in watch mode',
	    type: 'boolean',
	    'default': true
	  },
	  watch: {
	    describe: 'If specified, watches files and regenerates on changes',
	    type: 'boolean'
	  },
	  validate: {
	    describe: 'Looks for pending changes and exits with non-zero code instead of ' + 'writing to disk',
	    type: 'boolean',
	    'default': false
	  },
	  noFutureProofEnums: {
	    describe: 'This option controls whether or not a catch-all entry is added to enum type definitions ' + 'for values that may be added in the future. Enabling this means you will have to update ' + 'your application whenever the GraphQL server schema adds new enum values to prevent it ' + 'from breaking.',
	    'default': false
	  }
	}).help().argv;

	// Run script with args
	// $FlowFixMe: Invalid types for yargs. Please fix this when touching this code.
	run(argv)['catch'](function (error) {
	  console.error(String(error.stack || error));
	  process.exit(1);
	});

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	var _exportNames = {
	  assertNode: true,
	  createTypeAnnotationBasedOnTypeof: true,
	  createUnionTypeAnnotation: true,
	  cloneNode: true,
	  clone: true,
	  cloneDeep: true,
	  cloneWithoutLoc: true,
	  addComment: true,
	  addComments: true,
	  inheritInnerComments: true,
	  inheritLeadingComments: true,
	  inheritsComments: true,
	  inheritTrailingComments: true,
	  removeComments: true,
	  ensureBlock: true,
	  toBindingIdentifierName: true,
	  toBlock: true,
	  toComputedKey: true,
	  toExpression: true,
	  toIdentifier: true,
	  toKeyAlias: true,
	  toSequenceExpression: true,
	  toStatement: true,
	  valueToNode: true,
	  appendToMemberExpression: true,
	  inherits: true,
	  prependToMemberExpression: true,
	  removeProperties: true,
	  removePropertiesDeep: true,
	  removeTypeDuplicates: true,
	  getBindingIdentifiers: true,
	  getOuterBindingIdentifiers: true,
	  traverse: true,
	  traverseFast: true,
	  shallowEqual: true,
	  is: true,
	  isBinding: true,
	  isBlockScoped: true,
	  isImmutable: true,
	  isLet: true,
	  isNode: true,
	  isNodesEquivalent: true,
	  isReferenced: true,
	  isScope: true,
	  isSpecifierDefault: true,
	  isType: true,
	  isValidES3Identifier: true,
	  isValidIdentifier: true,
	  isVar: true,
	  matchesPattern: true,
	  validate: true,
	  buildMatchMemberExpression: true,
	  react: true
	};
	exports.react = exports.buildMatchMemberExpression = exports.validate = exports.matchesPattern = exports.isVar = exports.isValidIdentifier = exports.isValidES3Identifier = exports.isType = exports.isSpecifierDefault = exports.isScope = exports.isReferenced = exports.isNodesEquivalent = exports.isNode = exports.isLet = exports.isImmutable = exports.isBlockScoped = exports.isBinding = exports.is = exports.shallowEqual = exports.traverseFast = exports.traverse = exports.getOuterBindingIdentifiers = exports.getBindingIdentifiers = exports.removeTypeDuplicates = exports.removePropertiesDeep = exports.removeProperties = exports.prependToMemberExpression = exports.inherits = exports.appendToMemberExpression = exports.valueToNode = exports.toStatement = exports.toSequenceExpression = exports.toKeyAlias = exports.toIdentifier = exports.toExpression = exports.toComputedKey = exports.toBlock = exports.toBindingIdentifierName = exports.ensureBlock = exports.removeComments = exports.inheritTrailingComments = exports.inheritsComments = exports.inheritLeadingComments = exports.inheritInnerComments = exports.addComments = exports.addComment = exports.cloneWithoutLoc = exports.cloneDeep = exports.clone = exports.cloneNode = exports.createUnionTypeAnnotation = exports.createTypeAnnotationBasedOnTypeof = exports.assertNode = void 0;

	var _isReactComponent = _interopRequireDefault(__webpack_require__(139));

	var _isCompatTag = _interopRequireDefault(__webpack_require__(138));

	var _buildChildren = _interopRequireDefault(__webpack_require__(103));

	var _assertNode = _interopRequireDefault(__webpack_require__(98));

	exports.assertNode = _assertNode.default;

	var _generated = __webpack_require__(99);

	Object.keys(_generated).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  exports[key] = _generated[key];
	});

	var _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(__webpack_require__(101));

	exports.createTypeAnnotationBasedOnTypeof = _createTypeAnnotationBasedOnTypeof.default;

	var _createUnionTypeAnnotation = _interopRequireDefault(__webpack_require__(102));

	exports.createUnionTypeAnnotation = _createUnionTypeAnnotation.default;

	var _generated2 = __webpack_require__(9);

	Object.keys(_generated2).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  exports[key] = _generated2[key];
	});

	var _cloneNode = _interopRequireDefault(__webpack_require__(16));

	exports.cloneNode = _cloneNode.default;

	var _clone = _interopRequireDefault(__webpack_require__(42));

	exports.clone = _clone.default;

	var _cloneDeep = _interopRequireDefault(__webpack_require__(104));

	exports.cloneDeep = _cloneDeep.default;

	var _cloneWithoutLoc = _interopRequireDefault(__webpack_require__(105));

	exports.cloneWithoutLoc = _cloneWithoutLoc.default;

	var _addComment = _interopRequireDefault(__webpack_require__(106));

	exports.addComment = _addComment.default;

	var _addComments = _interopRequireDefault(__webpack_require__(43));

	exports.addComments = _addComments.default;

	var _inheritInnerComments = _interopRequireDefault(__webpack_require__(44));

	exports.inheritInnerComments = _inheritInnerComments.default;

	var _inheritLeadingComments = _interopRequireDefault(__webpack_require__(45));

	exports.inheritLeadingComments = _inheritLeadingComments.default;

	var _inheritsComments = _interopRequireDefault(__webpack_require__(47));

	exports.inheritsComments = _inheritsComments.default;

	var _inheritTrailingComments = _interopRequireDefault(__webpack_require__(46));

	exports.inheritTrailingComments = _inheritTrailingComments.default;

	var _removeComments = _interopRequireDefault(__webpack_require__(107));

	exports.removeComments = _removeComments.default;

	var _generated3 = __webpack_require__(108);

	Object.keys(_generated3).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  exports[key] = _generated3[key];
	});

	var _constants = __webpack_require__(13);

	Object.keys(_constants).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  exports[key] = _constants[key];
	});

	var _ensureBlock = _interopRequireDefault(__webpack_require__(109));

	exports.ensureBlock = _ensureBlock.default;

	var _toBindingIdentifierName = _interopRequireDefault(__webpack_require__(111));

	exports.toBindingIdentifierName = _toBindingIdentifierName.default;

	var _toBlock = _interopRequireDefault(__webpack_require__(48));

	exports.toBlock = _toBlock.default;

	var _toComputedKey = _interopRequireDefault(__webpack_require__(112));

	exports.toComputedKey = _toComputedKey.default;

	var _toExpression = _interopRequireDefault(__webpack_require__(113));

	exports.toExpression = _toExpression.default;

	var _toIdentifier = _interopRequireDefault(__webpack_require__(49));

	exports.toIdentifier = _toIdentifier.default;

	var _toKeyAlias = _interopRequireDefault(__webpack_require__(114));

	exports.toKeyAlias = _toKeyAlias.default;

	var _toSequenceExpression = _interopRequireDefault(__webpack_require__(115));

	exports.toSequenceExpression = _toSequenceExpression.default;

	var _toStatement = _interopRequireDefault(__webpack_require__(116));

	exports.toStatement = _toStatement.default;

	var _valueToNode = _interopRequireDefault(__webpack_require__(117));

	exports.valueToNode = _valueToNode.default;

	var _definitions = __webpack_require__(11);

	Object.keys(_definitions).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  exports[key] = _definitions[key];
	});

	var _appendToMemberExpression = _interopRequireDefault(__webpack_require__(123));

	exports.appendToMemberExpression = _appendToMemberExpression.default;

	var _inherits = _interopRequireDefault(__webpack_require__(124));

	exports.inherits = _inherits.default;

	var _prependToMemberExpression = _interopRequireDefault(__webpack_require__(125));

	exports.prependToMemberExpression = _prependToMemberExpression.default;

	var _removeProperties = _interopRequireDefault(__webpack_require__(51));

	exports.removeProperties = _removeProperties.default;

	var _removePropertiesDeep = _interopRequireDefault(__webpack_require__(52));

	exports.removePropertiesDeep = _removePropertiesDeep.default;

	var _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(50));

	exports.removeTypeDuplicates = _removeTypeDuplicates.default;

	var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(19));

	exports.getBindingIdentifiers = _getBindingIdentifiers.default;

	var _getOuterBindingIdentifiers = _interopRequireDefault(__webpack_require__(126));

	exports.getOuterBindingIdentifiers = _getOuterBindingIdentifiers.default;

	var _traverse = _interopRequireDefault(__webpack_require__(127));

	exports.traverse = _traverse.default;

	var _traverseFast = _interopRequireDefault(__webpack_require__(53));

	exports.traverseFast = _traverseFast.default;

	var _shallowEqual = _interopRequireDefault(__webpack_require__(54));

	exports.shallowEqual = _shallowEqual.default;

	var _is = _interopRequireDefault(__webpack_require__(20));

	exports.is = _is.default;

	var _isBinding = _interopRequireDefault(__webpack_require__(129));

	exports.isBinding = _isBinding.default;

	var _isBlockScoped = _interopRequireDefault(__webpack_require__(130));

	exports.isBlockScoped = _isBlockScoped.default;

	var _isImmutable = _interopRequireDefault(__webpack_require__(131));

	exports.isImmutable = _isImmutable.default;

	var _isLet = _interopRequireDefault(__webpack_require__(56));

	exports.isLet = _isLet.default;

	var _isNode = _interopRequireDefault(__webpack_require__(57));

	exports.isNode = _isNode.default;

	var _isNodesEquivalent = _interopRequireDefault(__webpack_require__(132));

	exports.isNodesEquivalent = _isNodesEquivalent.default;

	var _isReferenced = _interopRequireDefault(__webpack_require__(133));

	exports.isReferenced = _isReferenced.default;

	var _isScope = _interopRequireDefault(__webpack_require__(134));

	exports.isScope = _isScope.default;

	var _isSpecifierDefault = _interopRequireDefault(__webpack_require__(135));

	exports.isSpecifierDefault = _isSpecifierDefault.default;

	var _isType = _interopRequireDefault(__webpack_require__(27));

	exports.isType = _isType.default;

	var _isValidES3Identifier = _interopRequireDefault(__webpack_require__(136));

	exports.isValidES3Identifier = _isValidES3Identifier.default;

	var _isValidIdentifier = _interopRequireDefault(__webpack_require__(17));

	exports.isValidIdentifier = _isValidIdentifier.default;

	var _isVar = _interopRequireDefault(__webpack_require__(137));

	exports.isVar = _isVar.default;

	var _matchesPattern = _interopRequireDefault(__webpack_require__(58));

	exports.matchesPattern = _matchesPattern.default;

	var _validate = _interopRequireDefault(__webpack_require__(59));

	exports.validate = _validate.default;

	var _buildMatchMemberExpression = _interopRequireDefault(__webpack_require__(55));

	exports.buildMatchMemberExpression = _buildMatchMemberExpression.default;

	var _generated4 = __webpack_require__(5);

	Object.keys(_generated4).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  exports[key] = _generated4[key];
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var react = {
	  isReactComponent: _isReactComponent.default,
	  isCompatTag: _isCompatTag.default,
	  buildChildren: _buildChildren.default
	};
	exports.react = react;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	module.exports = require("fbjs/lib/invariant");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	module.exports = require("graphql-compiler");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	module.exports = require("path");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.isArrayExpression = isArrayExpression;
	exports.isAssignmentExpression = isAssignmentExpression;
	exports.isBinaryExpression = isBinaryExpression;
	exports.isDirective = isDirective;
	exports.isDirectiveLiteral = isDirectiveLiteral;
	exports.isBlockStatement = isBlockStatement;
	exports.isBreakStatement = isBreakStatement;
	exports.isCallExpression = isCallExpression;
	exports.isCatchClause = isCatchClause;
	exports.isConditionalExpression = isConditionalExpression;
	exports.isContinueStatement = isContinueStatement;
	exports.isDebuggerStatement = isDebuggerStatement;
	exports.isDoWhileStatement = isDoWhileStatement;
	exports.isEmptyStatement = isEmptyStatement;
	exports.isExpressionStatement = isExpressionStatement;
	exports.isFile = isFile;
	exports.isForInStatement = isForInStatement;
	exports.isForStatement = isForStatement;
	exports.isFunctionDeclaration = isFunctionDeclaration;
	exports.isFunctionExpression = isFunctionExpression;
	exports.isIdentifier = isIdentifier;
	exports.isIfStatement = isIfStatement;
	exports.isLabeledStatement = isLabeledStatement;
	exports.isStringLiteral = isStringLiteral;
	exports.isNumericLiteral = isNumericLiteral;
	exports.isNullLiteral = isNullLiteral;
	exports.isBooleanLiteral = isBooleanLiteral;
	exports.isRegExpLiteral = isRegExpLiteral;
	exports.isLogicalExpression = isLogicalExpression;
	exports.isMemberExpression = isMemberExpression;
	exports.isNewExpression = isNewExpression;
	exports.isProgram = isProgram;
	exports.isObjectExpression = isObjectExpression;
	exports.isObjectMethod = isObjectMethod;
	exports.isObjectProperty = isObjectProperty;
	exports.isRestElement = isRestElement;
	exports.isReturnStatement = isReturnStatement;
	exports.isSequenceExpression = isSequenceExpression;
	exports.isSwitchCase = isSwitchCase;
	exports.isSwitchStatement = isSwitchStatement;
	exports.isThisExpression = isThisExpression;
	exports.isThrowStatement = isThrowStatement;
	exports.isTryStatement = isTryStatement;
	exports.isUnaryExpression = isUnaryExpression;
	exports.isUpdateExpression = isUpdateExpression;
	exports.isVariableDeclaration = isVariableDeclaration;
	exports.isVariableDeclarator = isVariableDeclarator;
	exports.isWhileStatement = isWhileStatement;
	exports.isWithStatement = isWithStatement;
	exports.isAssignmentPattern = isAssignmentPattern;
	exports.isArrayPattern = isArrayPattern;
	exports.isArrowFunctionExpression = isArrowFunctionExpression;
	exports.isClassBody = isClassBody;
	exports.isClassDeclaration = isClassDeclaration;
	exports.isClassExpression = isClassExpression;
	exports.isExportAllDeclaration = isExportAllDeclaration;
	exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
	exports.isExportNamedDeclaration = isExportNamedDeclaration;
	exports.isExportSpecifier = isExportSpecifier;
	exports.isForOfStatement = isForOfStatement;
	exports.isImportDeclaration = isImportDeclaration;
	exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
	exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
	exports.isImportSpecifier = isImportSpecifier;
	exports.isMetaProperty = isMetaProperty;
	exports.isClassMethod = isClassMethod;
	exports.isObjectPattern = isObjectPattern;
	exports.isSpreadElement = isSpreadElement;
	exports.isSuper = isSuper;
	exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
	exports.isTemplateElement = isTemplateElement;
	exports.isTemplateLiteral = isTemplateLiteral;
	exports.isYieldExpression = isYieldExpression;
	exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
	exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
	exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
	exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
	exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
	exports.isClassImplements = isClassImplements;
	exports.isDeclareClass = isDeclareClass;
	exports.isDeclareFunction = isDeclareFunction;
	exports.isDeclareInterface = isDeclareInterface;
	exports.isDeclareModule = isDeclareModule;
	exports.isDeclareModuleExports = isDeclareModuleExports;
	exports.isDeclareTypeAlias = isDeclareTypeAlias;
	exports.isDeclareOpaqueType = isDeclareOpaqueType;
	exports.isDeclareVariable = isDeclareVariable;
	exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
	exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
	exports.isDeclaredPredicate = isDeclaredPredicate;
	exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
	exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
	exports.isFunctionTypeParam = isFunctionTypeParam;
	exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
	exports.isInferredPredicate = isInferredPredicate;
	exports.isInterfaceExtends = isInterfaceExtends;
	exports.isInterfaceDeclaration = isInterfaceDeclaration;
	exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
	exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
	exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
	exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
	exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
	exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
	exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
	exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
	exports.isObjectTypeIndexer = isObjectTypeIndexer;
	exports.isObjectTypeProperty = isObjectTypeProperty;
	exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
	exports.isOpaqueType = isOpaqueType;
	exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
	exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
	exports.isStringTypeAnnotation = isStringTypeAnnotation;
	exports.isThisTypeAnnotation = isThisTypeAnnotation;
	exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
	exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
	exports.isTypeAlias = isTypeAlias;
	exports.isTypeAnnotation = isTypeAnnotation;
	exports.isTypeCastExpression = isTypeCastExpression;
	exports.isTypeParameter = isTypeParameter;
	exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
	exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
	exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
	exports.isVariance = isVariance;
	exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
	exports.isJSXAttribute = isJSXAttribute;
	exports.isJSXClosingElement = isJSXClosingElement;
	exports.isJSXElement = isJSXElement;
	exports.isJSXEmptyExpression = isJSXEmptyExpression;
	exports.isJSXExpressionContainer = isJSXExpressionContainer;
	exports.isJSXSpreadChild = isJSXSpreadChild;
	exports.isJSXIdentifier = isJSXIdentifier;
	exports.isJSXMemberExpression = isJSXMemberExpression;
	exports.isJSXNamespacedName = isJSXNamespacedName;
	exports.isJSXOpeningElement = isJSXOpeningElement;
	exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
	exports.isJSXText = isJSXText;
	exports.isJSXFragment = isJSXFragment;
	exports.isJSXOpeningFragment = isJSXOpeningFragment;
	exports.isJSXClosingFragment = isJSXClosingFragment;
	exports.isNoop = isNoop;
	exports.isParenthesizedExpression = isParenthesizedExpression;
	exports.isAwaitExpression = isAwaitExpression;
	exports.isBindExpression = isBindExpression;
	exports.isClassProperty = isClassProperty;
	exports.isOptionalMemberExpression = isOptionalMemberExpression;
	exports.isOptionalCallExpression = isOptionalCallExpression;
	exports.isImport = isImport;
	exports.isDecorator = isDecorator;
	exports.isDoExpression = isDoExpression;
	exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
	exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
	exports.isTSParameterProperty = isTSParameterProperty;
	exports.isTSDeclareFunction = isTSDeclareFunction;
	exports.isTSDeclareMethod = isTSDeclareMethod;
	exports.isTSQualifiedName = isTSQualifiedName;
	exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
	exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
	exports.isTSPropertySignature = isTSPropertySignature;
	exports.isTSMethodSignature = isTSMethodSignature;
	exports.isTSIndexSignature = isTSIndexSignature;
	exports.isTSAnyKeyword = isTSAnyKeyword;
	exports.isTSNumberKeyword = isTSNumberKeyword;
	exports.isTSObjectKeyword = isTSObjectKeyword;
	exports.isTSBooleanKeyword = isTSBooleanKeyword;
	exports.isTSStringKeyword = isTSStringKeyword;
	exports.isTSSymbolKeyword = isTSSymbolKeyword;
	exports.isTSVoidKeyword = isTSVoidKeyword;
	exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
	exports.isTSNullKeyword = isTSNullKeyword;
	exports.isTSNeverKeyword = isTSNeverKeyword;
	exports.isTSThisType = isTSThisType;
	exports.isTSFunctionType = isTSFunctionType;
	exports.isTSConstructorType = isTSConstructorType;
	exports.isTSTypeReference = isTSTypeReference;
	exports.isTSTypePredicate = isTSTypePredicate;
	exports.isTSTypeQuery = isTSTypeQuery;
	exports.isTSTypeLiteral = isTSTypeLiteral;
	exports.isTSArrayType = isTSArrayType;
	exports.isTSTupleType = isTSTupleType;
	exports.isTSUnionType = isTSUnionType;
	exports.isTSIntersectionType = isTSIntersectionType;
	exports.isTSParenthesizedType = isTSParenthesizedType;
	exports.isTSTypeOperator = isTSTypeOperator;
	exports.isTSIndexedAccessType = isTSIndexedAccessType;
	exports.isTSMappedType = isTSMappedType;
	exports.isTSLiteralType = isTSLiteralType;
	exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
	exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
	exports.isTSInterfaceBody = isTSInterfaceBody;
	exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
	exports.isTSAsExpression = isTSAsExpression;
	exports.isTSTypeAssertion = isTSTypeAssertion;
	exports.isTSEnumDeclaration = isTSEnumDeclaration;
	exports.isTSEnumMember = isTSEnumMember;
	exports.isTSModuleDeclaration = isTSModuleDeclaration;
	exports.isTSModuleBlock = isTSModuleBlock;
	exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
	exports.isTSExternalModuleReference = isTSExternalModuleReference;
	exports.isTSNonNullExpression = isTSNonNullExpression;
	exports.isTSExportAssignment = isTSExportAssignment;
	exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
	exports.isTSTypeAnnotation = isTSTypeAnnotation;
	exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
	exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
	exports.isTSTypeParameter = isTSTypeParameter;
	exports.isExpression = isExpression;
	exports.isBinary = isBinary;
	exports.isScopable = isScopable;
	exports.isBlockParent = isBlockParent;
	exports.isBlock = isBlock;
	exports.isStatement = isStatement;
	exports.isTerminatorless = isTerminatorless;
	exports.isCompletionStatement = isCompletionStatement;
	exports.isConditional = isConditional;
	exports.isLoop = isLoop;
	exports.isWhile = isWhile;
	exports.isExpressionWrapper = isExpressionWrapper;
	exports.isFor = isFor;
	exports.isForXStatement = isForXStatement;
	exports.isFunction = isFunction;
	exports.isFunctionParent = isFunctionParent;
	exports.isPureish = isPureish;
	exports.isDeclaration = isDeclaration;
	exports.isPatternLike = isPatternLike;
	exports.isLVal = isLVal;
	exports.isTSEntityName = isTSEntityName;
	exports.isLiteral = isLiteral;
	exports.isImmutable = isImmutable;
	exports.isUserWhitespacable = isUserWhitespacable;
	exports.isMethod = isMethod;
	exports.isObjectMember = isObjectMember;
	exports.isProperty = isProperty;
	exports.isUnaryLike = isUnaryLike;
	exports.isPattern = isPattern;
	exports.isClass = isClass;
	exports.isModuleDeclaration = isModuleDeclaration;
	exports.isExportDeclaration = isExportDeclaration;
	exports.isModuleSpecifier = isModuleSpecifier;
	exports.isFlow = isFlow;
	exports.isFlowType = isFlowType;
	exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
	exports.isFlowDeclaration = isFlowDeclaration;
	exports.isFlowPredicate = isFlowPredicate;
	exports.isJSX = isJSX;
	exports.isTSTypeElement = isTSTypeElement;
	exports.isTSType = isTSType;
	exports.isNumberLiteral = isNumberLiteral;
	exports.isRegexLiteral = isRegexLiteral;
	exports.isRestProperty = isRestProperty;
	exports.isSpreadProperty = isSpreadProperty;

	var _is = _interopRequireDefault(__webpack_require__(20));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isArrayExpression(node, opts) {
	  return (0, _is.default)("ArrayExpression", node, opts);
	}

	function isAssignmentExpression(node, opts) {
	  return (0, _is.default)("AssignmentExpression", node, opts);
	}

	function isBinaryExpression(node, opts) {
	  return (0, _is.default)("BinaryExpression", node, opts);
	}

	function isDirective(node, opts) {
	  return (0, _is.default)("Directive", node, opts);
	}

	function isDirectiveLiteral(node, opts) {
	  return (0, _is.default)("DirectiveLiteral", node, opts);
	}

	function isBlockStatement(node, opts) {
	  return (0, _is.default)("BlockStatement", node, opts);
	}

	function isBreakStatement(node, opts) {
	  return (0, _is.default)("BreakStatement", node, opts);
	}

	function isCallExpression(node, opts) {
	  return (0, _is.default)("CallExpression", node, opts);
	}

	function isCatchClause(node, opts) {
	  return (0, _is.default)("CatchClause", node, opts);
	}

	function isConditionalExpression(node, opts) {
	  return (0, _is.default)("ConditionalExpression", node, opts);
	}

	function isContinueStatement(node, opts) {
	  return (0, _is.default)("ContinueStatement", node, opts);
	}

	function isDebuggerStatement(node, opts) {
	  return (0, _is.default)("DebuggerStatement", node, opts);
	}

	function isDoWhileStatement(node, opts) {
	  return (0, _is.default)("DoWhileStatement", node, opts);
	}

	function isEmptyStatement(node, opts) {
	  return (0, _is.default)("EmptyStatement", node, opts);
	}

	function isExpressionStatement(node, opts) {
	  return (0, _is.default)("ExpressionStatement", node, opts);
	}

	function isFile(node, opts) {
	  return (0, _is.default)("File", node, opts);
	}

	function isForInStatement(node, opts) {
	  return (0, _is.default)("ForInStatement", node, opts);
	}

	function isForStatement(node, opts) {
	  return (0, _is.default)("ForStatement", node, opts);
	}

	function isFunctionDeclaration(node, opts) {
	  return (0, _is.default)("FunctionDeclaration", node, opts);
	}

	function isFunctionExpression(node, opts) {
	  return (0, _is.default)("FunctionExpression", node, opts);
	}

	function isIdentifier(node, opts) {
	  return (0, _is.default)("Identifier", node, opts);
	}

	function isIfStatement(node, opts) {
	  return (0, _is.default)("IfStatement", node, opts);
	}

	function isLabeledStatement(node, opts) {
	  return (0, _is.default)("LabeledStatement", node, opts);
	}

	function isStringLiteral(node, opts) {
	  return (0, _is.default)("StringLiteral", node, opts);
	}

	function isNumericLiteral(node, opts) {
	  return (0, _is.default)("NumericLiteral", node, opts);
	}

	function isNullLiteral(node, opts) {
	  return (0, _is.default)("NullLiteral", node, opts);
	}

	function isBooleanLiteral(node, opts) {
	  return (0, _is.default)("BooleanLiteral", node, opts);
	}

	function isRegExpLiteral(node, opts) {
	  return (0, _is.default)("RegExpLiteral", node, opts);
	}

	function isLogicalExpression(node, opts) {
	  return (0, _is.default)("LogicalExpression", node, opts);
	}

	function isMemberExpression(node, opts) {
	  return (0, _is.default)("MemberExpression", node, opts);
	}

	function isNewExpression(node, opts) {
	  return (0, _is.default)("NewExpression", node, opts);
	}

	function isProgram(node, opts) {
	  return (0, _is.default)("Program", node, opts);
	}

	function isObjectExpression(node, opts) {
	  return (0, _is.default)("ObjectExpression", node, opts);
	}

	function isObjectMethod(node, opts) {
	  return (0, _is.default)("ObjectMethod", node, opts);
	}

	function isObjectProperty(node, opts) {
	  return (0, _is.default)("ObjectProperty", node, opts);
	}

	function isRestElement(node, opts) {
	  return (0, _is.default)("RestElement", node, opts);
	}

	function isReturnStatement(node, opts) {
	  return (0, _is.default)("ReturnStatement", node, opts);
	}

	function isSequenceExpression(node, opts) {
	  return (0, _is.default)("SequenceExpression", node, opts);
	}

	function isSwitchCase(node, opts) {
	  return (0, _is.default)("SwitchCase", node, opts);
	}

	function isSwitchStatement(node, opts) {
	  return (0, _is.default)("SwitchStatement", node, opts);
	}

	function isThisExpression(node, opts) {
	  return (0, _is.default)("ThisExpression", node, opts);
	}

	function isThrowStatement(node, opts) {
	  return (0, _is.default)("ThrowStatement", node, opts);
	}

	function isTryStatement(node, opts) {
	  return (0, _is.default)("TryStatement", node, opts);
	}

	function isUnaryExpression(node, opts) {
	  return (0, _is.default)("UnaryExpression", node, opts);
	}

	function isUpdateExpression(node, opts) {
	  return (0, _is.default)("UpdateExpression", node, opts);
	}

	function isVariableDeclaration(node, opts) {
	  return (0, _is.default)("VariableDeclaration", node, opts);
	}

	function isVariableDeclarator(node, opts) {
	  return (0, _is.default)("VariableDeclarator", node, opts);
	}

	function isWhileStatement(node, opts) {
	  return (0, _is.default)("WhileStatement", node, opts);
	}

	function isWithStatement(node, opts) {
	  return (0, _is.default)("WithStatement", node, opts);
	}

	function isAssignmentPattern(node, opts) {
	  return (0, _is.default)("AssignmentPattern", node, opts);
	}

	function isArrayPattern(node, opts) {
	  return (0, _is.default)("ArrayPattern", node, opts);
	}

	function isArrowFunctionExpression(node, opts) {
	  return (0, _is.default)("ArrowFunctionExpression", node, opts);
	}

	function isClassBody(node, opts) {
	  return (0, _is.default)("ClassBody", node, opts);
	}

	function isClassDeclaration(node, opts) {
	  return (0, _is.default)("ClassDeclaration", node, opts);
	}

	function isClassExpression(node, opts) {
	  return (0, _is.default)("ClassExpression", node, opts);
	}

	function isExportAllDeclaration(node, opts) {
	  return (0, _is.default)("ExportAllDeclaration", node, opts);
	}

	function isExportDefaultDeclaration(node, opts) {
	  return (0, _is.default)("ExportDefaultDeclaration", node, opts);
	}

	function isExportNamedDeclaration(node, opts) {
	  return (0, _is.default)("ExportNamedDeclaration", node, opts);
	}

	function isExportSpecifier(node, opts) {
	  return (0, _is.default)("ExportSpecifier", node, opts);
	}

	function isForOfStatement(node, opts) {
	  return (0, _is.default)("ForOfStatement", node, opts);
	}

	function isImportDeclaration(node, opts) {
	  return (0, _is.default)("ImportDeclaration", node, opts);
	}

	function isImportDefaultSpecifier(node, opts) {
	  return (0, _is.default)("ImportDefaultSpecifier", node, opts);
	}

	function isImportNamespaceSpecifier(node, opts) {
	  return (0, _is.default)("ImportNamespaceSpecifier", node, opts);
	}

	function isImportSpecifier(node, opts) {
	  return (0, _is.default)("ImportSpecifier", node, opts);
	}

	function isMetaProperty(node, opts) {
	  return (0, _is.default)("MetaProperty", node, opts);
	}

	function isClassMethod(node, opts) {
	  return (0, _is.default)("ClassMethod", node, opts);
	}

	function isObjectPattern(node, opts) {
	  return (0, _is.default)("ObjectPattern", node, opts);
	}

	function isSpreadElement(node, opts) {
	  return (0, _is.default)("SpreadElement", node, opts);
	}

	function isSuper(node, opts) {
	  return (0, _is.default)("Super", node, opts);
	}

	function isTaggedTemplateExpression(node, opts) {
	  return (0, _is.default)("TaggedTemplateExpression", node, opts);
	}

	function isTemplateElement(node, opts) {
	  return (0, _is.default)("TemplateElement", node, opts);
	}

	function isTemplateLiteral(node, opts) {
	  return (0, _is.default)("TemplateLiteral", node, opts);
	}

	function isYieldExpression(node, opts) {
	  return (0, _is.default)("YieldExpression", node, opts);
	}

	function isAnyTypeAnnotation(node, opts) {
	  return (0, _is.default)("AnyTypeAnnotation", node, opts);
	}

	function isArrayTypeAnnotation(node, opts) {
	  return (0, _is.default)("ArrayTypeAnnotation", node, opts);
	}

	function isBooleanTypeAnnotation(node, opts) {
	  return (0, _is.default)("BooleanTypeAnnotation", node, opts);
	}

	function isBooleanLiteralTypeAnnotation(node, opts) {
	  return (0, _is.default)("BooleanLiteralTypeAnnotation", node, opts);
	}

	function isNullLiteralTypeAnnotation(node, opts) {
	  return (0, _is.default)("NullLiteralTypeAnnotation", node, opts);
	}

	function isClassImplements(node, opts) {
	  return (0, _is.default)("ClassImplements", node, opts);
	}

	function isDeclareClass(node, opts) {
	  return (0, _is.default)("DeclareClass", node, opts);
	}

	function isDeclareFunction(node, opts) {
	  return (0, _is.default)("DeclareFunction", node, opts);
	}

	function isDeclareInterface(node, opts) {
	  return (0, _is.default)("DeclareInterface", node, opts);
	}

	function isDeclareModule(node, opts) {
	  return (0, _is.default)("DeclareModule", node, opts);
	}

	function isDeclareModuleExports(node, opts) {
	  return (0, _is.default)("DeclareModuleExports", node, opts);
	}

	function isDeclareTypeAlias(node, opts) {
	  return (0, _is.default)("DeclareTypeAlias", node, opts);
	}

	function isDeclareOpaqueType(node, opts) {
	  return (0, _is.default)("DeclareOpaqueType", node, opts);
	}

	function isDeclareVariable(node, opts) {
	  return (0, _is.default)("DeclareVariable", node, opts);
	}

	function isDeclareExportDeclaration(node, opts) {
	  return (0, _is.default)("DeclareExportDeclaration", node, opts);
	}

	function isDeclareExportAllDeclaration(node, opts) {
	  return (0, _is.default)("DeclareExportAllDeclaration", node, opts);
	}

	function isDeclaredPredicate(node, opts) {
	  return (0, _is.default)("DeclaredPredicate", node, opts);
	}

	function isExistsTypeAnnotation(node, opts) {
	  return (0, _is.default)("ExistsTypeAnnotation", node, opts);
	}

	function isFunctionTypeAnnotation(node, opts) {
	  return (0, _is.default)("FunctionTypeAnnotation", node, opts);
	}

	function isFunctionTypeParam(node, opts) {
	  return (0, _is.default)("FunctionTypeParam", node, opts);
	}

	function isGenericTypeAnnotation(node, opts) {
	  return (0, _is.default)("GenericTypeAnnotation", node, opts);
	}

	function isInferredPredicate(node, opts) {
	  return (0, _is.default)("InferredPredicate", node, opts);
	}

	function isInterfaceExtends(node, opts) {
	  return (0, _is.default)("InterfaceExtends", node, opts);
	}

	function isInterfaceDeclaration(node, opts) {
	  return (0, _is.default)("InterfaceDeclaration", node, opts);
	}

	function isIntersectionTypeAnnotation(node, opts) {
	  return (0, _is.default)("IntersectionTypeAnnotation", node, opts);
	}

	function isMixedTypeAnnotation(node, opts) {
	  return (0, _is.default)("MixedTypeAnnotation", node, opts);
	}

	function isEmptyTypeAnnotation(node, opts) {
	  return (0, _is.default)("EmptyTypeAnnotation", node, opts);
	}

	function isNullableTypeAnnotation(node, opts) {
	  return (0, _is.default)("NullableTypeAnnotation", node, opts);
	}

	function isNumberLiteralTypeAnnotation(node, opts) {
	  return (0, _is.default)("NumberLiteralTypeAnnotation", node, opts);
	}

	function isNumberTypeAnnotation(node, opts) {
	  return (0, _is.default)("NumberTypeAnnotation", node, opts);
	}

	function isObjectTypeAnnotation(node, opts) {
	  return (0, _is.default)("ObjectTypeAnnotation", node, opts);
	}

	function isObjectTypeCallProperty(node, opts) {
	  return (0, _is.default)("ObjectTypeCallProperty", node, opts);
	}

	function isObjectTypeIndexer(node, opts) {
	  return (0, _is.default)("ObjectTypeIndexer", node, opts);
	}

	function isObjectTypeProperty(node, opts) {
	  return (0, _is.default)("ObjectTypeProperty", node, opts);
	}

	function isObjectTypeSpreadProperty(node, opts) {
	  return (0, _is.default)("ObjectTypeSpreadProperty", node, opts);
	}

	function isOpaqueType(node, opts) {
	  return (0, _is.default)("OpaqueType", node, opts);
	}

	function isQualifiedTypeIdentifier(node, opts) {
	  return (0, _is.default)("QualifiedTypeIdentifier", node, opts);
	}

	function isStringLiteralTypeAnnotation(node, opts) {
	  return (0, _is.default)("StringLiteralTypeAnnotation", node, opts);
	}

	function isStringTypeAnnotation(node, opts) {
	  return (0, _is.default)("StringTypeAnnotation", node, opts);
	}

	function isThisTypeAnnotation(node, opts) {
	  return (0, _is.default)("ThisTypeAnnotation", node, opts);
	}

	function isTupleTypeAnnotation(node, opts) {
	  return (0, _is.default)("TupleTypeAnnotation", node, opts);
	}

	function isTypeofTypeAnnotation(node, opts) {
	  return (0, _is.default)("TypeofTypeAnnotation", node, opts);
	}

	function isTypeAlias(node, opts) {
	  return (0, _is.default)("TypeAlias", node, opts);
	}

	function isTypeAnnotation(node, opts) {
	  return (0, _is.default)("TypeAnnotation", node, opts);
	}

	function isTypeCastExpression(node, opts) {
	  return (0, _is.default)("TypeCastExpression", node, opts);
	}

	function isTypeParameter(node, opts) {
	  return (0, _is.default)("TypeParameter", node, opts);
	}

	function isTypeParameterDeclaration(node, opts) {
	  return (0, _is.default)("TypeParameterDeclaration", node, opts);
	}

	function isTypeParameterInstantiation(node, opts) {
	  return (0, _is.default)("TypeParameterInstantiation", node, opts);
	}

	function isUnionTypeAnnotation(node, opts) {
	  return (0, _is.default)("UnionTypeAnnotation", node, opts);
	}

	function isVariance(node, opts) {
	  return (0, _is.default)("Variance", node, opts);
	}

	function isVoidTypeAnnotation(node, opts) {
	  return (0, _is.default)("VoidTypeAnnotation", node, opts);
	}

	function isJSXAttribute(node, opts) {
	  return (0, _is.default)("JSXAttribute", node, opts);
	}

	function isJSXClosingElement(node, opts) {
	  return (0, _is.default)("JSXClosingElement", node, opts);
	}

	function isJSXElement(node, opts) {
	  return (0, _is.default)("JSXElement", node, opts);
	}

	function isJSXEmptyExpression(node, opts) {
	  return (0, _is.default)("JSXEmptyExpression", node, opts);
	}

	function isJSXExpressionContainer(node, opts) {
	  return (0, _is.default)("JSXExpressionContainer", node, opts);
	}

	function isJSXSpreadChild(node, opts) {
	  return (0, _is.default)("JSXSpreadChild", node, opts);
	}

	function isJSXIdentifier(node, opts) {
	  return (0, _is.default)("JSXIdentifier", node, opts);
	}

	function isJSXMemberExpression(node, opts) {
	  return (0, _is.default)("JSXMemberExpression", node, opts);
	}

	function isJSXNamespacedName(node, opts) {
	  return (0, _is.default)("JSXNamespacedName", node, opts);
	}

	function isJSXOpeningElement(node, opts) {
	  return (0, _is.default)("JSXOpeningElement", node, opts);
	}

	function isJSXSpreadAttribute(node, opts) {
	  return (0, _is.default)("JSXSpreadAttribute", node, opts);
	}

	function isJSXText(node, opts) {
	  return (0, _is.default)("JSXText", node, opts);
	}

	function isJSXFragment(node, opts) {
	  return (0, _is.default)("JSXFragment", node, opts);
	}

	function isJSXOpeningFragment(node, opts) {
	  return (0, _is.default)("JSXOpeningFragment", node, opts);
	}

	function isJSXClosingFragment(node, opts) {
	  return (0, _is.default)("JSXClosingFragment", node, opts);
	}

	function isNoop(node, opts) {
	  return (0, _is.default)("Noop", node, opts);
	}

	function isParenthesizedExpression(node, opts) {
	  return (0, _is.default)("ParenthesizedExpression", node, opts);
	}

	function isAwaitExpression(node, opts) {
	  return (0, _is.default)("AwaitExpression", node, opts);
	}

	function isBindExpression(node, opts) {
	  return (0, _is.default)("BindExpression", node, opts);
	}

	function isClassProperty(node, opts) {
	  return (0, _is.default)("ClassProperty", node, opts);
	}

	function isOptionalMemberExpression(node, opts) {
	  return (0, _is.default)("OptionalMemberExpression", node, opts);
	}

	function isOptionalCallExpression(node, opts) {
	  return (0, _is.default)("OptionalCallExpression", node, opts);
	}

	function isImport(node, opts) {
	  return (0, _is.default)("Import", node, opts);
	}

	function isDecorator(node, opts) {
	  return (0, _is.default)("Decorator", node, opts);
	}

	function isDoExpression(node, opts) {
	  return (0, _is.default)("DoExpression", node, opts);
	}

	function isExportDefaultSpecifier(node, opts) {
	  return (0, _is.default)("ExportDefaultSpecifier", node, opts);
	}

	function isExportNamespaceSpecifier(node, opts) {
	  return (0, _is.default)("ExportNamespaceSpecifier", node, opts);
	}

	function isTSParameterProperty(node, opts) {
	  return (0, _is.default)("TSParameterProperty", node, opts);
	}

	function isTSDeclareFunction(node, opts) {
	  return (0, _is.default)("TSDeclareFunction", node, opts);
	}

	function isTSDeclareMethod(node, opts) {
	  return (0, _is.default)("TSDeclareMethod", node, opts);
	}

	function isTSQualifiedName(node, opts) {
	  return (0, _is.default)("TSQualifiedName", node, opts);
	}

	function isTSCallSignatureDeclaration(node, opts) {
	  return (0, _is.default)("TSCallSignatureDeclaration", node, opts);
	}

	function isTSConstructSignatureDeclaration(node, opts) {
	  return (0, _is.default)("TSConstructSignatureDeclaration", node, opts);
	}

	function isTSPropertySignature(node, opts) {
	  return (0, _is.default)("TSPropertySignature", node, opts);
	}

	function isTSMethodSignature(node, opts) {
	  return (0, _is.default)("TSMethodSignature", node, opts);
	}

	function isTSIndexSignature(node, opts) {
	  return (0, _is.default)("TSIndexSignature", node, opts);
	}

	function isTSAnyKeyword(node, opts) {
	  return (0, _is.default)("TSAnyKeyword", node, opts);
	}

	function isTSNumberKeyword(node, opts) {
	  return (0, _is.default)("TSNumberKeyword", node, opts);
	}

	function isTSObjectKeyword(node, opts) {
	  return (0, _is.default)("TSObjectKeyword", node, opts);
	}

	function isTSBooleanKeyword(node, opts) {
	  return (0, _is.default)("TSBooleanKeyword", node, opts);
	}

	function isTSStringKeyword(node, opts) {
	  return (0, _is.default)("TSStringKeyword", node, opts);
	}

	function isTSSymbolKeyword(node, opts) {
	  return (0, _is.default)("TSSymbolKeyword", node, opts);
	}

	function isTSVoidKeyword(node, opts) {
	  return (0, _is.default)("TSVoidKeyword", node, opts);
	}

	function isTSUndefinedKeyword(node, opts) {
	  return (0, _is.default)("TSUndefinedKeyword", node, opts);
	}

	function isTSNullKeyword(node, opts) {
	  return (0, _is.default)("TSNullKeyword", node, opts);
	}

	function isTSNeverKeyword(node, opts) {
	  return (0, _is.default)("TSNeverKeyword", node, opts);
	}

	function isTSThisType(node, opts) {
	  return (0, _is.default)("TSThisType", node, opts);
	}

	function isTSFunctionType(node, opts) {
	  return (0, _is.default)("TSFunctionType", node, opts);
	}

	function isTSConstructorType(node, opts) {
	  return (0, _is.default)("TSConstructorType", node, opts);
	}

	function isTSTypeReference(node, opts) {
	  return (0, _is.default)("TSTypeReference", node, opts);
	}

	function isTSTypePredicate(node, opts) {
	  return (0, _is.default)("TSTypePredicate", node, opts);
	}

	function isTSTypeQuery(node, opts) {
	  return (0, _is.default)("TSTypeQuery", node, opts);
	}

	function isTSTypeLiteral(node, opts) {
	  return (0, _is.default)("TSTypeLiteral", node, opts);
	}

	function isTSArrayType(node, opts) {
	  return (0, _is.default)("TSArrayType", node, opts);
	}

	function isTSTupleType(node, opts) {
	  return (0, _is.default)("TSTupleType", node, opts);
	}

	function isTSUnionType(node, opts) {
	  return (0, _is.default)("TSUnionType", node, opts);
	}

	function isTSIntersectionType(node, opts) {
	  return (0, _is.default)("TSIntersectionType", node, opts);
	}

	function isTSParenthesizedType(node, opts) {
	  return (0, _is.default)("TSParenthesizedType", node, opts);
	}

	function isTSTypeOperator(node, opts) {
	  return (0, _is.default)("TSTypeOperator", node, opts);
	}

	function isTSIndexedAccessType(node, opts) {
	  return (0, _is.default)("TSIndexedAccessType", node, opts);
	}

	function isTSMappedType(node, opts) {
	  return (0, _is.default)("TSMappedType", node, opts);
	}

	function isTSLiteralType(node, opts) {
	  return (0, _is.default)("TSLiteralType", node, opts);
	}

	function isTSExpressionWithTypeArguments(node, opts) {
	  return (0, _is.default)("TSExpressionWithTypeArguments", node, opts);
	}

	function isTSInterfaceDeclaration(node, opts) {
	  return (0, _is.default)("TSInterfaceDeclaration", node, opts);
	}

	function isTSInterfaceBody(node, opts) {
	  return (0, _is.default)("TSInterfaceBody", node, opts);
	}

	function isTSTypeAliasDeclaration(node, opts) {
	  return (0, _is.default)("TSTypeAliasDeclaration", node, opts);
	}

	function isTSAsExpression(node, opts) {
	  return (0, _is.default)("TSAsExpression", node, opts);
	}

	function isTSTypeAssertion(node, opts) {
	  return (0, _is.default)("TSTypeAssertion", node, opts);
	}

	function isTSEnumDeclaration(node, opts) {
	  return (0, _is.default)("TSEnumDeclaration", node, opts);
	}

	function isTSEnumMember(node, opts) {
	  return (0, _is.default)("TSEnumMember", node, opts);
	}

	function isTSModuleDeclaration(node, opts) {
	  return (0, _is.default)("TSModuleDeclaration", node, opts);
	}

	function isTSModuleBlock(node, opts) {
	  return (0, _is.default)("TSModuleBlock", node, opts);
	}

	function isTSImportEqualsDeclaration(node, opts) {
	  return (0, _is.default)("TSImportEqualsDeclaration", node, opts);
	}

	function isTSExternalModuleReference(node, opts) {
	  return (0, _is.default)("TSExternalModuleReference", node, opts);
	}

	function isTSNonNullExpression(node, opts) {
	  return (0, _is.default)("TSNonNullExpression", node, opts);
	}

	function isTSExportAssignment(node, opts) {
	  return (0, _is.default)("TSExportAssignment", node, opts);
	}

	function isTSNamespaceExportDeclaration(node, opts) {
	  return (0, _is.default)("TSNamespaceExportDeclaration", node, opts);
	}

	function isTSTypeAnnotation(node, opts) {
	  return (0, _is.default)("TSTypeAnnotation", node, opts);
	}

	function isTSTypeParameterInstantiation(node, opts) {
	  return (0, _is.default)("TSTypeParameterInstantiation", node, opts);
	}

	function isTSTypeParameterDeclaration(node, opts) {
	  return (0, _is.default)("TSTypeParameterDeclaration", node, opts);
	}

	function isTSTypeParameter(node, opts) {
	  return (0, _is.default)("TSTypeParameter", node, opts);
	}

	function isExpression(node, opts) {
	  return (0, _is.default)("Expression", node, opts);
	}

	function isBinary(node, opts) {
	  return (0, _is.default)("Binary", node, opts);
	}

	function isScopable(node, opts) {
	  return (0, _is.default)("Scopable", node, opts);
	}

	function isBlockParent(node, opts) {
	  return (0, _is.default)("BlockParent", node, opts);
	}

	function isBlock(node, opts) {
	  return (0, _is.default)("Block", node, opts);
	}

	function isStatement(node, opts) {
	  return (0, _is.default)("Statement", node, opts);
	}

	function isTerminatorless(node, opts) {
	  return (0, _is.default)("Terminatorless", node, opts);
	}

	function isCompletionStatement(node, opts) {
	  return (0, _is.default)("CompletionStatement", node, opts);
	}

	function isConditional(node, opts) {
	  return (0, _is.default)("Conditional", node, opts);
	}

	function isLoop(node, opts) {
	  return (0, _is.default)("Loop", node, opts);
	}

	function isWhile(node, opts) {
	  return (0, _is.default)("While", node, opts);
	}

	function isExpressionWrapper(node, opts) {
	  return (0, _is.default)("ExpressionWrapper", node, opts);
	}

	function isFor(node, opts) {
	  return (0, _is.default)("For", node, opts);
	}

	function isForXStatement(node, opts) {
	  return (0, _is.default)("ForXStatement", node, opts);
	}

	function isFunction(node, opts) {
	  return (0, _is.default)("Function", node, opts);
	}

	function isFunctionParent(node, opts) {
	  return (0, _is.default)("FunctionParent", node, opts);
	}

	function isPureish(node, opts) {
	  return (0, _is.default)("Pureish", node, opts);
	}

	function isDeclaration(node, opts) {
	  return (0, _is.default)("Declaration", node, opts);
	}

	function isPatternLike(node, opts) {
	  return (0, _is.default)("PatternLike", node, opts);
	}

	function isLVal(node, opts) {
	  return (0, _is.default)("LVal", node, opts);
	}

	function isTSEntityName(node, opts) {
	  return (0, _is.default)("TSEntityName", node, opts);
	}

	function isLiteral(node, opts) {
	  return (0, _is.default)("Literal", node, opts);
	}

	function isImmutable(node, opts) {
	  return (0, _is.default)("Immutable", node, opts);
	}

	function isUserWhitespacable(node, opts) {
	  return (0, _is.default)("UserWhitespacable", node, opts);
	}

	function isMethod(node, opts) {
	  return (0, _is.default)("Method", node, opts);
	}

	function isObjectMember(node, opts) {
	  return (0, _is.default)("ObjectMember", node, opts);
	}

	function isProperty(node, opts) {
	  return (0, _is.default)("Property", node, opts);
	}

	function isUnaryLike(node, opts) {
	  return (0, _is.default)("UnaryLike", node, opts);
	}

	function isPattern(node, opts) {
	  return (0, _is.default)("Pattern", node, opts);
	}

	function isClass(node, opts) {
	  return (0, _is.default)("Class", node, opts);
	}

	function isModuleDeclaration(node, opts) {
	  return (0, _is.default)("ModuleDeclaration", node, opts);
	}

	function isExportDeclaration(node, opts) {
	  return (0, _is.default)("ExportDeclaration", node, opts);
	}

	function isModuleSpecifier(node, opts) {
	  return (0, _is.default)("ModuleSpecifier", node, opts);
	}

	function isFlow(node, opts) {
	  return (0, _is.default)("Flow", node, opts);
	}

	function isFlowType(node, opts) {
	  return (0, _is.default)("FlowType", node, opts);
	}

	function isFlowBaseAnnotation(node, opts) {
	  return (0, _is.default)("FlowBaseAnnotation", node, opts);
	}

	function isFlowDeclaration(node, opts) {
	  return (0, _is.default)("FlowDeclaration", node, opts);
	}

	function isFlowPredicate(node, opts) {
	  return (0, _is.default)("FlowPredicate", node, opts);
	}

	function isJSX(node, opts) {
	  return (0, _is.default)("JSX", node, opts);
	}

	function isTSTypeElement(node, opts) {
	  return (0, _is.default)("TSTypeElement", node, opts);
	}

	function isTSType(node, opts) {
	  return (0, _is.default)("TSType", node, opts);
	}

	function isNumberLiteral(node, opts) {
	  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
	  return (0, _is.default)("NumberLiteral", node, opts);
	}

	function isRegexLiteral(node, opts) {
	  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
	  return (0, _is.default)("RegexLiteral", node, opts);
	}

	function isRestProperty(node, opts) {
	  console.trace("The node type RestProperty has been renamed to RestElement");
	  return (0, _is.default)("RestProperty", node, opts);
	}

	function isSpreadProperty(node, opts) {
	  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
	  return (0, _is.default)("SpreadProperty", node, opts);
	}

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	module.exports = require("graphql");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/toConsumableArray");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.arrayExpression = exports.ArrayExpression = ArrayExpression;
	exports.assignmentExpression = exports.AssignmentExpression = AssignmentExpression;
	exports.binaryExpression = exports.BinaryExpression = BinaryExpression;
	exports.directive = exports.Directive = Directive;
	exports.directiveLiteral = exports.DirectiveLiteral = DirectiveLiteral;
	exports.blockStatement = exports.BlockStatement = BlockStatement;
	exports.breakStatement = exports.BreakStatement = BreakStatement;
	exports.callExpression = exports.CallExpression = CallExpression;
	exports.catchClause = exports.CatchClause = CatchClause;
	exports.conditionalExpression = exports.ConditionalExpression = ConditionalExpression;
	exports.continueStatement = exports.ContinueStatement = ContinueStatement;
	exports.debuggerStatement = exports.DebuggerStatement = DebuggerStatement;
	exports.doWhileStatement = exports.DoWhileStatement = DoWhileStatement;
	exports.emptyStatement = exports.EmptyStatement = EmptyStatement;
	exports.expressionStatement = exports.ExpressionStatement = ExpressionStatement;
	exports.file = exports.File = File;
	exports.forInStatement = exports.ForInStatement = ForInStatement;
	exports.forStatement = exports.ForStatement = ForStatement;
	exports.functionDeclaration = exports.FunctionDeclaration = FunctionDeclaration;
	exports.functionExpression = exports.FunctionExpression = FunctionExpression;
	exports.identifier = exports.Identifier = Identifier;
	exports.ifStatement = exports.IfStatement = IfStatement;
	exports.labeledStatement = exports.LabeledStatement = LabeledStatement;
	exports.stringLiteral = exports.StringLiteral = StringLiteral;
	exports.numericLiteral = exports.NumericLiteral = NumericLiteral;
	exports.nullLiteral = exports.NullLiteral = NullLiteral;
	exports.booleanLiteral = exports.BooleanLiteral = BooleanLiteral;
	exports.regExpLiteral = exports.RegExpLiteral = RegExpLiteral;
	exports.logicalExpression = exports.LogicalExpression = LogicalExpression;
	exports.memberExpression = exports.MemberExpression = MemberExpression;
	exports.newExpression = exports.NewExpression = NewExpression;
	exports.program = exports.Program = Program;
	exports.objectExpression = exports.ObjectExpression = ObjectExpression;
	exports.objectMethod = exports.ObjectMethod = ObjectMethod;
	exports.objectProperty = exports.ObjectProperty = ObjectProperty;
	exports.restElement = exports.RestElement = RestElement;
	exports.returnStatement = exports.ReturnStatement = ReturnStatement;
	exports.sequenceExpression = exports.SequenceExpression = SequenceExpression;
	exports.switchCase = exports.SwitchCase = SwitchCase;
	exports.switchStatement = exports.SwitchStatement = SwitchStatement;
	exports.thisExpression = exports.ThisExpression = ThisExpression;
	exports.throwStatement = exports.ThrowStatement = ThrowStatement;
	exports.tryStatement = exports.TryStatement = TryStatement;
	exports.unaryExpression = exports.UnaryExpression = UnaryExpression;
	exports.updateExpression = exports.UpdateExpression = UpdateExpression;
	exports.variableDeclaration = exports.VariableDeclaration = VariableDeclaration;
	exports.variableDeclarator = exports.VariableDeclarator = VariableDeclarator;
	exports.whileStatement = exports.WhileStatement = WhileStatement;
	exports.withStatement = exports.WithStatement = WithStatement;
	exports.assignmentPattern = exports.AssignmentPattern = AssignmentPattern;
	exports.arrayPattern = exports.ArrayPattern = ArrayPattern;
	exports.arrowFunctionExpression = exports.ArrowFunctionExpression = ArrowFunctionExpression;
	exports.classBody = exports.ClassBody = ClassBody;
	exports.classDeclaration = exports.ClassDeclaration = ClassDeclaration;
	exports.classExpression = exports.ClassExpression = ClassExpression;
	exports.exportAllDeclaration = exports.ExportAllDeclaration = ExportAllDeclaration;
	exports.exportDefaultDeclaration = exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	exports.exportNamedDeclaration = exports.ExportNamedDeclaration = ExportNamedDeclaration;
	exports.exportSpecifier = exports.ExportSpecifier = ExportSpecifier;
	exports.forOfStatement = exports.ForOfStatement = ForOfStatement;
	exports.importDeclaration = exports.ImportDeclaration = ImportDeclaration;
	exports.importDefaultSpecifier = exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	exports.importNamespaceSpecifier = exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	exports.importSpecifier = exports.ImportSpecifier = ImportSpecifier;
	exports.metaProperty = exports.MetaProperty = MetaProperty;
	exports.classMethod = exports.ClassMethod = ClassMethod;
	exports.objectPattern = exports.ObjectPattern = ObjectPattern;
	exports.spreadElement = exports.SpreadElement = SpreadElement;
	exports.super = exports.Super = Super;
	exports.taggedTemplateExpression = exports.TaggedTemplateExpression = TaggedTemplateExpression;
	exports.templateElement = exports.TemplateElement = TemplateElement;
	exports.templateLiteral = exports.TemplateLiteral = TemplateLiteral;
	exports.yieldExpression = exports.YieldExpression = YieldExpression;
	exports.anyTypeAnnotation = exports.AnyTypeAnnotation = AnyTypeAnnotation;
	exports.arrayTypeAnnotation = exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
	exports.booleanTypeAnnotation = exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
	exports.booleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
	exports.nullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
	exports.classImplements = exports.ClassImplements = ClassImplements;
	exports.declareClass = exports.DeclareClass = DeclareClass;
	exports.declareFunction = exports.DeclareFunction = DeclareFunction;
	exports.declareInterface = exports.DeclareInterface = DeclareInterface;
	exports.declareModule = exports.DeclareModule = DeclareModule;
	exports.declareModuleExports = exports.DeclareModuleExports = DeclareModuleExports;
	exports.declareTypeAlias = exports.DeclareTypeAlias = DeclareTypeAlias;
	exports.declareOpaqueType = exports.DeclareOpaqueType = DeclareOpaqueType;
	exports.declareVariable = exports.DeclareVariable = DeclareVariable;
	exports.declareExportDeclaration = exports.DeclareExportDeclaration = DeclareExportDeclaration;
	exports.declareExportAllDeclaration = exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
	exports.declaredPredicate = exports.DeclaredPredicate = DeclaredPredicate;
	exports.existsTypeAnnotation = exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
	exports.functionTypeAnnotation = exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
	exports.functionTypeParam = exports.FunctionTypeParam = FunctionTypeParam;
	exports.genericTypeAnnotation = exports.GenericTypeAnnotation = GenericTypeAnnotation;
	exports.inferredPredicate = exports.InferredPredicate = InferredPredicate;
	exports.interfaceExtends = exports.InterfaceExtends = InterfaceExtends;
	exports.interfaceDeclaration = exports.InterfaceDeclaration = InterfaceDeclaration;
	exports.intersectionTypeAnnotation = exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
	exports.mixedTypeAnnotation = exports.MixedTypeAnnotation = MixedTypeAnnotation;
	exports.emptyTypeAnnotation = exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
	exports.nullableTypeAnnotation = exports.NullableTypeAnnotation = NullableTypeAnnotation;
	exports.numberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = NumberLiteralTypeAnnotation;
	exports.numberTypeAnnotation = exports.NumberTypeAnnotation = NumberTypeAnnotation;
	exports.objectTypeAnnotation = exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
	exports.objectTypeCallProperty = exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
	exports.objectTypeIndexer = exports.ObjectTypeIndexer = ObjectTypeIndexer;
	exports.objectTypeProperty = exports.ObjectTypeProperty = ObjectTypeProperty;
	exports.objectTypeSpreadProperty = exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
	exports.opaqueType = exports.OpaqueType = OpaqueType;
	exports.qualifiedTypeIdentifier = exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
	exports.stringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotation = StringLiteralTypeAnnotation;
	exports.stringTypeAnnotation = exports.StringTypeAnnotation = StringTypeAnnotation;
	exports.thisTypeAnnotation = exports.ThisTypeAnnotation = ThisTypeAnnotation;
	exports.tupleTypeAnnotation = exports.TupleTypeAnnotation = TupleTypeAnnotation;
	exports.typeofTypeAnnotation = exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
	exports.typeAlias = exports.TypeAlias = TypeAlias;
	exports.typeAnnotation = exports.TypeAnnotation = TypeAnnotation;
	exports.typeCastExpression = exports.TypeCastExpression = TypeCastExpression;
	exports.typeParameter = exports.TypeParameter = TypeParameter;
	exports.typeParameterDeclaration = exports.TypeParameterDeclaration = TypeParameterDeclaration;
	exports.typeParameterInstantiation = exports.TypeParameterInstantiation = TypeParameterInstantiation;
	exports.unionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
	exports.variance = exports.Variance = Variance;
	exports.voidTypeAnnotation = exports.VoidTypeAnnotation = VoidTypeAnnotation;
	exports.jSXAttribute = exports.jsxAttribute = exports.JSXAttribute = JSXAttribute;
	exports.jSXClosingElement = exports.jsxClosingElement = exports.JSXClosingElement = JSXClosingElement;
	exports.jSXElement = exports.jsxElement = exports.JSXElement = JSXElement;
	exports.jSXEmptyExpression = exports.jsxEmptyExpression = exports.JSXEmptyExpression = JSXEmptyExpression;
	exports.jSXExpressionContainer = exports.jsxExpressionContainer = exports.JSXExpressionContainer = JSXExpressionContainer;
	exports.jSXSpreadChild = exports.jsxSpreadChild = exports.JSXSpreadChild = JSXSpreadChild;
	exports.jSXIdentifier = exports.jsxIdentifier = exports.JSXIdentifier = JSXIdentifier;
	exports.jSXMemberExpression = exports.jsxMemberExpression = exports.JSXMemberExpression = JSXMemberExpression;
	exports.jSXNamespacedName = exports.jsxNamespacedName = exports.JSXNamespacedName = JSXNamespacedName;
	exports.jSXOpeningElement = exports.jsxOpeningElement = exports.JSXOpeningElement = JSXOpeningElement;
	exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = exports.JSXSpreadAttribute = JSXSpreadAttribute;
	exports.jSXText = exports.jsxText = exports.JSXText = JSXText;
	exports.jSXFragment = exports.jsxFragment = exports.JSXFragment = JSXFragment;
	exports.jSXOpeningFragment = exports.jsxOpeningFragment = exports.JSXOpeningFragment = JSXOpeningFragment;
	exports.jSXClosingFragment = exports.jsxClosingFragment = exports.JSXClosingFragment = JSXClosingFragment;
	exports.noop = exports.Noop = Noop;
	exports.parenthesizedExpression = exports.ParenthesizedExpression = ParenthesizedExpression;
	exports.awaitExpression = exports.AwaitExpression = AwaitExpression;
	exports.bindExpression = exports.BindExpression = BindExpression;
	exports.classProperty = exports.ClassProperty = ClassProperty;
	exports.optionalMemberExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
	exports.optionalCallExpression = exports.OptionalCallExpression = OptionalCallExpression;
	exports.import = exports.Import = Import;
	exports.decorator = exports.Decorator = Decorator;
	exports.doExpression = exports.DoExpression = DoExpression;
	exports.exportDefaultSpecifier = exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
	exports.exportNamespaceSpecifier = exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
	exports.tSParameterProperty = exports.tsParameterProperty = exports.TSParameterProperty = TSParameterProperty;
	exports.tSDeclareFunction = exports.tsDeclareFunction = exports.TSDeclareFunction = TSDeclareFunction;
	exports.tSDeclareMethod = exports.tsDeclareMethod = exports.TSDeclareMethod = TSDeclareMethod;
	exports.tSQualifiedName = exports.tsQualifiedName = exports.TSQualifiedName = TSQualifiedName;
	exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
	exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
	exports.tSPropertySignature = exports.tsPropertySignature = exports.TSPropertySignature = TSPropertySignature;
	exports.tSMethodSignature = exports.tsMethodSignature = exports.TSMethodSignature = TSMethodSignature;
	exports.tSIndexSignature = exports.tsIndexSignature = exports.TSIndexSignature = TSIndexSignature;
	exports.tSAnyKeyword = exports.tsAnyKeyword = exports.TSAnyKeyword = TSAnyKeyword;
	exports.tSNumberKeyword = exports.tsNumberKeyword = exports.TSNumberKeyword = TSNumberKeyword;
	exports.tSObjectKeyword = exports.tsObjectKeyword = exports.TSObjectKeyword = TSObjectKeyword;
	exports.tSBooleanKeyword = exports.tsBooleanKeyword = exports.TSBooleanKeyword = TSBooleanKeyword;
	exports.tSStringKeyword = exports.tsStringKeyword = exports.TSStringKeyword = TSStringKeyword;
	exports.tSSymbolKeyword = exports.tsSymbolKeyword = exports.TSSymbolKeyword = TSSymbolKeyword;
	exports.tSVoidKeyword = exports.tsVoidKeyword = exports.TSVoidKeyword = TSVoidKeyword;
	exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = exports.TSUndefinedKeyword = TSUndefinedKeyword;
	exports.tSNullKeyword = exports.tsNullKeyword = exports.TSNullKeyword = TSNullKeyword;
	exports.tSNeverKeyword = exports.tsNeverKeyword = exports.TSNeverKeyword = TSNeverKeyword;
	exports.tSThisType = exports.tsThisType = exports.TSThisType = TSThisType;
	exports.tSFunctionType = exports.tsFunctionType = exports.TSFunctionType = TSFunctionType;
	exports.tSConstructorType = exports.tsConstructorType = exports.TSConstructorType = TSConstructorType;
	exports.tSTypeReference = exports.tsTypeReference = exports.TSTypeReference = TSTypeReference;
	exports.tSTypePredicate = exports.tsTypePredicate = exports.TSTypePredicate = TSTypePredicate;
	exports.tSTypeQuery = exports.tsTypeQuery = exports.TSTypeQuery = TSTypeQuery;
	exports.tSTypeLiteral = exports.tsTypeLiteral = exports.TSTypeLiteral = TSTypeLiteral;
	exports.tSArrayType = exports.tsArrayType = exports.TSArrayType = TSArrayType;
	exports.tSTupleType = exports.tsTupleType = exports.TSTupleType = TSTupleType;
	exports.tSUnionType = exports.tsUnionType = exports.TSUnionType = TSUnionType;
	exports.tSIntersectionType = exports.tsIntersectionType = exports.TSIntersectionType = TSIntersectionType;
	exports.tSParenthesizedType = exports.tsParenthesizedType = exports.TSParenthesizedType = TSParenthesizedType;
	exports.tSTypeOperator = exports.tsTypeOperator = exports.TSTypeOperator = TSTypeOperator;
	exports.tSIndexedAccessType = exports.tsIndexedAccessType = exports.TSIndexedAccessType = TSIndexedAccessType;
	exports.tSMappedType = exports.tsMappedType = exports.TSMappedType = TSMappedType;
	exports.tSLiteralType = exports.tsLiteralType = exports.TSLiteralType = TSLiteralType;
	exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
	exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
	exports.tSInterfaceBody = exports.tsInterfaceBody = exports.TSInterfaceBody = TSInterfaceBody;
	exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
	exports.tSAsExpression = exports.tsAsExpression = exports.TSAsExpression = TSAsExpression;
	exports.tSTypeAssertion = exports.tsTypeAssertion = exports.TSTypeAssertion = TSTypeAssertion;
	exports.tSEnumDeclaration = exports.tsEnumDeclaration = exports.TSEnumDeclaration = TSEnumDeclaration;
	exports.tSEnumMember = exports.tsEnumMember = exports.TSEnumMember = TSEnumMember;
	exports.tSModuleDeclaration = exports.tsModuleDeclaration = exports.TSModuleDeclaration = TSModuleDeclaration;
	exports.tSModuleBlock = exports.tsModuleBlock = exports.TSModuleBlock = TSModuleBlock;
	exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
	exports.tSExternalModuleReference = exports.tsExternalModuleReference = exports.TSExternalModuleReference = TSExternalModuleReference;
	exports.tSNonNullExpression = exports.tsNonNullExpression = exports.TSNonNullExpression = TSNonNullExpression;
	exports.tSExportAssignment = exports.tsExportAssignment = exports.TSExportAssignment = TSExportAssignment;
	exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
	exports.tSTypeAnnotation = exports.tsTypeAnnotation = exports.TSTypeAnnotation = TSTypeAnnotation;
	exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
	exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = exports.TSTypeParameterDeclaration = TSTypeParameterDeclaration;
	exports.tSTypeParameter = exports.tsTypeParameter = exports.TSTypeParameter = TSTypeParameter;
	exports.numberLiteral = exports.NumberLiteral = NumberLiteral;
	exports.regexLiteral = exports.RegexLiteral = RegexLiteral;
	exports.restProperty = exports.RestProperty = RestProperty;
	exports.spreadProperty = exports.SpreadProperty = SpreadProperty;

	var _builder = _interopRequireDefault(__webpack_require__(100));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function ArrayExpression() {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return _builder.default.apply(void 0, ["ArrayExpression"].concat(args));
	}

	function AssignmentExpression() {
	  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    args[_key2] = arguments[_key2];
	  }

	  return _builder.default.apply(void 0, ["AssignmentExpression"].concat(args));
	}

	function BinaryExpression() {
	  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	    args[_key3] = arguments[_key3];
	  }

	  return _builder.default.apply(void 0, ["BinaryExpression"].concat(args));
	}

	function Directive() {
	  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	    args[_key4] = arguments[_key4];
	  }

	  return _builder.default.apply(void 0, ["Directive"].concat(args));
	}

	function DirectiveLiteral() {
	  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	    args[_key5] = arguments[_key5];
	  }

	  return _builder.default.apply(void 0, ["DirectiveLiteral"].concat(args));
	}

	function BlockStatement() {
	  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	    args[_key6] = arguments[_key6];
	  }

	  return _builder.default.apply(void 0, ["BlockStatement"].concat(args));
	}

	function BreakStatement() {
	  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
	    args[_key7] = arguments[_key7];
	  }

	  return _builder.default.apply(void 0, ["BreakStatement"].concat(args));
	}

	function CallExpression() {
	  for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
	    args[_key8] = arguments[_key8];
	  }

	  return _builder.default.apply(void 0, ["CallExpression"].concat(args));
	}

	function CatchClause() {
	  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
	    args[_key9] = arguments[_key9];
	  }

	  return _builder.default.apply(void 0, ["CatchClause"].concat(args));
	}

	function ConditionalExpression() {
	  for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
	    args[_key10] = arguments[_key10];
	  }

	  return _builder.default.apply(void 0, ["ConditionalExpression"].concat(args));
	}

	function ContinueStatement() {
	  for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
	    args[_key11] = arguments[_key11];
	  }

	  return _builder.default.apply(void 0, ["ContinueStatement"].concat(args));
	}

	function DebuggerStatement() {
	  for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
	    args[_key12] = arguments[_key12];
	  }

	  return _builder.default.apply(void 0, ["DebuggerStatement"].concat(args));
	}

	function DoWhileStatement() {
	  for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
	    args[_key13] = arguments[_key13];
	  }

	  return _builder.default.apply(void 0, ["DoWhileStatement"].concat(args));
	}

	function EmptyStatement() {
	  for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
	    args[_key14] = arguments[_key14];
	  }

	  return _builder.default.apply(void 0, ["EmptyStatement"].concat(args));
	}

	function ExpressionStatement() {
	  for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
	    args[_key15] = arguments[_key15];
	  }

	  return _builder.default.apply(void 0, ["ExpressionStatement"].concat(args));
	}

	function File() {
	  for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
	    args[_key16] = arguments[_key16];
	  }

	  return _builder.default.apply(void 0, ["File"].concat(args));
	}

	function ForInStatement() {
	  for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
	    args[_key17] = arguments[_key17];
	  }

	  return _builder.default.apply(void 0, ["ForInStatement"].concat(args));
	}

	function ForStatement() {
	  for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
	    args[_key18] = arguments[_key18];
	  }

	  return _builder.default.apply(void 0, ["ForStatement"].concat(args));
	}

	function FunctionDeclaration() {
	  for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
	    args[_key19] = arguments[_key19];
	  }

	  return _builder.default.apply(void 0, ["FunctionDeclaration"].concat(args));
	}

	function FunctionExpression() {
	  for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
	    args[_key20] = arguments[_key20];
	  }

	  return _builder.default.apply(void 0, ["FunctionExpression"].concat(args));
	}

	function Identifier() {
	  for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
	    args[_key21] = arguments[_key21];
	  }

	  return _builder.default.apply(void 0, ["Identifier"].concat(args));
	}

	function IfStatement() {
	  for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
	    args[_key22] = arguments[_key22];
	  }

	  return _builder.default.apply(void 0, ["IfStatement"].concat(args));
	}

	function LabeledStatement() {
	  for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
	    args[_key23] = arguments[_key23];
	  }

	  return _builder.default.apply(void 0, ["LabeledStatement"].concat(args));
	}

	function StringLiteral() {
	  for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
	    args[_key24] = arguments[_key24];
	  }

	  return _builder.default.apply(void 0, ["StringLiteral"].concat(args));
	}

	function NumericLiteral() {
	  for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
	    args[_key25] = arguments[_key25];
	  }

	  return _builder.default.apply(void 0, ["NumericLiteral"].concat(args));
	}

	function NullLiteral() {
	  for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {
	    args[_key26] = arguments[_key26];
	  }

	  return _builder.default.apply(void 0, ["NullLiteral"].concat(args));
	}

	function BooleanLiteral() {
	  for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {
	    args[_key27] = arguments[_key27];
	  }

	  return _builder.default.apply(void 0, ["BooleanLiteral"].concat(args));
	}

	function RegExpLiteral() {
	  for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {
	    args[_key28] = arguments[_key28];
	  }

	  return _builder.default.apply(void 0, ["RegExpLiteral"].concat(args));
	}

	function LogicalExpression() {
	  for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {
	    args[_key29] = arguments[_key29];
	  }

	  return _builder.default.apply(void 0, ["LogicalExpression"].concat(args));
	}

	function MemberExpression() {
	  for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {
	    args[_key30] = arguments[_key30];
	  }

	  return _builder.default.apply(void 0, ["MemberExpression"].concat(args));
	}

	function NewExpression() {
	  for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {
	    args[_key31] = arguments[_key31];
	  }

	  return _builder.default.apply(void 0, ["NewExpression"].concat(args));
	}

	function Program() {
	  for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {
	    args[_key32] = arguments[_key32];
	  }

	  return _builder.default.apply(void 0, ["Program"].concat(args));
	}

	function ObjectExpression() {
	  for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {
	    args[_key33] = arguments[_key33];
	  }

	  return _builder.default.apply(void 0, ["ObjectExpression"].concat(args));
	}

	function ObjectMethod() {
	  for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {
	    args[_key34] = arguments[_key34];
	  }

	  return _builder.default.apply(void 0, ["ObjectMethod"].concat(args));
	}

	function ObjectProperty() {
	  for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {
	    args[_key35] = arguments[_key35];
	  }

	  return _builder.default.apply(void 0, ["ObjectProperty"].concat(args));
	}

	function RestElement() {
	  for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {
	    args[_key36] = arguments[_key36];
	  }

	  return _builder.default.apply(void 0, ["RestElement"].concat(args));
	}

	function ReturnStatement() {
	  for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {
	    args[_key37] = arguments[_key37];
	  }

	  return _builder.default.apply(void 0, ["ReturnStatement"].concat(args));
	}

	function SequenceExpression() {
	  for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {
	    args[_key38] = arguments[_key38];
	  }

	  return _builder.default.apply(void 0, ["SequenceExpression"].concat(args));
	}

	function SwitchCase() {
	  for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {
	    args[_key39] = arguments[_key39];
	  }

	  return _builder.default.apply(void 0, ["SwitchCase"].concat(args));
	}

	function SwitchStatement() {
	  for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {
	    args[_key40] = arguments[_key40];
	  }

	  return _builder.default.apply(void 0, ["SwitchStatement"].concat(args));
	}

	function ThisExpression() {
	  for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {
	    args[_key41] = arguments[_key41];
	  }

	  return _builder.default.apply(void 0, ["ThisExpression"].concat(args));
	}

	function ThrowStatement() {
	  for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {
	    args[_key42] = arguments[_key42];
	  }

	  return _builder.default.apply(void 0, ["ThrowStatement"].concat(args));
	}

	function TryStatement() {
	  for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {
	    args[_key43] = arguments[_key43];
	  }

	  return _builder.default.apply(void 0, ["TryStatement"].concat(args));
	}

	function UnaryExpression() {
	  for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {
	    args[_key44] = arguments[_key44];
	  }

	  return _builder.default.apply(void 0, ["UnaryExpression"].concat(args));
	}

	function UpdateExpression() {
	  for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {
	    args[_key45] = arguments[_key45];
	  }

	  return _builder.default.apply(void 0, ["UpdateExpression"].concat(args));
	}

	function VariableDeclaration() {
	  for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {
	    args[_key46] = arguments[_key46];
	  }

	  return _builder.default.apply(void 0, ["VariableDeclaration"].concat(args));
	}

	function VariableDeclarator() {
	  for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {
	    args[_key47] = arguments[_key47];
	  }

	  return _builder.default.apply(void 0, ["VariableDeclarator"].concat(args));
	}

	function WhileStatement() {
	  for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {
	    args[_key48] = arguments[_key48];
	  }

	  return _builder.default.apply(void 0, ["WhileStatement"].concat(args));
	}

	function WithStatement() {
	  for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {
	    args[_key49] = arguments[_key49];
	  }

	  return _builder.default.apply(void 0, ["WithStatement"].concat(args));
	}

	function AssignmentPattern() {
	  for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {
	    args[_key50] = arguments[_key50];
	  }

	  return _builder.default.apply(void 0, ["AssignmentPattern"].concat(args));
	}

	function ArrayPattern() {
	  for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {
	    args[_key51] = arguments[_key51];
	  }

	  return _builder.default.apply(void 0, ["ArrayPattern"].concat(args));
	}

	function ArrowFunctionExpression() {
	  for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {
	    args[_key52] = arguments[_key52];
	  }

	  return _builder.default.apply(void 0, ["ArrowFunctionExpression"].concat(args));
	}

	function ClassBody() {
	  for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {
	    args[_key53] = arguments[_key53];
	  }

	  return _builder.default.apply(void 0, ["ClassBody"].concat(args));
	}

	function ClassDeclaration() {
	  for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {
	    args[_key54] = arguments[_key54];
	  }

	  return _builder.default.apply(void 0, ["ClassDeclaration"].concat(args));
	}

	function ClassExpression() {
	  for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {
	    args[_key55] = arguments[_key55];
	  }

	  return _builder.default.apply(void 0, ["ClassExpression"].concat(args));
	}

	function ExportAllDeclaration() {
	  for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {
	    args[_key56] = arguments[_key56];
	  }

	  return _builder.default.apply(void 0, ["ExportAllDeclaration"].concat(args));
	}

	function ExportDefaultDeclaration() {
	  for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {
	    args[_key57] = arguments[_key57];
	  }

	  return _builder.default.apply(void 0, ["ExportDefaultDeclaration"].concat(args));
	}

	function ExportNamedDeclaration() {
	  for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {
	    args[_key58] = arguments[_key58];
	  }

	  return _builder.default.apply(void 0, ["ExportNamedDeclaration"].concat(args));
	}

	function ExportSpecifier() {
	  for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {
	    args[_key59] = arguments[_key59];
	  }

	  return _builder.default.apply(void 0, ["ExportSpecifier"].concat(args));
	}

	function ForOfStatement() {
	  for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {
	    args[_key60] = arguments[_key60];
	  }

	  return _builder.default.apply(void 0, ["ForOfStatement"].concat(args));
	}

	function ImportDeclaration() {
	  for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {
	    args[_key61] = arguments[_key61];
	  }

	  return _builder.default.apply(void 0, ["ImportDeclaration"].concat(args));
	}

	function ImportDefaultSpecifier() {
	  for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {
	    args[_key62] = arguments[_key62];
	  }

	  return _builder.default.apply(void 0, ["ImportDefaultSpecifier"].concat(args));
	}

	function ImportNamespaceSpecifier() {
	  for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {
	    args[_key63] = arguments[_key63];
	  }

	  return _builder.default.apply(void 0, ["ImportNamespaceSpecifier"].concat(args));
	}

	function ImportSpecifier() {
	  for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {
	    args[_key64] = arguments[_key64];
	  }

	  return _builder.default.apply(void 0, ["ImportSpecifier"].concat(args));
	}

	function MetaProperty() {
	  for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {
	    args[_key65] = arguments[_key65];
	  }

	  return _builder.default.apply(void 0, ["MetaProperty"].concat(args));
	}

	function ClassMethod() {
	  for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {
	    args[_key66] = arguments[_key66];
	  }

	  return _builder.default.apply(void 0, ["ClassMethod"].concat(args));
	}

	function ObjectPattern() {
	  for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {
	    args[_key67] = arguments[_key67];
	  }

	  return _builder.default.apply(void 0, ["ObjectPattern"].concat(args));
	}

	function SpreadElement() {
	  for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {
	    args[_key68] = arguments[_key68];
	  }

	  return _builder.default.apply(void 0, ["SpreadElement"].concat(args));
	}

	function Super() {
	  for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {
	    args[_key69] = arguments[_key69];
	  }

	  return _builder.default.apply(void 0, ["Super"].concat(args));
	}

	function TaggedTemplateExpression() {
	  for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {
	    args[_key70] = arguments[_key70];
	  }

	  return _builder.default.apply(void 0, ["TaggedTemplateExpression"].concat(args));
	}

	function TemplateElement() {
	  for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {
	    args[_key71] = arguments[_key71];
	  }

	  return _builder.default.apply(void 0, ["TemplateElement"].concat(args));
	}

	function TemplateLiteral() {
	  for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {
	    args[_key72] = arguments[_key72];
	  }

	  return _builder.default.apply(void 0, ["TemplateLiteral"].concat(args));
	}

	function YieldExpression() {
	  for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {
	    args[_key73] = arguments[_key73];
	  }

	  return _builder.default.apply(void 0, ["YieldExpression"].concat(args));
	}

	function AnyTypeAnnotation() {
	  for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {
	    args[_key74] = arguments[_key74];
	  }

	  return _builder.default.apply(void 0, ["AnyTypeAnnotation"].concat(args));
	}

	function ArrayTypeAnnotation() {
	  for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {
	    args[_key75] = arguments[_key75];
	  }

	  return _builder.default.apply(void 0, ["ArrayTypeAnnotation"].concat(args));
	}

	function BooleanTypeAnnotation() {
	  for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {
	    args[_key76] = arguments[_key76];
	  }

	  return _builder.default.apply(void 0, ["BooleanTypeAnnotation"].concat(args));
	}

	function BooleanLiteralTypeAnnotation() {
	  for (var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++) {
	    args[_key77] = arguments[_key77];
	  }

	  return _builder.default.apply(void 0, ["BooleanLiteralTypeAnnotation"].concat(args));
	}

	function NullLiteralTypeAnnotation() {
	  for (var _len78 = arguments.length, args = new Array(_len78), _key78 = 0; _key78 < _len78; _key78++) {
	    args[_key78] = arguments[_key78];
	  }

	  return _builder.default.apply(void 0, ["NullLiteralTypeAnnotation"].concat(args));
	}

	function ClassImplements() {
	  for (var _len79 = arguments.length, args = new Array(_len79), _key79 = 0; _key79 < _len79; _key79++) {
	    args[_key79] = arguments[_key79];
	  }

	  return _builder.default.apply(void 0, ["ClassImplements"].concat(args));
	}

	function DeclareClass() {
	  for (var _len80 = arguments.length, args = new Array(_len80), _key80 = 0; _key80 < _len80; _key80++) {
	    args[_key80] = arguments[_key80];
	  }

	  return _builder.default.apply(void 0, ["DeclareClass"].concat(args));
	}

	function DeclareFunction() {
	  for (var _len81 = arguments.length, args = new Array(_len81), _key81 = 0; _key81 < _len81; _key81++) {
	    args[_key81] = arguments[_key81];
	  }

	  return _builder.default.apply(void 0, ["DeclareFunction"].concat(args));
	}

	function DeclareInterface() {
	  for (var _len82 = arguments.length, args = new Array(_len82), _key82 = 0; _key82 < _len82; _key82++) {
	    args[_key82] = arguments[_key82];
	  }

	  return _builder.default.apply(void 0, ["DeclareInterface"].concat(args));
	}

	function DeclareModule() {
	  for (var _len83 = arguments.length, args = new Array(_len83), _key83 = 0; _key83 < _len83; _key83++) {
	    args[_key83] = arguments[_key83];
	  }

	  return _builder.default.apply(void 0, ["DeclareModule"].concat(args));
	}

	function DeclareModuleExports() {
	  for (var _len84 = arguments.length, args = new Array(_len84), _key84 = 0; _key84 < _len84; _key84++) {
	    args[_key84] = arguments[_key84];
	  }

	  return _builder.default.apply(void 0, ["DeclareModuleExports"].concat(args));
	}

	function DeclareTypeAlias() {
	  for (var _len85 = arguments.length, args = new Array(_len85), _key85 = 0; _key85 < _len85; _key85++) {
	    args[_key85] = arguments[_key85];
	  }

	  return _builder.default.apply(void 0, ["DeclareTypeAlias"].concat(args));
	}

	function DeclareOpaqueType() {
	  for (var _len86 = arguments.length, args = new Array(_len86), _key86 = 0; _key86 < _len86; _key86++) {
	    args[_key86] = arguments[_key86];
	  }

	  return _builder.default.apply(void 0, ["DeclareOpaqueType"].concat(args));
	}

	function DeclareVariable() {
	  for (var _len87 = arguments.length, args = new Array(_len87), _key87 = 0; _key87 < _len87; _key87++) {
	    args[_key87] = arguments[_key87];
	  }

	  return _builder.default.apply(void 0, ["DeclareVariable"].concat(args));
	}

	function DeclareExportDeclaration() {
	  for (var _len88 = arguments.length, args = new Array(_len88), _key88 = 0; _key88 < _len88; _key88++) {
	    args[_key88] = arguments[_key88];
	  }

	  return _builder.default.apply(void 0, ["DeclareExportDeclaration"].concat(args));
	}

	function DeclareExportAllDeclaration() {
	  for (var _len89 = arguments.length, args = new Array(_len89), _key89 = 0; _key89 < _len89; _key89++) {
	    args[_key89] = arguments[_key89];
	  }

	  return _builder.default.apply(void 0, ["DeclareExportAllDeclaration"].concat(args));
	}

	function DeclaredPredicate() {
	  for (var _len90 = arguments.length, args = new Array(_len90), _key90 = 0; _key90 < _len90; _key90++) {
	    args[_key90] = arguments[_key90];
	  }

	  return _builder.default.apply(void 0, ["DeclaredPredicate"].concat(args));
	}

	function ExistsTypeAnnotation() {
	  for (var _len91 = arguments.length, args = new Array(_len91), _key91 = 0; _key91 < _len91; _key91++) {
	    args[_key91] = arguments[_key91];
	  }

	  return _builder.default.apply(void 0, ["ExistsTypeAnnotation"].concat(args));
	}

	function FunctionTypeAnnotation() {
	  for (var _len92 = arguments.length, args = new Array(_len92), _key92 = 0; _key92 < _len92; _key92++) {
	    args[_key92] = arguments[_key92];
	  }

	  return _builder.default.apply(void 0, ["FunctionTypeAnnotation"].concat(args));
	}

	function FunctionTypeParam() {
	  for (var _len93 = arguments.length, args = new Array(_len93), _key93 = 0; _key93 < _len93; _key93++) {
	    args[_key93] = arguments[_key93];
	  }

	  return _builder.default.apply(void 0, ["FunctionTypeParam"].concat(args));
	}

	function GenericTypeAnnotation() {
	  for (var _len94 = arguments.length, args = new Array(_len94), _key94 = 0; _key94 < _len94; _key94++) {
	    args[_key94] = arguments[_key94];
	  }

	  return _builder.default.apply(void 0, ["GenericTypeAnnotation"].concat(args));
	}

	function InferredPredicate() {
	  for (var _len95 = arguments.length, args = new Array(_len95), _key95 = 0; _key95 < _len95; _key95++) {
	    args[_key95] = arguments[_key95];
	  }

	  return _builder.default.apply(void 0, ["InferredPredicate"].concat(args));
	}

	function InterfaceExtends() {
	  for (var _len96 = arguments.length, args = new Array(_len96), _key96 = 0; _key96 < _len96; _key96++) {
	    args[_key96] = arguments[_key96];
	  }

	  return _builder.default.apply(void 0, ["InterfaceExtends"].concat(args));
	}

	function InterfaceDeclaration() {
	  for (var _len97 = arguments.length, args = new Array(_len97), _key97 = 0; _key97 < _len97; _key97++) {
	    args[_key97] = arguments[_key97];
	  }

	  return _builder.default.apply(void 0, ["InterfaceDeclaration"].concat(args));
	}

	function IntersectionTypeAnnotation() {
	  for (var _len98 = arguments.length, args = new Array(_len98), _key98 = 0; _key98 < _len98; _key98++) {
	    args[_key98] = arguments[_key98];
	  }

	  return _builder.default.apply(void 0, ["IntersectionTypeAnnotation"].concat(args));
	}

	function MixedTypeAnnotation() {
	  for (var _len99 = arguments.length, args = new Array(_len99), _key99 = 0; _key99 < _len99; _key99++) {
	    args[_key99] = arguments[_key99];
	  }

	  return _builder.default.apply(void 0, ["MixedTypeAnnotation"].concat(args));
	}

	function EmptyTypeAnnotation() {
	  for (var _len100 = arguments.length, args = new Array(_len100), _key100 = 0; _key100 < _len100; _key100++) {
	    args[_key100] = arguments[_key100];
	  }

	  return _builder.default.apply(void 0, ["EmptyTypeAnnotation"].concat(args));
	}

	function NullableTypeAnnotation() {
	  for (var _len101 = arguments.length, args = new Array(_len101), _key101 = 0; _key101 < _len101; _key101++) {
	    args[_key101] = arguments[_key101];
	  }

	  return _builder.default.apply(void 0, ["NullableTypeAnnotation"].concat(args));
	}

	function NumberLiteralTypeAnnotation() {
	  for (var _len102 = arguments.length, args = new Array(_len102), _key102 = 0; _key102 < _len102; _key102++) {
	    args[_key102] = arguments[_key102];
	  }

	  return _builder.default.apply(void 0, ["NumberLiteralTypeAnnotation"].concat(args));
	}

	function NumberTypeAnnotation() {
	  for (var _len103 = arguments.length, args = new Array(_len103), _key103 = 0; _key103 < _len103; _key103++) {
	    args[_key103] = arguments[_key103];
	  }

	  return _builder.default.apply(void 0, ["NumberTypeAnnotation"].concat(args));
	}

	function ObjectTypeAnnotation() {
	  for (var _len104 = arguments.length, args = new Array(_len104), _key104 = 0; _key104 < _len104; _key104++) {
	    args[_key104] = arguments[_key104];
	  }

	  return _builder.default.apply(void 0, ["ObjectTypeAnnotation"].concat(args));
	}

	function ObjectTypeCallProperty() {
	  for (var _len105 = arguments.length, args = new Array(_len105), _key105 = 0; _key105 < _len105; _key105++) {
	    args[_key105] = arguments[_key105];
	  }

	  return _builder.default.apply(void 0, ["ObjectTypeCallProperty"].concat(args));
	}

	function ObjectTypeIndexer() {
	  for (var _len106 = arguments.length, args = new Array(_len106), _key106 = 0; _key106 < _len106; _key106++) {
	    args[_key106] = arguments[_key106];
	  }

	  return _builder.default.apply(void 0, ["ObjectTypeIndexer"].concat(args));
	}

	function ObjectTypeProperty() {
	  for (var _len107 = arguments.length, args = new Array(_len107), _key107 = 0; _key107 < _len107; _key107++) {
	    args[_key107] = arguments[_key107];
	  }

	  return _builder.default.apply(void 0, ["ObjectTypeProperty"].concat(args));
	}

	function ObjectTypeSpreadProperty() {
	  for (var _len108 = arguments.length, args = new Array(_len108), _key108 = 0; _key108 < _len108; _key108++) {
	    args[_key108] = arguments[_key108];
	  }

	  return _builder.default.apply(void 0, ["ObjectTypeSpreadProperty"].concat(args));
	}

	function OpaqueType() {
	  for (var _len109 = arguments.length, args = new Array(_len109), _key109 = 0; _key109 < _len109; _key109++) {
	    args[_key109] = arguments[_key109];
	  }

	  return _builder.default.apply(void 0, ["OpaqueType"].concat(args));
	}

	function QualifiedTypeIdentifier() {
	  for (var _len110 = arguments.length, args = new Array(_len110), _key110 = 0; _key110 < _len110; _key110++) {
	    args[_key110] = arguments[_key110];
	  }

	  return _builder.default.apply(void 0, ["QualifiedTypeIdentifier"].concat(args));
	}

	function StringLiteralTypeAnnotation() {
	  for (var _len111 = arguments.length, args = new Array(_len111), _key111 = 0; _key111 < _len111; _key111++) {
	    args[_key111] = arguments[_key111];
	  }

	  return _builder.default.apply(void 0, ["StringLiteralTypeAnnotation"].concat(args));
	}

	function StringTypeAnnotation() {
	  for (var _len112 = arguments.length, args = new Array(_len112), _key112 = 0; _key112 < _len112; _key112++) {
	    args[_key112] = arguments[_key112];
	  }

	  return _builder.default.apply(void 0, ["StringTypeAnnotation"].concat(args));
	}

	function ThisTypeAnnotation() {
	  for (var _len113 = arguments.length, args = new Array(_len113), _key113 = 0; _key113 < _len113; _key113++) {
	    args[_key113] = arguments[_key113];
	  }

	  return _builder.default.apply(void 0, ["ThisTypeAnnotation"].concat(args));
	}

	function TupleTypeAnnotation() {
	  for (var _len114 = arguments.length, args = new Array(_len114), _key114 = 0; _key114 < _len114; _key114++) {
	    args[_key114] = arguments[_key114];
	  }

	  return _builder.default.apply(void 0, ["TupleTypeAnnotation"].concat(args));
	}

	function TypeofTypeAnnotation() {
	  for (var _len115 = arguments.length, args = new Array(_len115), _key115 = 0; _key115 < _len115; _key115++) {
	    args[_key115] = arguments[_key115];
	  }

	  return _builder.default.apply(void 0, ["TypeofTypeAnnotation"].concat(args));
	}

	function TypeAlias() {
	  for (var _len116 = arguments.length, args = new Array(_len116), _key116 = 0; _key116 < _len116; _key116++) {
	    args[_key116] = arguments[_key116];
	  }

	  return _builder.default.apply(void 0, ["TypeAlias"].concat(args));
	}

	function TypeAnnotation() {
	  for (var _len117 = arguments.length, args = new Array(_len117), _key117 = 0; _key117 < _len117; _key117++) {
	    args[_key117] = arguments[_key117];
	  }

	  return _builder.default.apply(void 0, ["TypeAnnotation"].concat(args));
	}

	function TypeCastExpression() {
	  for (var _len118 = arguments.length, args = new Array(_len118), _key118 = 0; _key118 < _len118; _key118++) {
	    args[_key118] = arguments[_key118];
	  }

	  return _builder.default.apply(void 0, ["TypeCastExpression"].concat(args));
	}

	function TypeParameter() {
	  for (var _len119 = arguments.length, args = new Array(_len119), _key119 = 0; _key119 < _len119; _key119++) {
	    args[_key119] = arguments[_key119];
	  }

	  return _builder.default.apply(void 0, ["TypeParameter"].concat(args));
	}

	function TypeParameterDeclaration() {
	  for (var _len120 = arguments.length, args = new Array(_len120), _key120 = 0; _key120 < _len120; _key120++) {
	    args[_key120] = arguments[_key120];
	  }

	  return _builder.default.apply(void 0, ["TypeParameterDeclaration"].concat(args));
	}

	function TypeParameterInstantiation() {
	  for (var _len121 = arguments.length, args = new Array(_len121), _key121 = 0; _key121 < _len121; _key121++) {
	    args[_key121] = arguments[_key121];
	  }

	  return _builder.default.apply(void 0, ["TypeParameterInstantiation"].concat(args));
	}

	function UnionTypeAnnotation() {
	  for (var _len122 = arguments.length, args = new Array(_len122), _key122 = 0; _key122 < _len122; _key122++) {
	    args[_key122] = arguments[_key122];
	  }

	  return _builder.default.apply(void 0, ["UnionTypeAnnotation"].concat(args));
	}

	function Variance() {
	  for (var _len123 = arguments.length, args = new Array(_len123), _key123 = 0; _key123 < _len123; _key123++) {
	    args[_key123] = arguments[_key123];
	  }

	  return _builder.default.apply(void 0, ["Variance"].concat(args));
	}

	function VoidTypeAnnotation() {
	  for (var _len124 = arguments.length, args = new Array(_len124), _key124 = 0; _key124 < _len124; _key124++) {
	    args[_key124] = arguments[_key124];
	  }

	  return _builder.default.apply(void 0, ["VoidTypeAnnotation"].concat(args));
	}

	function JSXAttribute() {
	  for (var _len125 = arguments.length, args = new Array(_len125), _key125 = 0; _key125 < _len125; _key125++) {
	    args[_key125] = arguments[_key125];
	  }

	  return _builder.default.apply(void 0, ["JSXAttribute"].concat(args));
	}

	function JSXClosingElement() {
	  for (var _len126 = arguments.length, args = new Array(_len126), _key126 = 0; _key126 < _len126; _key126++) {
	    args[_key126] = arguments[_key126];
	  }

	  return _builder.default.apply(void 0, ["JSXClosingElement"].concat(args));
	}

	function JSXElement() {
	  for (var _len127 = arguments.length, args = new Array(_len127), _key127 = 0; _key127 < _len127; _key127++) {
	    args[_key127] = arguments[_key127];
	  }

	  return _builder.default.apply(void 0, ["JSXElement"].concat(args));
	}

	function JSXEmptyExpression() {
	  for (var _len128 = arguments.length, args = new Array(_len128), _key128 = 0; _key128 < _len128; _key128++) {
	    args[_key128] = arguments[_key128];
	  }

	  return _builder.default.apply(void 0, ["JSXEmptyExpression"].concat(args));
	}

	function JSXExpressionContainer() {
	  for (var _len129 = arguments.length, args = new Array(_len129), _key129 = 0; _key129 < _len129; _key129++) {
	    args[_key129] = arguments[_key129];
	  }

	  return _builder.default.apply(void 0, ["JSXExpressionContainer"].concat(args));
	}

	function JSXSpreadChild() {
	  for (var _len130 = arguments.length, args = new Array(_len130), _key130 = 0; _key130 < _len130; _key130++) {
	    args[_key130] = arguments[_key130];
	  }

	  return _builder.default.apply(void 0, ["JSXSpreadChild"].concat(args));
	}

	function JSXIdentifier() {
	  for (var _len131 = arguments.length, args = new Array(_len131), _key131 = 0; _key131 < _len131; _key131++) {
	    args[_key131] = arguments[_key131];
	  }

	  return _builder.default.apply(void 0, ["JSXIdentifier"].concat(args));
	}

	function JSXMemberExpression() {
	  for (var _len132 = arguments.length, args = new Array(_len132), _key132 = 0; _key132 < _len132; _key132++) {
	    args[_key132] = arguments[_key132];
	  }

	  return _builder.default.apply(void 0, ["JSXMemberExpression"].concat(args));
	}

	function JSXNamespacedName() {
	  for (var _len133 = arguments.length, args = new Array(_len133), _key133 = 0; _key133 < _len133; _key133++) {
	    args[_key133] = arguments[_key133];
	  }

	  return _builder.default.apply(void 0, ["JSXNamespacedName"].concat(args));
	}

	function JSXOpeningElement() {
	  for (var _len134 = arguments.length, args = new Array(_len134), _key134 = 0; _key134 < _len134; _key134++) {
	    args[_key134] = arguments[_key134];
	  }

	  return _builder.default.apply(void 0, ["JSXOpeningElement"].concat(args));
	}

	function JSXSpreadAttribute() {
	  for (var _len135 = arguments.length, args = new Array(_len135), _key135 = 0; _key135 < _len135; _key135++) {
	    args[_key135] = arguments[_key135];
	  }

	  return _builder.default.apply(void 0, ["JSXSpreadAttribute"].concat(args));
	}

	function JSXText() {
	  for (var _len136 = arguments.length, args = new Array(_len136), _key136 = 0; _key136 < _len136; _key136++) {
	    args[_key136] = arguments[_key136];
	  }

	  return _builder.default.apply(void 0, ["JSXText"].concat(args));
	}

	function JSXFragment() {
	  for (var _len137 = arguments.length, args = new Array(_len137), _key137 = 0; _key137 < _len137; _key137++) {
	    args[_key137] = arguments[_key137];
	  }

	  return _builder.default.apply(void 0, ["JSXFragment"].concat(args));
	}

	function JSXOpeningFragment() {
	  for (var _len138 = arguments.length, args = new Array(_len138), _key138 = 0; _key138 < _len138; _key138++) {
	    args[_key138] = arguments[_key138];
	  }

	  return _builder.default.apply(void 0, ["JSXOpeningFragment"].concat(args));
	}

	function JSXClosingFragment() {
	  for (var _len139 = arguments.length, args = new Array(_len139), _key139 = 0; _key139 < _len139; _key139++) {
	    args[_key139] = arguments[_key139];
	  }

	  return _builder.default.apply(void 0, ["JSXClosingFragment"].concat(args));
	}

	function Noop() {
	  for (var _len140 = arguments.length, args = new Array(_len140), _key140 = 0; _key140 < _len140; _key140++) {
	    args[_key140] = arguments[_key140];
	  }

	  return _builder.default.apply(void 0, ["Noop"].concat(args));
	}

	function ParenthesizedExpression() {
	  for (var _len141 = arguments.length, args = new Array(_len141), _key141 = 0; _key141 < _len141; _key141++) {
	    args[_key141] = arguments[_key141];
	  }

	  return _builder.default.apply(void 0, ["ParenthesizedExpression"].concat(args));
	}

	function AwaitExpression() {
	  for (var _len142 = arguments.length, args = new Array(_len142), _key142 = 0; _key142 < _len142; _key142++) {
	    args[_key142] = arguments[_key142];
	  }

	  return _builder.default.apply(void 0, ["AwaitExpression"].concat(args));
	}

	function BindExpression() {
	  for (var _len143 = arguments.length, args = new Array(_len143), _key143 = 0; _key143 < _len143; _key143++) {
	    args[_key143] = arguments[_key143];
	  }

	  return _builder.default.apply(void 0, ["BindExpression"].concat(args));
	}

	function ClassProperty() {
	  for (var _len144 = arguments.length, args = new Array(_len144), _key144 = 0; _key144 < _len144; _key144++) {
	    args[_key144] = arguments[_key144];
	  }

	  return _builder.default.apply(void 0, ["ClassProperty"].concat(args));
	}

	function OptionalMemberExpression() {
	  for (var _len145 = arguments.length, args = new Array(_len145), _key145 = 0; _key145 < _len145; _key145++) {
	    args[_key145] = arguments[_key145];
	  }

	  return _builder.default.apply(void 0, ["OptionalMemberExpression"].concat(args));
	}

	function OptionalCallExpression() {
	  for (var _len146 = arguments.length, args = new Array(_len146), _key146 = 0; _key146 < _len146; _key146++) {
	    args[_key146] = arguments[_key146];
	  }

	  return _builder.default.apply(void 0, ["OptionalCallExpression"].concat(args));
	}

	function Import() {
	  for (var _len147 = arguments.length, args = new Array(_len147), _key147 = 0; _key147 < _len147; _key147++) {
	    args[_key147] = arguments[_key147];
	  }

	  return _builder.default.apply(void 0, ["Import"].concat(args));
	}

	function Decorator() {
	  for (var _len148 = arguments.length, args = new Array(_len148), _key148 = 0; _key148 < _len148; _key148++) {
	    args[_key148] = arguments[_key148];
	  }

	  return _builder.default.apply(void 0, ["Decorator"].concat(args));
	}

	function DoExpression() {
	  for (var _len149 = arguments.length, args = new Array(_len149), _key149 = 0; _key149 < _len149; _key149++) {
	    args[_key149] = arguments[_key149];
	  }

	  return _builder.default.apply(void 0, ["DoExpression"].concat(args));
	}

	function ExportDefaultSpecifier() {
	  for (var _len150 = arguments.length, args = new Array(_len150), _key150 = 0; _key150 < _len150; _key150++) {
	    args[_key150] = arguments[_key150];
	  }

	  return _builder.default.apply(void 0, ["ExportDefaultSpecifier"].concat(args));
	}

	function ExportNamespaceSpecifier() {
	  for (var _len151 = arguments.length, args = new Array(_len151), _key151 = 0; _key151 < _len151; _key151++) {
	    args[_key151] = arguments[_key151];
	  }

	  return _builder.default.apply(void 0, ["ExportNamespaceSpecifier"].concat(args));
	}

	function TSParameterProperty() {
	  for (var _len152 = arguments.length, args = new Array(_len152), _key152 = 0; _key152 < _len152; _key152++) {
	    args[_key152] = arguments[_key152];
	  }

	  return _builder.default.apply(void 0, ["TSParameterProperty"].concat(args));
	}

	function TSDeclareFunction() {
	  for (var _len153 = arguments.length, args = new Array(_len153), _key153 = 0; _key153 < _len153; _key153++) {
	    args[_key153] = arguments[_key153];
	  }

	  return _builder.default.apply(void 0, ["TSDeclareFunction"].concat(args));
	}

	function TSDeclareMethod() {
	  for (var _len154 = arguments.length, args = new Array(_len154), _key154 = 0; _key154 < _len154; _key154++) {
	    args[_key154] = arguments[_key154];
	  }

	  return _builder.default.apply(void 0, ["TSDeclareMethod"].concat(args));
	}

	function TSQualifiedName() {
	  for (var _len155 = arguments.length, args = new Array(_len155), _key155 = 0; _key155 < _len155; _key155++) {
	    args[_key155] = arguments[_key155];
	  }

	  return _builder.default.apply(void 0, ["TSQualifiedName"].concat(args));
	}

	function TSCallSignatureDeclaration() {
	  for (var _len156 = arguments.length, args = new Array(_len156), _key156 = 0; _key156 < _len156; _key156++) {
	    args[_key156] = arguments[_key156];
	  }

	  return _builder.default.apply(void 0, ["TSCallSignatureDeclaration"].concat(args));
	}

	function TSConstructSignatureDeclaration() {
	  for (var _len157 = arguments.length, args = new Array(_len157), _key157 = 0; _key157 < _len157; _key157++) {
	    args[_key157] = arguments[_key157];
	  }

	  return _builder.default.apply(void 0, ["TSConstructSignatureDeclaration"].concat(args));
	}

	function TSPropertySignature() {
	  for (var _len158 = arguments.length, args = new Array(_len158), _key158 = 0; _key158 < _len158; _key158++) {
	    args[_key158] = arguments[_key158];
	  }

	  return _builder.default.apply(void 0, ["TSPropertySignature"].concat(args));
	}

	function TSMethodSignature() {
	  for (var _len159 = arguments.length, args = new Array(_len159), _key159 = 0; _key159 < _len159; _key159++) {
	    args[_key159] = arguments[_key159];
	  }

	  return _builder.default.apply(void 0, ["TSMethodSignature"].concat(args));
	}

	function TSIndexSignature() {
	  for (var _len160 = arguments.length, args = new Array(_len160), _key160 = 0; _key160 < _len160; _key160++) {
	    args[_key160] = arguments[_key160];
	  }

	  return _builder.default.apply(void 0, ["TSIndexSignature"].concat(args));
	}

	function TSAnyKeyword() {
	  for (var _len161 = arguments.length, args = new Array(_len161), _key161 = 0; _key161 < _len161; _key161++) {
	    args[_key161] = arguments[_key161];
	  }

	  return _builder.default.apply(void 0, ["TSAnyKeyword"].concat(args));
	}

	function TSNumberKeyword() {
	  for (var _len162 = arguments.length, args = new Array(_len162), _key162 = 0; _key162 < _len162; _key162++) {
	    args[_key162] = arguments[_key162];
	  }

	  return _builder.default.apply(void 0, ["TSNumberKeyword"].concat(args));
	}

	function TSObjectKeyword() {
	  for (var _len163 = arguments.length, args = new Array(_len163), _key163 = 0; _key163 < _len163; _key163++) {
	    args[_key163] = arguments[_key163];
	  }

	  return _builder.default.apply(void 0, ["TSObjectKeyword"].concat(args));
	}

	function TSBooleanKeyword() {
	  for (var _len164 = arguments.length, args = new Array(_len164), _key164 = 0; _key164 < _len164; _key164++) {
	    args[_key164] = arguments[_key164];
	  }

	  return _builder.default.apply(void 0, ["TSBooleanKeyword"].concat(args));
	}

	function TSStringKeyword() {
	  for (var _len165 = arguments.length, args = new Array(_len165), _key165 = 0; _key165 < _len165; _key165++) {
	    args[_key165] = arguments[_key165];
	  }

	  return _builder.default.apply(void 0, ["TSStringKeyword"].concat(args));
	}

	function TSSymbolKeyword() {
	  for (var _len166 = arguments.length, args = new Array(_len166), _key166 = 0; _key166 < _len166; _key166++) {
	    args[_key166] = arguments[_key166];
	  }

	  return _builder.default.apply(void 0, ["TSSymbolKeyword"].concat(args));
	}

	function TSVoidKeyword() {
	  for (var _len167 = arguments.length, args = new Array(_len167), _key167 = 0; _key167 < _len167; _key167++) {
	    args[_key167] = arguments[_key167];
	  }

	  return _builder.default.apply(void 0, ["TSVoidKeyword"].concat(args));
	}

	function TSUndefinedKeyword() {
	  for (var _len168 = arguments.length, args = new Array(_len168), _key168 = 0; _key168 < _len168; _key168++) {
	    args[_key168] = arguments[_key168];
	  }

	  return _builder.default.apply(void 0, ["TSUndefinedKeyword"].concat(args));
	}

	function TSNullKeyword() {
	  for (var _len169 = arguments.length, args = new Array(_len169), _key169 = 0; _key169 < _len169; _key169++) {
	    args[_key169] = arguments[_key169];
	  }

	  return _builder.default.apply(void 0, ["TSNullKeyword"].concat(args));
	}

	function TSNeverKeyword() {
	  for (var _len170 = arguments.length, args = new Array(_len170), _key170 = 0; _key170 < _len170; _key170++) {
	    args[_key170] = arguments[_key170];
	  }

	  return _builder.default.apply(void 0, ["TSNeverKeyword"].concat(args));
	}

	function TSThisType() {
	  for (var _len171 = arguments.length, args = new Array(_len171), _key171 = 0; _key171 < _len171; _key171++) {
	    args[_key171] = arguments[_key171];
	  }

	  return _builder.default.apply(void 0, ["TSThisType"].concat(args));
	}

	function TSFunctionType() {
	  for (var _len172 = arguments.length, args = new Array(_len172), _key172 = 0; _key172 < _len172; _key172++) {
	    args[_key172] = arguments[_key172];
	  }

	  return _builder.default.apply(void 0, ["TSFunctionType"].concat(args));
	}

	function TSConstructorType() {
	  for (var _len173 = arguments.length, args = new Array(_len173), _key173 = 0; _key173 < _len173; _key173++) {
	    args[_key173] = arguments[_key173];
	  }

	  return _builder.default.apply(void 0, ["TSConstructorType"].concat(args));
	}

	function TSTypeReference() {
	  for (var _len174 = arguments.length, args = new Array(_len174), _key174 = 0; _key174 < _len174; _key174++) {
	    args[_key174] = arguments[_key174];
	  }

	  return _builder.default.apply(void 0, ["TSTypeReference"].concat(args));
	}

	function TSTypePredicate() {
	  for (var _len175 = arguments.length, args = new Array(_len175), _key175 = 0; _key175 < _len175; _key175++) {
	    args[_key175] = arguments[_key175];
	  }

	  return _builder.default.apply(void 0, ["TSTypePredicate"].concat(args));
	}

	function TSTypeQuery() {
	  for (var _len176 = arguments.length, args = new Array(_len176), _key176 = 0; _key176 < _len176; _key176++) {
	    args[_key176] = arguments[_key176];
	  }

	  return _builder.default.apply(void 0, ["TSTypeQuery"].concat(args));
	}

	function TSTypeLiteral() {
	  for (var _len177 = arguments.length, args = new Array(_len177), _key177 = 0; _key177 < _len177; _key177++) {
	    args[_key177] = arguments[_key177];
	  }

	  return _builder.default.apply(void 0, ["TSTypeLiteral"].concat(args));
	}

	function TSArrayType() {
	  for (var _len178 = arguments.length, args = new Array(_len178), _key178 = 0; _key178 < _len178; _key178++) {
	    args[_key178] = arguments[_key178];
	  }

	  return _builder.default.apply(void 0, ["TSArrayType"].concat(args));
	}

	function TSTupleType() {
	  for (var _len179 = arguments.length, args = new Array(_len179), _key179 = 0; _key179 < _len179; _key179++) {
	    args[_key179] = arguments[_key179];
	  }

	  return _builder.default.apply(void 0, ["TSTupleType"].concat(args));
	}

	function TSUnionType() {
	  for (var _len180 = arguments.length, args = new Array(_len180), _key180 = 0; _key180 < _len180; _key180++) {
	    args[_key180] = arguments[_key180];
	  }

	  return _builder.default.apply(void 0, ["TSUnionType"].concat(args));
	}

	function TSIntersectionType() {
	  for (var _len181 = arguments.length, args = new Array(_len181), _key181 = 0; _key181 < _len181; _key181++) {
	    args[_key181] = arguments[_key181];
	  }

	  return _builder.default.apply(void 0, ["TSIntersectionType"].concat(args));
	}

	function TSParenthesizedType() {
	  for (var _len182 = arguments.length, args = new Array(_len182), _key182 = 0; _key182 < _len182; _key182++) {
	    args[_key182] = arguments[_key182];
	  }

	  return _builder.default.apply(void 0, ["TSParenthesizedType"].concat(args));
	}

	function TSTypeOperator() {
	  for (var _len183 = arguments.length, args = new Array(_len183), _key183 = 0; _key183 < _len183; _key183++) {
	    args[_key183] = arguments[_key183];
	  }

	  return _builder.default.apply(void 0, ["TSTypeOperator"].concat(args));
	}

	function TSIndexedAccessType() {
	  for (var _len184 = arguments.length, args = new Array(_len184), _key184 = 0; _key184 < _len184; _key184++) {
	    args[_key184] = arguments[_key184];
	  }

	  return _builder.default.apply(void 0, ["TSIndexedAccessType"].concat(args));
	}

	function TSMappedType() {
	  for (var _len185 = arguments.length, args = new Array(_len185), _key185 = 0; _key185 < _len185; _key185++) {
	    args[_key185] = arguments[_key185];
	  }

	  return _builder.default.apply(void 0, ["TSMappedType"].concat(args));
	}

	function TSLiteralType() {
	  for (var _len186 = arguments.length, args = new Array(_len186), _key186 = 0; _key186 < _len186; _key186++) {
	    args[_key186] = arguments[_key186];
	  }

	  return _builder.default.apply(void 0, ["TSLiteralType"].concat(args));
	}

	function TSExpressionWithTypeArguments() {
	  for (var _len187 = arguments.length, args = new Array(_len187), _key187 = 0; _key187 < _len187; _key187++) {
	    args[_key187] = arguments[_key187];
	  }

	  return _builder.default.apply(void 0, ["TSExpressionWithTypeArguments"].concat(args));
	}

	function TSInterfaceDeclaration() {
	  for (var _len188 = arguments.length, args = new Array(_len188), _key188 = 0; _key188 < _len188; _key188++) {
	    args[_key188] = arguments[_key188];
	  }

	  return _builder.default.apply(void 0, ["TSInterfaceDeclaration"].concat(args));
	}

	function TSInterfaceBody() {
	  for (var _len189 = arguments.length, args = new Array(_len189), _key189 = 0; _key189 < _len189; _key189++) {
	    args[_key189] = arguments[_key189];
	  }

	  return _builder.default.apply(void 0, ["TSInterfaceBody"].concat(args));
	}

	function TSTypeAliasDeclaration() {
	  for (var _len190 = arguments.length, args = new Array(_len190), _key190 = 0; _key190 < _len190; _key190++) {
	    args[_key190] = arguments[_key190];
	  }

	  return _builder.default.apply(void 0, ["TSTypeAliasDeclaration"].concat(args));
	}

	function TSAsExpression() {
	  for (var _len191 = arguments.length, args = new Array(_len191), _key191 = 0; _key191 < _len191; _key191++) {
	    args[_key191] = arguments[_key191];
	  }

	  return _builder.default.apply(void 0, ["TSAsExpression"].concat(args));
	}

	function TSTypeAssertion() {
	  for (var _len192 = arguments.length, args = new Array(_len192), _key192 = 0; _key192 < _len192; _key192++) {
	    args[_key192] = arguments[_key192];
	  }

	  return _builder.default.apply(void 0, ["TSTypeAssertion"].concat(args));
	}

	function TSEnumDeclaration() {
	  for (var _len193 = arguments.length, args = new Array(_len193), _key193 = 0; _key193 < _len193; _key193++) {
	    args[_key193] = arguments[_key193];
	  }

	  return _builder.default.apply(void 0, ["TSEnumDeclaration"].concat(args));
	}

	function TSEnumMember() {
	  for (var _len194 = arguments.length, args = new Array(_len194), _key194 = 0; _key194 < _len194; _key194++) {
	    args[_key194] = arguments[_key194];
	  }

	  return _builder.default.apply(void 0, ["TSEnumMember"].concat(args));
	}

	function TSModuleDeclaration() {
	  for (var _len195 = arguments.length, args = new Array(_len195), _key195 = 0; _key195 < _len195; _key195++) {
	    args[_key195] = arguments[_key195];
	  }

	  return _builder.default.apply(void 0, ["TSModuleDeclaration"].concat(args));
	}

	function TSModuleBlock() {
	  for (var _len196 = arguments.length, args = new Array(_len196), _key196 = 0; _key196 < _len196; _key196++) {
	    args[_key196] = arguments[_key196];
	  }

	  return _builder.default.apply(void 0, ["TSModuleBlock"].concat(args));
	}

	function TSImportEqualsDeclaration() {
	  for (var _len197 = arguments.length, args = new Array(_len197), _key197 = 0; _key197 < _len197; _key197++) {
	    args[_key197] = arguments[_key197];
	  }

	  return _builder.default.apply(void 0, ["TSImportEqualsDeclaration"].concat(args));
	}

	function TSExternalModuleReference() {
	  for (var _len198 = arguments.length, args = new Array(_len198), _key198 = 0; _key198 < _len198; _key198++) {
	    args[_key198] = arguments[_key198];
	  }

	  return _builder.default.apply(void 0, ["TSExternalModuleReference"].concat(args));
	}

	function TSNonNullExpression() {
	  for (var _len199 = arguments.length, args = new Array(_len199), _key199 = 0; _key199 < _len199; _key199++) {
	    args[_key199] = arguments[_key199];
	  }

	  return _builder.default.apply(void 0, ["TSNonNullExpression"].concat(args));
	}

	function TSExportAssignment() {
	  for (var _len200 = arguments.length, args = new Array(_len200), _key200 = 0; _key200 < _len200; _key200++) {
	    args[_key200] = arguments[_key200];
	  }

	  return _builder.default.apply(void 0, ["TSExportAssignment"].concat(args));
	}

	function TSNamespaceExportDeclaration() {
	  for (var _len201 = arguments.length, args = new Array(_len201), _key201 = 0; _key201 < _len201; _key201++) {
	    args[_key201] = arguments[_key201];
	  }

	  return _builder.default.apply(void 0, ["TSNamespaceExportDeclaration"].concat(args));
	}

	function TSTypeAnnotation() {
	  for (var _len202 = arguments.length, args = new Array(_len202), _key202 = 0; _key202 < _len202; _key202++) {
	    args[_key202] = arguments[_key202];
	  }

	  return _builder.default.apply(void 0, ["TSTypeAnnotation"].concat(args));
	}

	function TSTypeParameterInstantiation() {
	  for (var _len203 = arguments.length, args = new Array(_len203), _key203 = 0; _key203 < _len203; _key203++) {
	    args[_key203] = arguments[_key203];
	  }

	  return _builder.default.apply(void 0, ["TSTypeParameterInstantiation"].concat(args));
	}

	function TSTypeParameterDeclaration() {
	  for (var _len204 = arguments.length, args = new Array(_len204), _key204 = 0; _key204 < _len204; _key204++) {
	    args[_key204] = arguments[_key204];
	  }

	  return _builder.default.apply(void 0, ["TSTypeParameterDeclaration"].concat(args));
	}

	function TSTypeParameter() {
	  for (var _len205 = arguments.length, args = new Array(_len205), _key205 = 0; _key205 < _len205; _key205++) {
	    args[_key205] = arguments[_key205];
	  }

	  return _builder.default.apply(void 0, ["TSTypeParameter"].concat(args));
	}

	function NumberLiteral() {
	  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");

	  for (var _len206 = arguments.length, args = new Array(_len206), _key206 = 0; _key206 < _len206; _key206++) {
	    args[_key206] = arguments[_key206];
	  }

	  return NumberLiteral.apply(void 0, ["NumberLiteral"].concat(args));
	}

	function RegexLiteral() {
	  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");

	  for (var _len207 = arguments.length, args = new Array(_len207), _key207 = 0; _key207 < _len207; _key207++) {
	    args[_key207] = arguments[_key207];
	  }

	  return RegexLiteral.apply(void 0, ["RegexLiteral"].concat(args));
	}

	function RestProperty() {
	  console.trace("The node type RestProperty has been renamed to RestElement");

	  for (var _len208 = arguments.length, args = new Array(_len208), _key208 = 0; _key208 < _len208; _key208++) {
	    args[_key208] = arguments[_key208];
	  }

	  return RestProperty.apply(void 0, ["RestProperty"].concat(args));
	}

	function SpreadProperty() {
	  console.trace("The node type SpreadProperty has been renamed to SpreadElement");

	  for (var _len209 = arguments.length, args = new Array(_len209), _key209 = 0; _key209 < _len209; _key209++) {
	    args[_key209] = arguments[_key209];
	  }

	  return SpreadProperty.apply(void 0, ["SpreadProperty"].concat(args));
	}

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	module.exports = require("fs");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.TYPES = void 0;

	var _toFastProperties = _interopRequireDefault(__webpack_require__(156));

	__webpack_require__(24);

	__webpack_require__(25);

	__webpack_require__(119);

	__webpack_require__(120);

	__webpack_require__(121);

	__webpack_require__(118);

	__webpack_require__(122);

	var _utils = __webpack_require__(12);

	exports.VISITOR_KEYS = _utils.VISITOR_KEYS;
	exports.ALIAS_KEYS = _utils.ALIAS_KEYS;
	exports.FLIPPED_ALIAS_KEYS = _utils.FLIPPED_ALIAS_KEYS;
	exports.NODE_FIELDS = _utils.NODE_FIELDS;
	exports.BUILDER_KEYS = _utils.BUILDER_KEYS;
	exports.DEPRECATED_KEYS = _utils.DEPRECATED_KEYS;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	(0, _toFastProperties.default)(_utils.VISITOR_KEYS);
	(0, _toFastProperties.default)(_utils.ALIAS_KEYS);
	(0, _toFastProperties.default)(_utils.FLIPPED_ALIAS_KEYS);
	(0, _toFastProperties.default)(_utils.NODE_FIELDS);
	(0, _toFastProperties.default)(_utils.BUILDER_KEYS);
	(0, _toFastProperties.default)(_utils.DEPRECATED_KEYS);
	var TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));
	exports.TYPES = TYPES;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.validate = validate;
	exports.typeIs = typeIs;
	exports.validateType = validateType;
	exports.validateOptional = validateOptional;
	exports.validateOptionalType = validateOptionalType;
	exports.arrayOf = arrayOf;
	exports.arrayOfType = arrayOfType;
	exports.validateArrayOfType = validateArrayOfType;
	exports.assertEach = assertEach;
	exports.assertOneOf = assertOneOf;
	exports.assertNodeType = assertNodeType;
	exports.assertNodeOrValueType = assertNodeOrValueType;
	exports.assertValueType = assertValueType;
	exports.chain = chain;
	exports.default = defineType;
	exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;

	var _is = _interopRequireDefault(__webpack_require__(20));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var VISITOR_KEYS = {};
	exports.VISITOR_KEYS = VISITOR_KEYS;
	var ALIAS_KEYS = {};
	exports.ALIAS_KEYS = ALIAS_KEYS;
	var FLIPPED_ALIAS_KEYS = {};
	exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
	var NODE_FIELDS = {};
	exports.NODE_FIELDS = NODE_FIELDS;
	var BUILDER_KEYS = {};
	exports.BUILDER_KEYS = BUILDER_KEYS;
	var DEPRECATED_KEYS = {};
	exports.DEPRECATED_KEYS = DEPRECATED_KEYS;

	function getType(val) {
	  if (Array.isArray(val)) {
	    return "array";
	  } else if (val === null) {
	    return "null";
	  } else if (val === undefined) {
	    return "undefined";
	  } else {
	    return typeof val;
	  }
	}

	function validate(validate) {
	  return {
	    validate: validate
	  };
	}

	function typeIs(typeName) {
	  return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType.apply(void 0, typeName);
	}

	function validateType(typeName) {
	  return validate(typeIs(typeName));
	}

	function validateOptional(validate) {
	  return {
	    validate: validate,
	    optional: true
	  };
	}

	function validateOptionalType(typeName) {
	  return {
	    validate: typeIs(typeName),
	    optional: true
	  };
	}

	function arrayOf(elementType) {
	  return chain(assertValueType("array"), assertEach(elementType));
	}

	function arrayOfType(typeName) {
	  return arrayOf(typeIs(typeName));
	}

	function validateArrayOfType(typeName) {
	  return validate(arrayOfType(typeName));
	}

	function assertEach(callback) {
	  function validator(node, key, val) {
	    if (!Array.isArray(val)) return;

	    for (var i = 0; i < val.length; i++) {
	      callback(node, key + "[" + i + "]", val[i]);
	    }
	  }

	  validator.each = callback;
	  return validator;
	}

	function assertOneOf() {
	  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
	    values[_key] = arguments[_key];
	  }

	  function validate(node, key, val) {
	    if (values.indexOf(val) < 0) {
	      throw new TypeError("Property " + key + " expected value to be one of " + JSON.stringify(values) + " but got " + JSON.stringify(val));
	    }
	  }

	  validate.oneOf = values;
	  return validate;
	}

	function assertNodeType() {
	  for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    types[_key2] = arguments[_key2];
	  }

	  function validate(node, key, val) {
	    var valid = false;

	    for (var _i = 0; _i < types.length; _i++) {
	      var type = types[_i];

	      if ((0, _is.default)(type, val)) {
	        valid = true;
	        break;
	      }
	    }

	    if (!valid) {
	      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " " + ("but instead got " + JSON.stringify(val && val.type)));
	    }
	  }

	  validate.oneOfNodeTypes = types;
	  return validate;
	}

	function assertNodeOrValueType() {
	  for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	    types[_key3] = arguments[_key3];
	  }

	  function validate(node, key, val) {
	    var valid = false;

	    for (var _i2 = 0; _i2 < types.length; _i2++) {
	      var type = types[_i2];

	      if (getType(val) === type || (0, _is.default)(type, val)) {
	        valid = true;
	        break;
	      }
	    }

	    if (!valid) {
	      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " " + ("but instead got " + JSON.stringify(val && val.type)));
	    }
	  }

	  validate.oneOfNodeOrValueTypes = types;
	  return validate;
	}

	function assertValueType(type) {
	  function validate(node, key, val) {
	    var valid = getType(val) === type;

	    if (!valid) {
	      throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType(val));
	    }
	  }

	  validate.type = type;
	  return validate;
	}

	function chain() {
	  for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	    fns[_key4] = arguments[_key4];
	  }

	  function validate() {
	    for (var _i3 = 0; _i3 < fns.length; _i3++) {
	      var fn = fns[_i3];
	      fn.apply(void 0, arguments);
	    }
	  }

	  validate.chainOf = fns;
	  return validate;
	}

	function defineType(type, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  var inherits = opts.inherits && store[opts.inherits] || {};
	  var fields = opts.fields || inherits.fields || {};
	  var visitor = opts.visitor || inherits.visitor || [];
	  var aliases = opts.aliases || inherits.aliases || [];
	  var builder = opts.builder || inherits.builder || opts.visitor || [];

	  if (opts.deprecatedAlias) {
	    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
	  }

	  var _arr = visitor.concat(builder);

	  for (var _i4 = 0; _i4 < _arr.length; _i4++) {
	    var key = _arr[_i4];
	    fields[key] = fields[key] || {};
	  }

	  for (var _key5 in fields) {
	    var field = fields[_key5];

	    if (builder.indexOf(_key5) === -1) {
	      field.optional = true;
	    }

	    if (field.default === undefined) {
	      field.default = null;
	    } else if (!field.validate) {
	      field.validate = assertValueType(getType(field.default));
	    }
	  }

	  VISITOR_KEYS[type] = opts.visitor = visitor;
	  BUILDER_KEYS[type] = opts.builder = builder;
	  NODE_FIELDS[type] = opts.fields = fields;
	  ALIAS_KEYS[type] = opts.aliases = aliases;
	  aliases.forEach(function (alias) {
	    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
	    FLIPPED_ALIAS_KEYS[alias].push(type);
	  });
	  store[type] = opts;
	}

	var store = {};

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;
	var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
	exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
	var FLATTENABLE_KEYS = ["body", "expressions"];
	exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
	var FOR_INIT_KEYS = ["left", "init"];
	exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
	var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
	exports.COMMENT_KEYS = COMMENT_KEYS;
	var LOGICAL_OPERATORS = ["||", "&&", "??"];
	exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
	var UPDATE_OPERATORS = ["++", "--"];
	exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
	var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
	exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
	var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
	exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
	var COMPARISON_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS.concat(["in", "instanceof"]);
	exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
	var BOOLEAN_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS.concat(BOOLEAN_NUMBER_BINARY_OPERATORS);
	exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
	var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
	exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
	var BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS, BOOLEAN_BINARY_OPERATORS);
	exports.BINARY_OPERATORS = BINARY_OPERATORS;
	var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
	exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
	var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
	exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
	var STRING_UNARY_OPERATORS = ["typeof"];
	exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
	var UNARY_OPERATORS = ["void", "throw"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);
	exports.UNARY_OPERATORS = UNARY_OPERATORS;
	var INHERIT_KEYS = {
	  optional: ["typeAnnotation", "typeParameters", "returnType"],
	  force: ["start", "loc", "end"]
	};
	exports.INHERIT_KEYS = INHERIT_KEYS;
	var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
	exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
	var NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
	exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(3),
	    FilterDirectivesTransform = _require.FilterDirectivesTransform,
	    FlattenTransform = _require.FlattenTransform,
	    InlineFragmentsTransform = _require.InlineFragmentsTransform,
	    SkipClientFieldTransform = _require.SkipClientFieldTransform,
	    SkipRedundantNodesTransform = _require.SkipRedundantNodesTransform,
	    SkipUnreachableNodeTransform = _require.SkipUnreachableNodeTransform,
	    StripUnusedVariablesTransform = _require.StripUnusedVariablesTransform;

	// Transforms applied to the code used to process a query response.
	var relaySchemaExtensions = [__webpack_require__(32).SCHEMA_EXTENSION, __webpack_require__(22).SCHEMA_EXTENSION];

	// Transforms applied to both operations and fragments for both reading and
	// writing from the store.
	var relayCommonTransforms = [__webpack_require__(32).transform, __webpack_require__(73).transform, __webpack_require__(22).transform, __webpack_require__(37).transform, __webpack_require__(67).transform];

	// Transforms applied to fragments used for reading data from a store
	var relayFragmentTransforms = [__webpack_require__(68).transform, FlattenTransform.transformWithOptions({ flattenAbstractTypes: true }), SkipRedundantNodesTransform.transform];

	// Transforms applied to queries/mutations/subscriptions that are used for
	// fetching data from the server and parsing those responses.
	var relayQueryTransforms = [__webpack_require__(63).transform, SkipClientFieldTransform.transform, SkipUnreachableNodeTransform.transform, __webpack_require__(71).transform];

	// Transforms applied to the code used to process a query response.
	var relayCodegenTransforms = [InlineFragmentsTransform.transform, FlattenTransform.transformWithOptions({ flattenAbstractTypes: true }), SkipRedundantNodesTransform.transform, __webpack_require__(35).transform, FilterDirectivesTransform.transform];

	// Transforms applied before printing the query sent to the server.
	var relayPrintTransforms = [FlattenTransform.transformWithOptions({}), __webpack_require__(35).transform, __webpack_require__(72).transform, FilterDirectivesTransform.transform, StripUnusedVariablesTransform.transform];

	module.exports = {
	  commonTransforms: relayCommonTransforms,
	  codegenTransforms: relayCodegenTransforms,
	  fragmentTransforms: relayFragmentTransforms,
	  printTransforms: relayPrintTransforms,
	  queryTransforms: relayQueryTransforms,
	  schemaExtensions: relaySchemaExtensions
	};

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	module.exports = require("fbjs/lib/nullthrows");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = cloneNode;

	var _definitions = __webpack_require__(11);

	var has = Function.call.bind(Object.prototype.hasOwnProperty);

	function cloneIfNode(obj, deep) {
	  if (obj && typeof obj.type === "string" && obj.type !== "CommentLine" && obj.type !== "CommentBlock") {
	    return cloneNode(obj, deep);
	  }

	  return obj;
	}

	function cloneIfNodeOrArray(obj, deep) {
	  if (Array.isArray(obj)) {
	    return obj.map(function (node) {
	      return cloneIfNode(node, deep);
	    });
	  }

	  return cloneIfNode(obj, deep);
	}

	function cloneNode(node, deep) {
	  if (deep === void 0) {
	    deep = true;
	  }

	  if (!node) return node;
	  var type = node.type;
	  var newNode = {
	    type: type
	  };

	  if (type === "Identifier") {
	    newNode.name = node.name;
	  } else if (!has(_definitions.NODE_FIELDS, type)) {
	    throw new Error("Unknown node type: \"" + type + "\"");
	  } else {
	    var _arr = Object.keys(_definitions.NODE_FIELDS[type]);

	    for (var _i = 0; _i < _arr.length; _i++) {
	      var field = _arr[_i];

	      if (has(node, field)) {
	        newNode[field] = deep ? cloneIfNodeOrArray(node[field], true) : node[field];
	      }
	    }
	  }

	  if (has(node, "loc")) {
	    newNode.loc = node.loc;
	  }

	  if (has(node, "leadingComments")) {
	    newNode.leadingComments = node.leadingComments;
	  }

	  if (has(node, "innerComments")) {
	    newNode.innerComments = node.innerCmments;
	  }

	  if (has(node, "trailingComments")) {
	    newNode.trailingComments = node.trailingComments;
	  }

	  if (has(node, "extra")) {
	    newNode.extra = Object.assign({}, node.extra);
	  }

	  return newNode;
	}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isValidIdentifier;

	var _esutils = _interopRequireDefault(__webpack_require__(144));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isValidIdentifier(name) {
	  if (typeof name !== "string" || _esutils.default.keyword.isReservedWordES6(name, true)) {
	    return false;
	  } else if (name === "await") {
	    return false;
	  } else {
	    return _esutils.default.keyword.isIdentifierNameES6(name);
	  }
	}

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	module.exports = require("relay-runtime");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = getBindingIdentifiers;

	var _generated = __webpack_require__(5);

	function getBindingIdentifiers(node, duplicates, outerOnly) {
	  var search = [].concat(node);
	  var ids = Object.create(null);

	  while (search.length) {
	    var id = search.shift();
	    if (!id) continue;
	    var keys = getBindingIdentifiers.keys[id.type];

	    if ((0, _generated.isIdentifier)(id)) {
	      if (duplicates) {
	        var _ids = ids[id.name] = ids[id.name] || [];

	        _ids.push(id);
	      } else {
	        ids[id.name] = id;
	      }

	      continue;
	    }

	    if ((0, _generated.isExportDeclaration)(id)) {
	      if ((0, _generated.isDeclaration)(id.declaration)) {
	        search.push(id.declaration);
	      }

	      continue;
	    }

	    if (outerOnly) {
	      if ((0, _generated.isFunctionDeclaration)(id)) {
	        search.push(id.id);
	        continue;
	      }

	      if ((0, _generated.isFunctionExpression)(id)) {
	        continue;
	      }
	    }

	    if (keys) {
	      for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];

	        if (id[key]) {
	          search = search.concat(id[key]);
	        }
	      }
	    }
	  }

	  return ids;
	}

	getBindingIdentifiers.keys = {
	  DeclareClass: ["id"],
	  DeclareFunction: ["id"],
	  DeclareModule: ["id"],
	  DeclareVariable: ["id"],
	  InterfaceDeclaration: ["id"],
	  TypeAlias: ["id"],
	  OpaqueType: ["id"],
	  CatchClause: ["param"],
	  LabeledStatement: ["label"],
	  UnaryExpression: ["argument"],
	  AssignmentExpression: ["left"],
	  ImportSpecifier: ["local"],
	  ImportNamespaceSpecifier: ["local"],
	  ImportDefaultSpecifier: ["local"],
	  ImportDeclaration: ["specifiers"],
	  ExportSpecifier: ["exported"],
	  ExportNamespaceSpecifier: ["exported"],
	  ExportDefaultSpecifier: ["exported"],
	  FunctionDeclaration: ["id", "params"],
	  FunctionExpression: ["id", "params"],
	  ForInStatement: ["left"],
	  ForOfStatement: ["left"],
	  ClassDeclaration: ["id"],
	  ClassExpression: ["id"],
	  RestElement: ["argument"],
	  UpdateExpression: ["argument"],
	  ObjectProperty: ["value"],
	  AssignmentPattern: ["left"],
	  ArrayPattern: ["elements"],
	  ObjectPattern: ["properties"],
	  VariableDeclaration: ["declarations"],
	  VariableDeclarator: ["id"]
	};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = is;

	var _shallowEqual = _interopRequireDefault(__webpack_require__(54));

	var _isType = _interopRequireDefault(__webpack_require__(27));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function is(type, node, opts) {
	  if (!node) return false;
	  var matches = (0, _isType.default)(node.type, type);
	  if (!matches) return false;

	  if (typeof opts === "undefined") {
	    return true;
	  } else {
	    return (0, _shallowEqual.default)(node, opts);
	  }
	}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(29));

	var _possibleConstructorReturn3 = _interopRequireDefault(__webpack_require__(142));

	var _inherits3 = _interopRequireDefault(__webpack_require__(141));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(6),
	    assertAbstractType = _require.assertAbstractType,
	    isAbstractType = _require.isAbstractType;

	var _require2 = __webpack_require__(3),
	    Parser = _require2.Parser,
	    SchemaUtils = _require2.SchemaUtils;

	var getRawType = SchemaUtils.getRawType;

	var RelayParser = function (_Parser) {
	  (0, _inherits3['default'])(RelayParser, _Parser);

	  function RelayParser(schema, definition) {
	    (0, _classCallCheck3['default'])(this, RelayParser);

	    var _this = (0, _possibleConstructorReturn3['default'])(this, _Parser.call(this, schema, definition));

	    _this._definition = definition;
	    _this._schema = schema;
	    return _this;
	  }

	  /**
	   * Find the definition of a field of the specified type.
	   */


	  RelayParser.prototype.getFieldDefinition = function getFieldDefinition(parentType, fieldName, fieldAST) {
	    var schemaFieldDef = _Parser.prototype.getFieldDefinition.call(this, parentType, fieldName, fieldAST);
	    if (!schemaFieldDef) {
	      var type = getRawType(parentType);
	      schemaFieldDef = getClassicFieldDefinition(this._schema, type, fieldName, fieldAST);
	    }
	    return schemaFieldDef || null;
	  };

	  return RelayParser;
	}(Parser);

	function getName(ast) {
	  var name = ast.name ? ast.name.value : null;
	  __webpack_require__(2)(typeof name === 'string', 'RelayParser: Expected ast node `%s` to have a name.', ast);
	  return name;
	}

	function getClassicFieldDefinition(schema, type, fieldName, fieldAST) {
	  if (isAbstractType(type) && fieldAST && fieldAST.directives && fieldAST.directives.some(function (directive) {
	    return getName(directive) === 'fixme_fat_interface';
	  })) {
	    var possibleTypes = schema.getPossibleTypes(assertAbstractType(type));
	    var schemaFieldDef = void 0;

	    var _loop = function _loop(ii) {
	      var possibleField = possibleTypes[ii].getFields()[fieldName];
	      if (possibleField) {
	        // Fat interface fields can have differing arguments. Try to return
	        // a field with matching arguments, but still return a field if the
	        // arguments do not match.
	        schemaFieldDef = possibleField;
	        if (fieldAST && fieldAST.arguments) {
	          var argumentsAllExist = fieldAST.arguments.every(function (argument) {
	            return possibleField.args.find(function (argDef) {
	              return argDef.name === getName(argument);
	            });
	          });
	          if (argumentsAllExist) {
	            return 'break';
	          }
	        }
	      }
	    };

	    for (var ii = 0; ii < possibleTypes.length; ii++) {
	      var _ret = _loop(ii);

	      if (_ret === 'break') break;
	    }
	    return schemaFieldDef;
	  }
	}

	module.exports = RelayParser;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(3),
	    CompilerContext = _require.CompilerContext,
	    IRTransformer = _require.IRTransformer,
	    getLiteralArgumentValues = _require.getLiteralArgumentValues;

	var RELAY = 'relay';
	var SCHEMA_EXTENSION = 'directive @relay(\n  # Marks this fragment spread as being deferrable such that it loads after\n  # other portions of the view.\n  deferrable: Boolean,\n\n  # Marks a connection field as containing nodes without \'id\' fields.\n  # This is used to silence the warning when diffing connections.\n  isConnectionWithoutNodeID: Boolean,\n\n  # Marks a fragment as intended for pattern matching (as opposed to fetching).\n  # Used in Classic only.\n  pattern: Boolean,\n\n  # Marks a fragment as being backed by a GraphQLList.\n  plural: Boolean,\n\n  # Marks a fragment spread which should be unmasked if provided false\n  mask: Boolean = true,\n\n  # Selectively pass variables down into a fragment. Only used in Classic.\n  variables: [String!],\n) on FRAGMENT_DEFINITION | FRAGMENT_SPREAD | INLINE_FRAGMENT | FIELD';

	/**
	 * A transform that extracts `@relay(plural: Boolean)` directives and converts
	 * them to metadata that can be accessed at runtime.
	 */
	function relayRelayDirectiveTransform(context) {
	  return IRTransformer.transform(context, {
	    Fragment: visitRelayMetadata(fragmentMetadata),
	    FragmentSpread: visitRelayMetadata(fragmentSpreadMetadata)
	  });
	}

	function visitRelayMetadata(metadataFn) {
	  return function (node) {
	    var relayDirective = node.directives.find(function (_ref) {
	      var name = _ref.name;
	      return name === RELAY;
	    });
	    if (!relayDirective) {
	      return this.traverse(node);
	    }
	    var argValues = getLiteralArgumentValues(relayDirective.args);
	    var metadata = metadataFn(argValues);
	    return this.traverse((0, _extends3['default'])({}, node, {
	      directives: node.directives.filter(function (directive) {
	        return directive !== relayDirective;
	      }),
	      metadata: (0, _extends3['default'])({}, node.metadata || {}, metadata)
	    }));
	  };
	}

	function fragmentMetadata(_ref2) {
	  var plural = _ref2.plural;

	  __webpack_require__(2)(plural === undefined || typeof plural === 'boolean', 'RelayRelayDirectiveTransform: Expected the "plural" argument to @relay ' + 'to be a boolean literal if specified.');
	  return { plural: plural };
	}

	function fragmentSpreadMetadata(_ref3) {
	  var mask = _ref3.mask,
	      deferrable = _ref3.deferrable;

	  __webpack_require__(2)(mask === undefined || typeof mask === 'boolean', 'RelayRelayDirectiveTransform: Expected the "mask" argument to @relay ' + 'to be a boolean literal if specified.');
	  __webpack_require__(2)(deferrable === undefined || typeof deferrable === 'boolean', 'RelayRelayDirectiveTransform: Expected the "deferrable" argument to ' + '@relay to be a boolean literal if specified.');
	  __webpack_require__(2)(!(deferrable === true && mask === false), 'RelayRelayDirectiveTransform: Cannot unmask a deferrable fragment spread.');
	  return { mask: mask, deferrable: deferrable };
	}

	module.exports = {
	  RELAY: RELAY,
	  SCHEMA_EXTENSION: SCHEMA_EXTENSION,
	  transform: relayRelayDirectiveTransform
	};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.Identifier = Identifier;
	exports.SpreadElement = exports.RestElement = RestElement;
	exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
	exports.ObjectMethod = ObjectMethod;
	exports.ObjectProperty = ObjectProperty;
	exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
	exports.RegExpLiteral = RegExpLiteral;
	exports.BooleanLiteral = BooleanLiteral;
	exports.NullLiteral = NullLiteral;
	exports.NumericLiteral = NumericLiteral;
	exports.StringLiteral = StringLiteral;

	var t = _interopRequireWildcard(__webpack_require__(1));

	var _jsesc = _interopRequireDefault(__webpack_require__(147));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function Identifier(node) {
	  this.word(node.name);
	}

	function RestElement(node) {
	  this.token("...");
	  this.print(node.argument, node);
	}

	function ObjectExpression(node) {
	  var props = node.properties;
	  this.token("{");
	  this.printInnerComments(node);

	  if (props.length) {
	    this.space();
	    this.printList(props, node, {
	      indent: true,
	      statement: true
	    });
	    this.space();
	  }

	  this.token("}");
	}

	function ObjectMethod(node) {
	  this.printJoin(node.decorators, node);

	  this._methodHead(node);

	  this.space();
	  this.print(node.body, node);
	}

	function ObjectProperty(node) {
	  this.printJoin(node.decorators, node);

	  if (node.computed) {
	    this.token("[");
	    this.print(node.key, node);
	    this.token("]");
	  } else {
	    if (t.isAssignmentPattern(node.value) && t.isIdentifier(node.key) && node.key.name === node.value.left.name) {
	      this.print(node.value, node);
	      return;
	    }

	    this.print(node.key, node);

	    if (node.shorthand && t.isIdentifier(node.key) && t.isIdentifier(node.value) && node.key.name === node.value.name) {
	      return;
	    }
	  }

	  this.token(":");
	  this.space();
	  this.print(node.value, node);
	}

	function ArrayExpression(node) {
	  var elems = node.elements;
	  var len = elems.length;
	  this.token("[");
	  this.printInnerComments(node);

	  for (var i = 0; i < elems.length; i++) {
	    var elem = elems[i];

	    if (elem) {
	      if (i > 0) this.space();
	      this.print(elem, node);
	      if (i < len - 1) this.token(",");
	    } else {
	      this.token(",");
	    }
	  }

	  this.token("]");
	}

	function RegExpLiteral(node) {
	  this.word("/" + node.pattern + "/" + node.flags);
	}

	function BooleanLiteral(node) {
	  this.word(node.value ? "true" : "false");
	}

	function NullLiteral() {
	  this.word("null");
	}

	function NumericLiteral(node) {
	  var raw = this.getPossibleRaw(node);
	  var value = node.value + "";

	  if (raw == null) {
	    this.number(value);
	  } else if (this.format.minified) {
	    this.number(raw.length < value.length ? raw : value);
	  } else {
	    this.number(raw);
	  }
	}

	function StringLiteral(node) {
	  var raw = this.getPossibleRaw(node);

	  if (!this.format.minified && raw != null) {
	    this.token(raw);
	    return;
	  }

	  var opts = {
	    quotes: "double",
	    wrap: true
	  };

	  if (this.format.jsonCompatibleStrings) {
	    opts.json = true;
	  }

	  var val = (0, _jsesc.default)(node.value, opts);
	  return this.token(val);
	}

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;

	var _isValidIdentifier = _interopRequireDefault(__webpack_require__(17));

	var _constants = __webpack_require__(13);

	var _utils = _interopRequireWildcard(__webpack_require__(12));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	(0, _utils.default)("ArrayExpression", {
	  fields: {
	    elements: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
	      default: []
	    }
	  },
	  visitor: ["elements"],
	  aliases: ["Expression"]
	});
	(0, _utils.default)("AssignmentExpression", {
	  fields: {
	    operator: {
	      validate: (0, _utils.assertValueType)("string")
	    },
	    left: {
	      validate: (0, _utils.assertNodeType)("LVal")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  builder: ["operator", "left", "right"],
	  visitor: ["left", "right"],
	  aliases: ["Expression"]
	});
	(0, _utils.default)("BinaryExpression", {
	  builder: ["operator", "left", "right"],
	  fields: {
	    operator: {
	      validate: _utils.assertOneOf.apply(void 0, _constants.BINARY_OPERATORS)
	    },
	    left: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  visitor: ["left", "right"],
	  aliases: ["Binary", "Expression"]
	});
	(0, _utils.default)("Directive", {
	  visitor: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
	    }
	  }
	});
	(0, _utils.default)("DirectiveLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});
	(0, _utils.default)("BlockStatement", {
	  builder: ["body", "directives"],
	  visitor: ["directives", "body"],
	  fields: {
	    directives: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
	      default: []
	    },
	    body: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
	    }
	  },
	  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
	});
	(0, _utils.default)("BreakStatement", {
	  visitor: ["label"],
	  fields: {
	    label: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    }
	  },
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
	});
	(0, _utils.default)("CallExpression", {
	  visitor: ["callee", "arguments", "typeParameters"],
	  builder: ["callee", "arguments"],
	  aliases: ["Expression"],
	  fields: {
	    callee: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    arguments: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName")))
	    },
	    optional: {
	      validate: (0, _utils.assertOneOf)(true, false),
	      optional: true
	    },
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("CatchClause", {
	  visitor: ["param", "body"],
	  fields: {
	    param: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  },
	  aliases: ["Scopable", "BlockParent"]
	});
	(0, _utils.default)("ConditionalExpression", {
	  visitor: ["test", "consequent", "alternate"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    consequent: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    alternate: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  aliases: ["Expression", "Conditional"]
	});
	(0, _utils.default)("ContinueStatement", {
	  visitor: ["label"],
	  fields: {
	    label: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    }
	  },
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
	});
	(0, _utils.default)("DebuggerStatement", {
	  aliases: ["Statement"]
	});
	(0, _utils.default)("DoWhileStatement", {
	  visitor: ["test", "body"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  },
	  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
	});
	(0, _utils.default)("EmptyStatement", {
	  aliases: ["Statement"]
	});
	(0, _utils.default)("ExpressionStatement", {
	  visitor: ["expression"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  aliases: ["Statement", "ExpressionWrapper"]
	});
	(0, _utils.default)("File", {
	  builder: ["program", "comments", "tokens"],
	  visitor: ["program"],
	  fields: {
	    program: {
	      validate: (0, _utils.assertNodeType)("Program")
	    }
	  }
	});
	(0, _utils.default)("ForInStatement", {
	  visitor: ["left", "right", "body"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
	  fields: {
	    left: {
	      validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	(0, _utils.default)("ForStatement", {
	  visitor: ["init", "test", "update", "body"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
	  fields: {
	    init: {
	      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
	      optional: true
	    },
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    update: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	var functionCommon = {
	  params: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("LVal")))
	  },
	  generator: {
	    default: false,
	    validate: (0, _utils.assertValueType)("boolean")
	  },
	  async: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    default: false
	  }
	};
	exports.functionCommon = functionCommon;
	var functionTypeAnnotationCommon = {
	  returnType: {
	    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  typeParameters: {
	    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
	    optional: true
	  }
	};
	exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
	var functionDeclarationCommon = Object.assign({}, functionCommon, {
	  declare: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  id: {
	    validate: (0, _utils.assertNodeType)("Identifier"),
	    optional: true
	  }
	});
	exports.functionDeclarationCommon = functionDeclarationCommon;
	(0, _utils.default)("FunctionDeclaration", {
	  builder: ["id", "params", "body", "generator", "async"],
	  visitor: ["id", "params", "body", "returnType", "typeParameters"],
	  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  }),
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"]
	});
	(0, _utils.default)("FunctionExpression", {
	  inherits: "FunctionDeclaration",
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
	  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
	    id: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  })
	});
	var patternLikeCommon = {
	  typeAnnotation: {
	    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  decorators: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
	  }
	};
	exports.patternLikeCommon = patternLikeCommon;
	(0, _utils.default)("Identifier", {
	  builder: ["name"],
	  visitor: ["typeAnnotation"],
	  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
	  fields: Object.assign({}, patternLikeCommon, {
	    name: {
	      validate: (0, _utils.chain)(function (node, key, val) {
	        if (!(0, _isValidIdentifier.default)(val)) {}
	      }, (0, _utils.assertValueType)("string"))
	    },
	    optional: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    }
	  })
	});
	(0, _utils.default)("IfStatement", {
	  visitor: ["test", "consequent", "alternate"],
	  aliases: ["Statement", "Conditional"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    consequent: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    },
	    alternate: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	(0, _utils.default)("LabeledStatement", {
	  visitor: ["label", "body"],
	  aliases: ["Statement"],
	  fields: {
	    label: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	(0, _utils.default)("StringLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	(0, _utils.default)("NumericLiteral", {
	  builder: ["value"],
	  deprecatedAlias: "NumberLiteral",
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("number")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	(0, _utils.default)("NullLiteral", {
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	(0, _utils.default)("BooleanLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("boolean")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	(0, _utils.default)("RegExpLiteral", {
	  builder: ["pattern", "flags"],
	  deprecatedAlias: "RegexLiteral",
	  aliases: ["Expression", "Literal"],
	  fields: {
	    pattern: {
	      validate: (0, _utils.assertValueType)("string")
	    },
	    flags: {
	      validate: (0, _utils.assertValueType)("string"),
	      default: ""
	    }
	  }
	});
	(0, _utils.default)("LogicalExpression", {
	  builder: ["operator", "left", "right"],
	  visitor: ["left", "right"],
	  aliases: ["Binary", "Expression"],
	  fields: {
	    operator: {
	      validate: _utils.assertOneOf.apply(void 0, _constants.LOGICAL_OPERATORS)
	    },
	    left: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("MemberExpression", {
	  builder: ["object", "property", "computed", "optional"],
	  visitor: ["object", "property"],
	  aliases: ["Expression", "LVal"],
	  fields: {
	    object: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    property: {
	      validate: function () {
	        var normal = (0, _utils.assertNodeType)("Identifier");
	        var computed = (0, _utils.assertNodeType)("Expression");
	        return function (node, key, val) {
	          var validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };
	      }()
	    },
	    computed: {
	      default: false
	    },
	    optional: {
	      validate: (0, _utils.assertOneOf)(true, false),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("NewExpression", {
	  inherits: "CallExpression"
	});
	(0, _utils.default)("Program", {
	  visitor: ["directives", "body"],
	  builder: ["body", "directives", "sourceType"],
	  fields: {
	    sourceFile: {
	      validate: (0, _utils.assertValueType)("string")
	    },
	    sourceType: {
	      validate: (0, _utils.assertOneOf)("script", "module"),
	      default: "script"
	    },
	    directives: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
	      default: []
	    },
	    body: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
	    }
	  },
	  aliases: ["Scopable", "BlockParent", "Block"]
	});
	(0, _utils.default)("ObjectExpression", {
	  visitor: ["properties"],
	  aliases: ["Expression"],
	  fields: {
	    properties: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
	    }
	  }
	});
	(0, _utils.default)("ObjectMethod", {
	  builder: ["kind", "key", "params", "body", "computed"],
	  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
	    kind: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("method", "get", "set")),
	      default: "method"
	    },
	    computed: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    key: {
	      validate: function () {
	        var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
	        var computed = (0, _utils.assertNodeType)("Expression");
	        return function (node, key, val) {
	          var validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };
	      }()
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  }),
	  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
	  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
	});
	(0, _utils.default)("ObjectProperty", {
	  builder: ["key", "value", "computed", "shorthand", "decorators"],
	  fields: {
	    computed: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    key: {
	      validate: function () {
	        var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
	        var computed = (0, _utils.assertNodeType)("Expression");
	        return function (node, key, val) {
	          var validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };
	      }()
	    },
	    value: {
	      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
	    },
	    shorthand: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
	      optional: true
	    }
	  },
	  visitor: ["key", "value", "decorators"],
	  aliases: ["UserWhitespacable", "Property", "ObjectMember"]
	});
	(0, _utils.default)("RestElement", {
	  visitor: ["argument", "typeAnnotation"],
	  builder: ["argument"],
	  aliases: ["LVal", "PatternLike"],
	  deprecatedAlias: "RestProperty",
	  fields: Object.assign({}, patternLikeCommon, {
	    argument: {
	      validate: (0, _utils.assertNodeType)("LVal")
	    }
	  })
	});
	(0, _utils.default)("ReturnStatement", {
	  visitor: ["argument"],
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("SequenceExpression", {
	  visitor: ["expressions"],
	  fields: {
	    expressions: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
	    }
	  },
	  aliases: ["Expression"]
	});
	(0, _utils.default)("SwitchCase", {
	  visitor: ["test", "consequent"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    consequent: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
	    }
	  }
	});
	(0, _utils.default)("SwitchStatement", {
	  visitor: ["discriminant", "cases"],
	  aliases: ["Statement", "BlockParent", "Scopable"],
	  fields: {
	    discriminant: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    cases: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
	    }
	  }
	});
	(0, _utils.default)("ThisExpression", {
	  aliases: ["Expression"]
	});
	(0, _utils.default)("ThrowStatement", {
	  visitor: ["argument"],
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("TryStatement", {
	  visitor: ["block", "handler", "finalizer"],
	  aliases: ["Statement"],
	  fields: {
	    block: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    },
	    handler: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("CatchClause")
	    },
	    finalizer: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  }
	});
	(0, _utils.default)("UnaryExpression", {
	  builder: ["operator", "argument", "prefix"],
	  fields: {
	    prefix: {
	      default: true
	    },
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    operator: {
	      validate: _utils.assertOneOf.apply(void 0, _constants.UNARY_OPERATORS)
	    }
	  },
	  visitor: ["argument"],
	  aliases: ["UnaryLike", "Expression"]
	});
	(0, _utils.default)("UpdateExpression", {
	  builder: ["operator", "argument", "prefix"],
	  fields: {
	    prefix: {
	      default: false
	    },
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    operator: {
	      validate: _utils.assertOneOf.apply(void 0, _constants.UPDATE_OPERATORS)
	    }
	  },
	  visitor: ["argument"],
	  aliases: ["Expression"]
	});
	(0, _utils.default)("VariableDeclaration", {
	  builder: ["kind", "declarations"],
	  visitor: ["declarations"],
	  aliases: ["Statement", "Declaration"],
	  fields: {
	    declare: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    kind: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("var", "let", "const"))
	    },
	    declarations: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
	    }
	  }
	});
	(0, _utils.default)("VariableDeclarator", {
	  visitor: ["id", "init"],
	  fields: {
	    id: {
	      validate: (0, _utils.assertNodeType)("LVal")
	    },
	    init: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("WhileStatement", {
	  visitor: ["test", "body"],
	  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement", "Statement")
	    }
	  }
	});
	(0, _utils.default)("WithStatement", {
	  visitor: ["object", "body"],
	  aliases: ["Statement"],
	  fields: {
	    object: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement", "Statement")
	    }
	  }
	});

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = void 0;

	var _utils = _interopRequireWildcard(__webpack_require__(12));

	var _core = __webpack_require__(24);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	(0, _utils.default)("AssignmentPattern", {
	  visitor: ["left", "right"],
	  builder: ["left", "right"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, _core.patternLikeCommon, {
	    left: {
	      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
	    }
	  })
	});
	(0, _utils.default)("ArrayPattern", {
	  visitor: ["elements", "typeAnnotation"],
	  builder: ["elements"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, _core.patternLikeCommon, {
	    elements: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("PatternLike")))
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
	    }
	  })
	});
	(0, _utils.default)("ArrowFunctionExpression", {
	  builder: ["params", "body", "async"],
	  visitor: ["params", "body", "returnType", "typeParameters"],
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
	  fields: Object.assign({}, _core.functionCommon, _core.functionTypeAnnotationCommon, {
	    expression: {
	      validate: (0, _utils.assertValueType)("boolean")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
	    }
	  })
	});
	(0, _utils.default)("ClassBody", {
	  visitor: ["body"],
	  fields: {
	    body: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassProperty", "TSDeclareMethod", "TSIndexSignature")))
	    }
	  }
	});
	var classCommon = {
	  typeParameters: {
	    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
	    optional: true
	  },
	  body: {
	    validate: (0, _utils.assertNodeType)("ClassBody")
	  },
	  superClass: {
	    optional: true,
	    validate: (0, _utils.assertNodeType)("Expression")
	  },
	  superTypeParameters: {
	    validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	    optional: true
	  },
	  implements: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
	    optional: true
	  }
	};
	(0, _utils.default)("ClassDeclaration", {
	  builder: ["id", "superClass", "body", "decorators"],
	  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
	  aliases: ["Scopable", "Class", "Statement", "Declaration", "Pureish"],
	  fields: Object.assign({}, classCommon, {
	    declare: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    abstract: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    id: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
	      optional: true
	    }
	  })
	});
	(0, _utils.default)("ClassExpression", {
	  inherits: "ClassDeclaration",
	  aliases: ["Scopable", "Class", "Expression", "Pureish"],
	  fields: Object.assign({}, classCommon, {
	    id: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("ClassBody")
	    },
	    superClass: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
	      optional: true
	    }
	  })
	});
	(0, _utils.default)("ExportAllDeclaration", {
	  visitor: ["source"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
	  fields: {
	    source: {
	      validate: (0, _utils.assertNodeType)("StringLiteral")
	    }
	  }
	});
	(0, _utils.default)("ExportDefaultDeclaration", {
	  visitor: ["declaration"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
	  fields: {
	    declaration: {
	      validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
	    }
	  }
	});
	(0, _utils.default)("ExportNamedDeclaration", {
	  visitor: ["declaration", "specifiers", "source"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
	  fields: {
	    declaration: {
	      validate: (0, _utils.assertNodeType)("Declaration"),
	      optional: true
	    },
	    specifiers: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier")))
	    },
	    source: {
	      validate: (0, _utils.assertNodeType)("StringLiteral"),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("ExportSpecifier", {
	  visitor: ["local", "exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    exported: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	(0, _utils.default)("ForOfStatement", {
	  visitor: ["left", "right", "body"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
	  fields: {
	    left: {
	      validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    },
	    await: {
	      default: false,
	      validate: (0, _utils.assertValueType)("boolean")
	    }
	  }
	});
	(0, _utils.default)("ImportDeclaration", {
	  visitor: ["specifiers", "source"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
	  fields: {
	    specifiers: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
	    },
	    source: {
	      validate: (0, _utils.assertNodeType)("StringLiteral")
	    }
	  }
	});
	(0, _utils.default)("ImportDefaultSpecifier", {
	  visitor: ["local"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	(0, _utils.default)("ImportNamespaceSpecifier", {
	  visitor: ["local"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	(0, _utils.default)("ImportSpecifier", {
	  visitor: ["local", "imported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    imported: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    importKind: {
	      validate: (0, _utils.assertOneOf)(null, "type", "typeof")
	    }
	  }
	});
	(0, _utils.default)("MetaProperty", {
	  visitor: ["meta", "property"],
	  aliases: ["Expression"],
	  fields: {
	    meta: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    property: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	var classMethodOrPropertyCommon = {
	  abstract: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  accessibility: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
	    optional: true
	  },
	  static: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  computed: {
	    default: false,
	    validate: (0, _utils.assertValueType)("boolean")
	  },
	  optional: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  key: {
	    validate: (0, _utils.chain)(function () {
	      var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
	      var computed = (0, _utils.assertNodeType)("Expression");
	      return function (node, key, val) {
	        var validator = node.computed ? computed : normal;
	        validator(node, key, val);
	      };
	    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
	  }
	};
	exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
	var classMethodOrDeclareMethodCommon = Object.assign({}, _core.functionCommon, classMethodOrPropertyCommon, {
	  kind: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("get", "set", "method", "constructor")),
	    default: "method"
	  },
	  access: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
	    optional: true
	  },
	  decorators: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
	    optional: true
	  }
	});
	exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
	(0, _utils.default)("ClassMethod", {
	  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
	  builder: ["kind", "key", "params", "body", "computed", "static"],
	  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
	  fields: Object.assign({}, classMethodOrDeclareMethodCommon, _core.functionTypeAnnotationCommon, {
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  })
	});
	(0, _utils.default)("ObjectPattern", {
	  visitor: ["properties", "typeAnnotation"],
	  builder: ["properties"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, _core.patternLikeCommon, {
	    properties: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
	    }
	  })
	});
	(0, _utils.default)("SpreadElement", {
	  visitor: ["argument"],
	  aliases: ["UnaryLike"],
	  deprecatedAlias: "SpreadProperty",
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("Super", {
	  aliases: ["Expression"]
	});
	(0, _utils.default)("TaggedTemplateExpression", {
	  visitor: ["tag", "quasi"],
	  aliases: ["Expression"],
	  fields: {
	    tag: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    quasi: {
	      validate: (0, _utils.assertNodeType)("TemplateLiteral")
	    }
	  }
	});
	(0, _utils.default)("TemplateElement", {
	  builder: ["value", "tail"],
	  fields: {
	    value: {},
	    tail: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    }
	  }
	});
	(0, _utils.default)("TemplateLiteral", {
	  visitor: ["quasis", "expressions"],
	  aliases: ["Expression", "Literal"],
	  fields: {
	    quasis: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
	    },
	    expressions: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
	    }
	  }
	});
	(0, _utils.default)("YieldExpression", {
	  builder: ["argument", "delegate"],
	  visitor: ["argument"],
	  aliases: ["Expression", "Terminatorless"],
	  fields: {
	    delegate: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    argument: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = inherit;

	var _uniq = _interopRequireDefault(__webpack_require__(154));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inherit(key, child, parent) {
	  if (child && parent) {
	    child[key] = (0, _uniq.default)([].concat(child[key], parent[key]).filter(Boolean));
	  }
	}

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isType;

	var _definitions = __webpack_require__(11);

	function isType(nodeType, targetType) {
	  if (nodeType === targetType) return true;
	  if (_definitions.ALIAS_KEYS[targetType]) return false;
	  var aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];

	  if (aliases) {
	    if (aliases[0] === nodeType) return true;

	    for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	      var _ref;

	      if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref = _iterator[_i++];
	      } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref = _i.value;
	      }

	      var _alias = _ref;
	      if (nodeType === _alias) return true;
	    }
	  }

	  return false;
	}

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/classCallCheck");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	module.exports = require("crypto");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(6),
	    GraphQLNonNull = _require.GraphQLNonNull;

	/**
	 * A scope is a mapping of the values for each argument defined by the nearest
	 * ancestor root or fragment of a given IR selection. A scope maps argument
	 * names to the argument's statically determined value, which can be either a
	 * variable or a literal.
	 *
	 * There are two categories of scopes: root scopes and fragment scopes.
	 *
	 * Root scopes apply to `Root` IR and their subselections, up until any fragment
	 * spreads. Root scopes have the property that any argument may be provided at
	 * runtime: even where a default value is defined, the compiler must consider
	 * the value to be variable. Therefore, root scopes are a mapping of argument
	 * name to variables of the same name:
	 *
	 *   Map {
	 *     foo: $foo
	 *   }
	 *
	 * Fragment scopes apply to `Fragment` IR nodes and their subselections, up
	 * until any fragment spreads. Fragment scopes differ from root scopes in
	 * several ways:
	 * - Arguments may be overridden by the including fragment spread.
	 * - Arguments may import values from the root scope.
	 * - All other arguments must have their default values, or be null.
	 *
	 * Fragment scopes are also a mapping of argument name to value, but the value
	 * may also be a literal:
	 *
	 *   Map {
	 *     foo: $foo
	 *     bar: 42
	 *   }
	 */


	/**
	 * Creates a scope for a `Root`, with each argument mapped to a variable of the
	 * same name. Example:
	 *
	 * Query:
	 * query Foo($id: ID, $size: Int = 42) { ... }
	 *
	 * Scope:
	 * {
	 *   id: $id,
	 *   size: $size,
	 * }
	 *
	 * Note that even though a default value is defined for $size, the scope must
	 * assume that this could be overridden at runtime. The value cannot be decided
	 * statically and therefore is set to a variable.
	 */
	function getRootScope(definitions) {
	  var scope = {};
	  definitions.forEach(function (definition) {
	    scope[definition.name] = {
	      kind: 'Variable',
	      variableName: definition.name
	    };
	  });
	  return scope;
	}

	/**
	 * Creates a scope for a `Fragment` by translating fragment spread arguments in
	 * the context of a parent scope into a new scope and validating them against
	 * the argument definitions.
	 *
	 *
	 * Parent Scope:
	 * {
	 *   active: $parentActive
	 * }
	 *
	 * Fragment Spread:
	 * ...Bar(size: 42, enabled: $active)
	 *
	 * Fragment:
	 * fragment Bar on Foo @argumentDefinitions(
	 *   id: {type: "ID"}
	 *   size: {type: "Int"}
	 *   enabled: {type: "Boolean}
	 *   scale: {type: "Int", imports: "pixelRatio"}
	 * )
	 *
	 * Scope:
	 * {
	 *   // No argument is provided for $id, it gets the default value which in this
	 *   // case is `null`:
	 *   id: null,
	 *
	 *   // The parent passes 42 as a literal value for $size:
	 *   size: 42,
	 *
	 *   // The parent passes a variable as the value of $enabled. This variable is
	 *   // resolved in the parent scope to the value $parentActive, which becomes
	 *   // the value of $enabled:
	 *   $enabled: $parentActive,
	 *
	 *   // $scale imports pixelRatio from the root scope. Since any argument in a
	 *   // root scope maps to a variable of the same name, that means the value of
	 *   // pixelRatio in the root is $pixelRatio:
	 *   $scale: $pixelRatio,
	 * }
	 */
	function getFragmentScope(definitions, args, parentScope) {
	  var argMap = {};
	  args.forEach(function (arg) {
	    if (arg.value.kind === 'Literal') {
	      argMap[arg.name] = arg.value;
	    } else if (arg.value.kind === 'Variable') {
	      argMap[arg.name] = parentScope[arg.value.variableName];
	    }
	  });

	  var fragmentScope = {};
	  definitions.forEach(function (definition) {
	    if (definition.kind === 'RootArgumentDefinition') {
	      __webpack_require__(2)(!argMap.hasOwnProperty(definition.name), 'RelayCompilerScope: Unexpected argument for global variable `%s`. ' + '@arguments may only be provided for variables defined in the ' + "fragment's @argumentDefinitions list.", definition.name);
	      fragmentScope[definition.name] = {
	        kind: 'Variable',
	        variableName: definition.name
	      };
	    } else {
	      var arg = argMap[definition.name];
	      if (arg == null || arg.kind === 'Literal' && arg.value == null) {
	        // No variable or literal null was passed, fall back to default
	        // value.
	        __webpack_require__(2)(definition.defaultValue != null || !(definition.type instanceof GraphQLNonNull), 'RelayCompilerScope: No value found for required argument ' + '`$%s: %s`.', definition.name, definition.type.toString());
	        fragmentScope[definition.name] = {
	          kind: 'Literal',
	          value: definition.defaultValue
	        };
	      } else {
	        // Variable or non-null literal.
	        fragmentScope[definition.name] = arg;
	      }
	    }
	  });
	  return fragmentScope;
	}

	module.exports = { getFragmentScope: getFragmentScope, getRootScope: getRootScope };

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(66),
	    AFTER = _require.AFTER,
	    BEFORE = _require.BEFORE,
	    FIRST = _require.FIRST,
	    KEY = _require.KEY,
	    LAST = _require.LAST;

	var _require2 = __webpack_require__(18),
	    ConnectionInterface = _require2.ConnectionInterface;

	var _require3 = __webpack_require__(6),
	    assertCompositeType = _require3.assertCompositeType,
	    GraphQLInterfaceType = _require3.GraphQLInterfaceType,
	    GraphQLList = _require3.GraphQLList,
	    GraphQLObjectType = _require3.GraphQLObjectType,
	    GraphQLScalarType = _require3.GraphQLScalarType,
	    GraphQLUnionType = _require3.GraphQLUnionType,
	    parse = _require3.parse;

	var _require4 = __webpack_require__(3),
	    getLiteralArgumentValues = _require4.getLiteralArgumentValues,
	    IRTransformer = _require4.IRTransformer,
	    SchemaUtils = _require4.SchemaUtils;

	var CONNECTION = 'connection';

	/**
	 * @public
	 *
	 * Transforms fields with the `@connection` directive:
	 * - Verifies that the field type is connection-like.
	 * - Adds a `handle` property to the field, either the user-provided `handle`
	 *   argument or the default value "connection".
	 * - Inserts a sub-fragment on the field to ensure that standard connection
	 *   fields are fetched (e.g. cursors, node ids, page info).
	 */
	function relayConnectionTransform(context) {
	  return IRTransformer.transform(context, {
	    Fragment: visitFragmentOrRoot,
	    LinkedField: visitLinkedField,
	    Root: visitFragmentOrRoot
	  }, function (node) {
	    return {
	      path: [],
	      connectionMetadata: [],
	      definitionName: node.name
	    };
	  });
	}

	var SCHEMA_EXTENSION = 'directive @connection(key: String!, filters: [String]) on FIELD';

	/**
	 * @internal
	 */
	function visitFragmentOrRoot(node, options) {
	  var transformedNode = this.traverse(node, options);
	  var connectionMetadata = options.connectionMetadata;
	  if (connectionMetadata.length) {
	    return (0, _extends3['default'])({}, transformedNode, {
	      metadata: (0, _extends3['default'])({}, transformedNode.metadata, {
	        connection: connectionMetadata
	      })
	    });
	  }
	  return transformedNode;
	}

	/**
	 * @internal
	 */
	function visitLinkedField(field, options) {
	  var isPlural = SchemaUtils.getNullableType(field.type) instanceof GraphQLList;
	  options.path.push(isPlural ? null : field.alias || field.name);
	  var transformedField = this.traverse(field, options);
	  var connectionDirective = field.directives.find(function (directive) {
	    return directive.name === CONNECTION;
	  });
	  if (!connectionDirective) {
	    options.path.pop();
	    return transformedField;
	  }
	  var definitionName = options.definitionName;

	  validateConnectionSelection(definitionName, transformedField);
	  validateConnectionType(definitionName, transformedField.type);

	  var pathHasPlural = options.path.includes(null);
	  var firstArg = findArg(transformedField, FIRST);
	  var lastArg = findArg(transformedField, LAST);
	  var direction = null;
	  var countArg = null;
	  var cursorArg = null;
	  if (firstArg && !lastArg) {
	    direction = 'forward';
	    countArg = firstArg;
	    cursorArg = findArg(transformedField, AFTER);
	  } else if (lastArg && !firstArg) {
	    direction = 'backward';
	    countArg = lastArg;
	    cursorArg = findArg(transformedField, BEFORE);
	  } else if (lastArg && firstArg) {
	    direction = 'bidirectional';
	    // TODO(T26511885) Maybe add connection metadata to this case
	  }
	  var countVariable = countArg && countArg.value.kind === 'Variable' ? countArg.value.variableName : null;
	  var cursorVariable = cursorArg && cursorArg.value.kind === 'Variable' ? cursorArg.value.variableName : null;
	  options.connectionMetadata.push({
	    count: countVariable,
	    cursor: cursorVariable,
	    direction: direction,
	    path: pathHasPlural ? null : [].concat((0, _toConsumableArray3['default'])(options.path))
	  });
	  options.path.pop();

	  var _getLiteralArgumentVa = getLiteralArgumentValues(connectionDirective.args),
	      key = _getLiteralArgumentVa.key,
	      filters = _getLiteralArgumentVa.filters;

	  __webpack_require__(2)(typeof key === 'string', 'RelayConnectionTransform: Expected the %s argument to @%s to ' + 'be a string literal for field %s', KEY, CONNECTION, field.name);
	  var postfix = '' + (field.alias || field.name);
	  __webpack_require__(2)(key.endsWith('_' + postfix), 'RelayConnectionTransform: Expected the %s argument to @%s to ' + 'be of form <SomeName>_%s, but get %s. For detailed explanation, check out the dex page ' + 'https://facebook.github.io/relay/docs/pagination-container.html#connection-directive', KEY, CONNECTION, postfix, key);

	  var generateFilters = function generateFilters() {
	    var filteredVariableArgs = field.args.filter(function (arg) {
	      return !ConnectionInterface.isConnectionCall({
	        name: arg.name,
	        value: null
	      });
	    }).map(function (arg) {
	      return arg.name;
	    });
	    return filteredVariableArgs.length === 0 ? null : filteredVariableArgs;
	  };

	  var handle = {
	    name: CONNECTION,
	    key: key,
	    filters: filters || generateFilters()
	  };

	  if (direction !== null) {
	    var fragment = generateConnectionFragment(this.getContext(), transformedField.type, direction);
	    transformedField = (0, _extends3['default'])({}, transformedField, {
	      selections: transformedField.selections.concat(fragment)
	    });
	  }
	  return (0, _extends3['default'])({}, transformedField, {
	    directives: transformedField.directives.filter(function (directive) {
	      return directive.name !== CONNECTION;
	    }),
	    handles: transformedField.handles ? [].concat((0, _toConsumableArray3['default'])(transformedField.handles), [handle]) : [handle]
	  });
	}

	/**
	 * @internal
	 *
	 * Generates a fragment on the given type that fetches the minimal connection
	 * fields in order to merge different pagination results together at runtime.
	 */
	function generateConnectionFragment(context, type, direction) {
	  var _ConnectionInterface$ = ConnectionInterface.get(),
	      CURSOR = _ConnectionInterface$.CURSOR,
	      EDGES = _ConnectionInterface$.EDGES,
	      END_CURSOR = _ConnectionInterface$.END_CURSOR,
	      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,
	      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,
	      NODE = _ConnectionInterface$.NODE,
	      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,
	      START_CURSOR = _ConnectionInterface$.START_CURSOR;

	  var compositeType = assertCompositeType(SchemaUtils.getNullableType(type));

	  var pageInfo = PAGE_INFO;
	  if (direction === 'forward') {
	    pageInfo += '{\n      ' + END_CURSOR + '\n      ' + HAS_NEXT_PAGE + '\n    }';
	  } else if (direction === 'backward') {
	    pageInfo += '{\n      ' + HAS_PREV_PAGE + '\n      ' + START_CURSOR + '\n    }';
	  } else {
	    pageInfo += '{\n      ' + END_CURSOR + '\n      ' + HAS_NEXT_PAGE + '\n      ' + HAS_PREV_PAGE + '\n      ' + START_CURSOR + '\n    }';
	  }

	  var fragmentString = 'fragment ConnectionFragment on ' + String(compositeType) + ' {\n      ' + EDGES + ' {\n        ' + CURSOR + '\n        ' + NODE + ' {\n          __typename # rely on GenerateRequisiteFieldTransform to add "id"\n        }\n      }\n      ' + pageInfo + '\n    }';

	  var ast = parse(fragmentString);
	  var fragmentAST = ast.definitions[0];
	  __webpack_require__(2)(fragmentAST && fragmentAST.kind === 'FragmentDefinition', 'RelayConnectionTransform: Expected a fragment definition AST.');
	  var fragment = __webpack_require__(21).transform(context.clientSchema, fragmentAST);
	  __webpack_require__(2)(fragment && fragment.kind === 'Fragment', 'RelayConnectionTransform: Expected a connection fragment.');
	  return {
	    directives: [],
	    kind: 'InlineFragment',
	    metadata: null,
	    selections: fragment.selections,
	    typeCondition: compositeType
	  };
	}

	function findArg(field, argName) {
	  return field.args && field.args.find(function (arg) {
	    return arg.name === argName;
	  });
	}

	/**
	 * @internal
	 *
	 * Validates that the selection is a valid connection:
	 * - Specifies a first or last argument to prevent accidental, unconstrained
	 *   data access.
	 * - Has an `edges` selection, otherwise there is nothing to paginate.
	 *
	 * TODO: This implementation requires the edges field to be a direct selection
	 * and not contained within an inline fragment or fragment spread. It's
	 * technically possible to remove this restriction if this pattern becomes
	 * common/necessary.
	 */
	function validateConnectionSelection(definitionName, field) {
	  var _ConnectionInterface$2 = ConnectionInterface.get(),
	      EDGES = _ConnectionInterface$2.EDGES;

	  __webpack_require__(2)(findArg(field, FIRST) || findArg(field, LAST), 'RelayConnectionTransform: Expected field `%s: %s` to have a %s or %s ' + 'argument in document `%s`.', field.name, field.type, FIRST, LAST, definitionName);
	  __webpack_require__(2)(field.selections.some(function (selection) {
	    return selection.kind === 'LinkedField' && selection.name === EDGES;
	  }), 'RelayConnectionTransform: Expected field `%s: %s` to have a %s ' + 'selection in document `%s`.', field.name, field.type, EDGES, definitionName);
	}

	/**
	 * @internal
	 *
	 * Validates that the type satisfies the Connection specification:
	 * - The type has an edges field, and edges have scalar `cursor` and object
	 *   `node` fields.
	 * - The type has a page info field which is an object with the correct
	 *   subfields.
	 */
	function validateConnectionType(definitionName, type) {
	  var _ConnectionInterface$3 = ConnectionInterface.get(),
	      CURSOR = _ConnectionInterface$3.CURSOR,
	      EDGES = _ConnectionInterface$3.EDGES,
	      END_CURSOR = _ConnectionInterface$3.END_CURSOR,
	      HAS_NEXT_PAGE = _ConnectionInterface$3.HAS_NEXT_PAGE,
	      HAS_PREV_PAGE = _ConnectionInterface$3.HAS_PREV_PAGE,
	      NODE = _ConnectionInterface$3.NODE,
	      PAGE_INFO = _ConnectionInterface$3.PAGE_INFO,
	      START_CURSOR = _ConnectionInterface$3.START_CURSOR;

	  var typeWithFields = SchemaUtils.assertTypeWithFields(SchemaUtils.getNullableType(type));
	  var typeFields = typeWithFields.getFields();
	  var edges = typeFields[EDGES];

	  __webpack_require__(2)(edges, 'RelayConnectionTransform: Expected type `%s` to have an %s field in ' + 'document `%s`.', type, EDGES, definitionName);

	  var edgesType = SchemaUtils.getNullableType(edges.type);
	  __webpack_require__(2)(edgesType instanceof GraphQLList, 'RelayConnectionTransform: Expected `%s` field on type `%s` to be a ' + 'list type in document `%s`.', EDGES, type, definitionName);
	  var edgeType = SchemaUtils.getNullableType(edgesType.ofType);
	  __webpack_require__(2)(edgeType instanceof GraphQLObjectType, 'RelayConnectionTransform: Expected %s field on type `%s` to be a list ' + 'of objects in document `%s`.', EDGES, type, definitionName);

	  var node = edgeType.getFields()[NODE];
	  __webpack_require__(2)(node, 'RelayConnectionTransform: Expected type `%s` to have an %s.%s field in ' + 'document `%s`.', type, EDGES, NODE, definitionName);
	  var nodeType = SchemaUtils.getNullableType(node.type);
	  __webpack_require__(2)(nodeType instanceof GraphQLInterfaceType || nodeType instanceof GraphQLUnionType || nodeType instanceof GraphQLObjectType, 'RelayConnectionTransform: Expected type `%s` to have an %s.%s field' + 'for which the type is an interface, object, or union in document `%s`.', type, EDGES, NODE, definitionName);

	  var cursor = edgeType.getFields()[CURSOR];
	  __webpack_require__(2)(cursor && SchemaUtils.getNullableType(cursor.type) instanceof GraphQLScalarType, 'RelayConnectionTransform: Expected type `%s` to have an ' + '%s.%s field for which the type is a scalar in document `%s`.', type, EDGES, CURSOR, definitionName);

	  var pageInfo = typeFields[PAGE_INFO];
	  __webpack_require__(2)(pageInfo, 'RelayConnectionTransform: Expected type `%s` to have a %s field ' + 'in document `%s`.', type, PAGE_INFO, definitionName);
	  var pageInfoType = SchemaUtils.getNullableType(pageInfo.type);
	  __webpack_require__(2)(pageInfoType instanceof GraphQLObjectType, 'RelayConnectionTransform: Expected type `%s` to have a %s field for ' + 'which the type is an object in document `%s`.', type, PAGE_INFO, definitionName);

	  [END_CURSOR, HAS_NEXT_PAGE, HAS_PREV_PAGE, START_CURSOR].forEach(function (fieldName) {
	    var pageInfoField = pageInfoType.getFields()[fieldName];
	    __webpack_require__(2)(pageInfoField && SchemaUtils.getNullableType(pageInfoField.type) instanceof GraphQLScalarType, 'RelayConnectionTransform: Expected type `%s` to have an ' + '%s field for which the type is an scalar in document `%s`.', pageInfo.type, fieldName, definitionName);
	  });
	}

	module.exports = {
	  CONNECTION: CONNECTION,
	  SCHEMA_EXTENSION: SCHEMA_EXTENSION,
	  transform: relayConnectionTransform
	};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	/**
	 * type NAME = any;
	 */
	function anyTypeAlias(name) {
	  return __webpack_require__(1).typeAlias(__webpack_require__(1).identifier(name), null, __webpack_require__(1).anyTypeAnnotation());
	}

	/**
	 * {|
	 *   PROPS
	 * |}
	 */
	function exactObjectTypeAnnotation(props) {
	  var typeAnnotation = __webpack_require__(1).objectTypeAnnotation(props);
	  typeAnnotation.exact = true;
	  return typeAnnotation;
	}

	/**
	 * export type NAME = TYPE
	 */
	function exportType(name, type) {
	  return __webpack_require__(1).exportNamedDeclaration(__webpack_require__(1).typeAlias(__webpack_require__(1).identifier(name), null, type), [], null);
	}

	/**
	 * import type {NAMES[0], NAMES[1], ...} from 'MODULE';
	 */
	function importTypes(names, module) {
	  var importDeclaration = __webpack_require__(1).importDeclaration(names.map(function (name) {
	    return __webpack_require__(1).importSpecifier(__webpack_require__(1).identifier(name), __webpack_require__(1).identifier(name));
	  }), __webpack_require__(1).stringLiteral(module));
	  importDeclaration.importKind = 'type';
	  return importDeclaration;
	}

	/**
	 * Create an intersection type if needed.
	 *
	 * TYPES[0] & TYPES[1] & ...
	 */
	function intersectionTypeAnnotation(types) {
	  __webpack_require__(2)(types.length > 0, 'RelayFlowBabelFactories: cannot create an intersection of 0 types');
	  return types.length === 1 ? types[0] : __webpack_require__(1).intersectionTypeAnnotation(types);
	}

	function lineComments() {
	  for (var _len = arguments.length, lines = Array(_len), _key = 0; _key < _len; _key++) {
	    lines[_key] = arguments[_key];
	  }

	  /* $FlowFixMe(>=0.70.0) This comment suppresses an error found when
	   * Flow v0.70 was deployed. To see the error delete this comment and
	   * run Flow. */
	  return lines.map(function (line) {
	    return { type: 'CommentLine', value: ' ' + line };
	  });
	}

	/**
	 * $ReadOnlyArray<TYPE>
	 */
	function readOnlyArrayOfType(thing) {
	  return __webpack_require__(1).genericTypeAnnotation(__webpack_require__(1).identifier('$ReadOnlyArray'), __webpack_require__(1).typeParameterInstantiation([thing]));
	}

	/**
	 * +KEY: VALUE
	 */
	function readOnlyObjectTypeProperty(key, value) {
	  var prop = __webpack_require__(1).objectTypeProperty(__webpack_require__(1).identifier(key), value);
	  prop.variance = __webpack_require__(1).variance('plus');
	  return prop;
	}

	function stringLiteralTypeAnnotation(value) {
	  var annotation = __webpack_require__(1).stringLiteralTypeAnnotation();
	  annotation.value = value;
	  return annotation;
	}

	/**
	 * Create a union type if needed.
	 *
	 * TYPES[0] | TYPES[1] | ...
	 */
	function unionTypeAnnotation(types) {
	  __webpack_require__(2)(types.length > 0, 'RelayFlowBabelFactories: cannot create a union of 0 types');
	  return types.length === 1 ? types[0] : __webpack_require__(1).unionTypeAnnotation(types);
	}

	module.exports = {
	  anyTypeAlias: anyTypeAlias,
	  exactObjectTypeAnnotation: exactObjectTypeAnnotation,
	  exportType: exportType,
	  importTypes: importTypes,
	  intersectionTypeAnnotation: intersectionTypeAnnotation,
	  lineComments: lineComments,
	  readOnlyArrayOfType: readOnlyArrayOfType,
	  readOnlyObjectTypeProperty: readOnlyObjectTypeProperty,
	  stringLiteralTypeAnnotation: stringLiteralTypeAnnotation,
	  unionTypeAnnotation: unionTypeAnnotation
	};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var babelGenerator = __webpack_require__(93)['default'];

	var _require = __webpack_require__(33),
	    anyTypeAlias = _require.anyTypeAlias,
	    exactObjectTypeAnnotation = _require.exactObjectTypeAnnotation,
	    exportType = _require.exportType,
	    importTypes = _require.importTypes,
	    intersectionTypeAnnotation = _require.intersectionTypeAnnotation,
	    lineComments = _require.lineComments,
	    readOnlyArrayOfType = _require.readOnlyArrayOfType,
	    readOnlyObjectTypeProperty = _require.readOnlyObjectTypeProperty,
	    stringLiteralTypeAnnotation = _require.stringLiteralTypeAnnotation,
	    unionTypeAnnotation = _require.unionTypeAnnotation;

	var _require2 = __webpack_require__(70),
	    transformScalarType = _require2.transformScalarType,
	    transformInputType = _require2.transformInputType;

	var _require3 = __webpack_require__(6),
	    GraphQLInputObjectType = _require3.GraphQLInputObjectType,
	    GraphQLNonNull = _require3.GraphQLNonNull;

	var _require4 = __webpack_require__(3),
	    FlattenTransform = _require4.FlattenTransform,
	    IRVisitor = _require4.IRVisitor,
	    Profiler = _require4.Profiler,
	    SchemaUtils = _require4.SchemaUtils;

	var isAbstractType = SchemaUtils.isAbstractType;


	function generate(node, options) {
	  var ast = IRVisitor.visit(node, createVisitor(options));
	  return babelGenerator(ast).code;
	}

	function makeProp(_ref, state, concreteType) {
	  var key = _ref.key,
	      schemaName = _ref.schemaName,
	      value = _ref.value,
	      conditional = _ref.conditional,
	      nodeType = _ref.nodeType,
	      nodeSelections = _ref.nodeSelections;

	  if (nodeType) {
	    value = transformScalarType(nodeType, state, selectionsToBabel([Array.from(__webpack_require__(15)(nodeSelections).values())], state));
	  }
	  if (schemaName === '__typename' && concreteType) {
	    value = stringLiteralTypeAnnotation(concreteType);
	  }
	  var typeProperty = readOnlyObjectTypeProperty(key, value);
	  if (conditional) {
	    typeProperty.optional = true;
	  }
	  return typeProperty;
	}

	var isTypenameSelection = function isTypenameSelection(selection) {
	  return selection.schemaName === '__typename';
	};
	var hasTypenameSelection = function hasTypenameSelection(selections) {
	  return selections.some(isTypenameSelection);
	};
	var onlySelectsTypename = function onlySelectsTypename(selections) {
	  return selections.every(isTypenameSelection);
	};

	function selectionsToBabel(selections, state, refTypeName) {
	  var baseFields = new Map();
	  var byConcreteType = {};

	  flattenArray(selections).forEach(function (selection) {
	    var concreteType = selection.concreteType;

	    if (concreteType) {
	      byConcreteType[concreteType] = byConcreteType[concreteType] || [];
	      byConcreteType[concreteType].push(selection);
	    } else {
	      var previousSel = baseFields.get(selection.key);

	      baseFields.set(selection.key, previousSel ? mergeSelection(selection, previousSel) : selection);
	    }
	  });

	  var types = [];

	  if (Object.keys(byConcreteType).length && onlySelectsTypename(Array.from(baseFields.values())) && (hasTypenameSelection(Array.from(baseFields.values())) || Object.keys(byConcreteType).every(function (type) {
	    return hasTypenameSelection(byConcreteType[type]);
	  }))) {
	    var _loop = function _loop(_concreteType) {
	      types.push(groupRefs([].concat((0, _toConsumableArray3['default'])(Array.from(baseFields.values())), (0, _toConsumableArray3['default'])(byConcreteType[_concreteType]))).map(function (selection) {
	        return makeProp(selection, state, _concreteType);
	      }));
	    };

	    for (var _concreteType in byConcreteType) {
	      _loop(_concreteType);
	    }
	    // It might be some other type then the listed concrete types. Ideally, we
	    // would set the type to diff(string, set of listed concrete types), but
	    // this doesn't exist in Flow at the time.
	    var otherProp = readOnlyObjectTypeProperty('__typename', stringLiteralTypeAnnotation('%other'));
	    otherProp.leadingComments = lineComments("This will never be '%other', but we need some", 'value in case none of the concrete values match.');
	    types.push([otherProp]);
	  } else {
	    var selectionMap = selectionsToMap(Array.from(baseFields.values()));
	    for (var _concreteType2 in byConcreteType) {
	      selectionMap = mergeSelections(selectionMap, selectionsToMap(byConcreteType[_concreteType2].map(function (sel) {
	        return (0, _extends3['default'])({}, sel, {
	          conditional: true
	        });
	      })));
	    }
	    var selectionMapValues = groupRefs(Array.from(selectionMap.values())).map(function (sel) {
	      return isTypenameSelection(sel) && sel.concreteType ? makeProp((0, _extends3['default'])({}, sel, { conditional: false }), state, sel.concreteType) : makeProp(sel, state);
	    });
	    types.push(selectionMapValues);
	  }

	  return unionTypeAnnotation(types.map(function (props) {
	    if (refTypeName) {
	      props.push(readOnlyObjectTypeProperty('$refType', __webpack_require__(1).genericTypeAnnotation(__webpack_require__(1).identifier(refTypeName))));
	    }
	    return exactObjectTypeAnnotation(props);
	  }));
	}

	function mergeSelection(a, b) {
	  if (!a) {
	    return (0, _extends3['default'])({}, b, {
	      conditional: true
	    });
	  }
	  return (0, _extends3['default'])({}, a, {
	    nodeSelections: a.nodeSelections ? mergeSelections(a.nodeSelections, __webpack_require__(15)(b.nodeSelections)) : null,
	    conditional: a.conditional && b.conditional
	  });
	}

	function mergeSelections(a, b) {
	  var merged = new Map();
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = a.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var _step$value = _step.value,
	          _key = _step$value[0],
	          _value = _step$value[1];

	      merged.set(_key, _value);
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator['return']) {
	        _iterator['return']();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;

	  try {
	    for (var _iterator2 = b.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var _step2$value = _step2.value,
	          _key2 = _step2$value[0],
	          _value2 = _step2$value[1];

	      merged.set(_key2, mergeSelection(a.get(_key2), _value2));
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2['return']) {
	        _iterator2['return']();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }

	  return merged;
	}

	function isPlural(node) {
	  return Boolean(node.metadata && node.metadata.plural);
	}

	function createVisitor(options) {
	  var state = {
	    customScalars: options.customScalars,
	    enumsHasteModule: options.enumsHasteModule,
	    existingFragmentNames: options.existingFragmentNames,
	    generatedFragments: new Set(),
	    generatedInputObjectTypes: {},
	    inputFieldWhiteList: options.inputFieldWhiteList,
	    relayRuntimeModule: options.relayRuntimeModule,
	    usedEnums: {},
	    usedFragments: new Set(),
	    useHaste: options.useHaste,
	    noFutureProofEnums: options.noFutureProofEnums
	  };

	  return {
	    leave: {
	      Root: function Root(node) {
	        var inputVariablesType = generateInputVariablesType(node, state);
	        var inputObjectTypes = generateInputObjectTypes(state);
	        var responseType = exportType(node.name + 'Response', selectionsToBabel(node.selections, state));
	        return __webpack_require__(1).program([].concat((0, _toConsumableArray3['default'])(getFragmentImports(state)), (0, _toConsumableArray3['default'])(getEnumDefinitions(state)), (0, _toConsumableArray3['default'])(inputObjectTypes), [inputVariablesType, responseType]));
	      },
	      Fragment: function Fragment(node) {
	        var selections = flattenArray(node.selections);
	        var numConecreteSelections = selections.filter(function (s) {
	          return s.concreteType;
	        }).length;
	        selections = selections.map(function (selection) {
	          if (numConecreteSelections <= 1 && isTypenameSelection(selection) && !isAbstractType(node.type)) {
	            return [(0, _extends3['default'])({}, selection, {
	              concreteType: node.type.toString()
	            })];
	          }
	          return [selection];
	        });
	        state.generatedFragments.add(node.name);
	        var refTypeName = getRefTypeName(node.name);
	        var refType = __webpack_require__(1).declareExportDeclaration(__webpack_require__(1).declareOpaqueType(__webpack_require__(1).identifier(refTypeName), null, __webpack_require__(1).genericTypeAnnotation(__webpack_require__(1).identifier('FragmentReference'))));
	        var baseType = selectionsToBabel(selections, state, refTypeName);
	        var type = isPlural(node) ? readOnlyArrayOfType(baseType) : baseType;
	        return __webpack_require__(1).program([].concat((0, _toConsumableArray3['default'])(getFragmentImports(state)), (0, _toConsumableArray3['default'])(getEnumDefinitions(state)), [importTypes(['FragmentReference'], state.relayRuntimeModule), refType, exportType(node.name, type)]));
	      },
	      InlineFragment: function InlineFragment(node) {
	        var typeCondition = node.typeCondition;
	        return flattenArray(node.selections).map(function (typeSelection) {
	          return isAbstractType(typeCondition) ? (0, _extends3['default'])({}, typeSelection, {
	            conditional: true
	          }) : (0, _extends3['default'])({}, typeSelection, {
	            concreteType: typeCondition.toString()
	          });
	        });
	      },
	      Condition: function Condition(node) {
	        return flattenArray(node.selections).map(function (selection) {
	          return (0, _extends3['default'])({}, selection, {
	            conditional: true
	          });
	        });
	      },
	      ScalarField: function ScalarField(node) {
	        return [{
	          key: node.alias || node.name,
	          schemaName: node.name,
	          value: transformScalarType(node.type, state)
	        }];
	      },
	      LinkedField: function LinkedField(node) {
	        return [{
	          key: node.alias || node.name,
	          schemaName: node.name,
	          nodeType: node.type,
	          nodeSelections: selectionsToMap(flattenArray(node.selections))
	        }];
	      },
	      FragmentSpread: function FragmentSpread(node) {
	        state.usedFragments.add(node.name);
	        return [{
	          key: '__fragments_' + node.name,
	          ref: node.name
	        }];
	      }
	    }
	  };
	}

	function selectionsToMap(selections) {
	  var map = new Map();
	  selections.forEach(function (selection) {
	    var previousSel = map.get(selection.key);
	    map.set(selection.key, previousSel ? mergeSelection(previousSel, selection) : selection);
	  });
	  return map;
	}

	function flattenArray(arrayOfArrays) {
	  var result = [];
	  arrayOfArrays.forEach(function (array) {
	    return result.push.apply(result, (0, _toConsumableArray3['default'])(array));
	  });
	  return result;
	}

	function generateInputObjectTypes(state) {
	  return Object.keys(state.generatedInputObjectTypes).map(function (typeIdentifier) {
	    var inputObjectType = state.generatedInputObjectTypes[typeIdentifier];
	    __webpack_require__(2)(typeof inputObjectType !== 'string', 'RelayCompilerFlowGenerator: Expected input object type to have been' + ' defined before calling `generateInputObjectTypes`');
	    return exportType(typeIdentifier, inputObjectType);
	  });
	}

	function generateInputVariablesType(node, state) {
	  return exportType(node.name + 'Variables', exactObjectTypeAnnotation(node.argumentDefinitions.map(function (arg) {
	    var property = __webpack_require__(1).objectTypeProperty(__webpack_require__(1).identifier(arg.name), transformInputType(arg.type, state));
	    if (!(arg.type instanceof GraphQLNonNull)) {
	      property.optional = true;
	    }
	    return property;
	  })));
	}

	function groupRefs(props) {
	  var result = [];
	  var refs = [];
	  props.forEach(function (prop) {
	    if (prop.ref) {
	      refs.push(prop.ref);
	    } else {
	      result.push(prop);
	    }
	  });
	  if (refs.length > 0) {
	    var _value3 = intersectionTypeAnnotation(refs.map(function (ref) {
	      return __webpack_require__(1).genericTypeAnnotation(__webpack_require__(1).identifier(getRefTypeName(ref)));
	    }));
	    result.push({
	      key: '$fragmentRefs',
	      conditional: false,
	      value: _value3
	    });
	  }
	  return result;
	}

	function getFragmentImports(state) {
	  var imports = [];
	  if (state.usedFragments.size > 0) {
	    var _usedFragments = Array.from(state.usedFragments).sort();
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;

	    try {
	      for (var _iterator3 = _usedFragments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	        var usedFragment = _step3.value;

	        var refTypeName = getRefTypeName(usedFragment);
	        if (!state.generatedFragments.has(usedFragment)) {
	          if (state.useHaste && state.existingFragmentNames.has(usedFragment)) {
	            // TODO(T22653277) support non-haste environments when importing
	            // fragments
	            imports.push(importTypes([refTypeName], usedFragment + '.graphql'));
	          } else {
	            imports.push(anyTypeAlias(refTypeName));
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError3 = true;
	      _iteratorError3 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
	          _iterator3['return']();
	        }
	      } finally {
	        if (_didIteratorError3) {
	          throw _iteratorError3;
	        }
	      }
	    }
	  }
	  return imports;
	}

	function getEnumDefinitions(_ref2) {
	  var enumsHasteModule = _ref2.enumsHasteModule,
	      usedEnums = _ref2.usedEnums,
	      noFutureProofEnums = _ref2.noFutureProofEnums;

	  var enumNames = Object.keys(usedEnums).sort();
	  if (enumNames.length === 0) {
	    return [];
	  }
	  if (enumsHasteModule) {
	    return [importTypes(enumNames, enumsHasteModule)];
	  }
	  return enumNames.map(function (name) {
	    var values = usedEnums[name].getValues().map(function (_ref3) {
	      var value = _ref3.value;
	      return value;
	    });
	    values.sort();
	    if (!noFutureProofEnums) {
	      values.push('%future added value');
	    }
	    return exportType(name, __webpack_require__(1).unionTypeAnnotation(values.map(function (value) {
	      return stringLiteralTypeAnnotation(value);
	    })));
	  });
	}

	function getRefTypeName(name) {
	  return name + '$ref';
	}

	var FLOW_TRANSFORMS = [__webpack_require__(22).transform, __webpack_require__(37).transform, FlattenTransform.transformWithOptions({})];

	module.exports = {
	  generate: Profiler.instrument(generate, 'RelayFlowGenerator.generate'),
	  flowTransforms: FLOW_TRANSFORMS
	};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(38),
	    hasUnaliasedSelection = _require.hasUnaliasedSelection;

	var _require2 = __webpack_require__(6),
	    assertLeafType = _require2.assertLeafType;

	var _require3 = __webpack_require__(3),
	    CompilerContext = _require3.CompilerContext,
	    IRTransformer = _require3.IRTransformer,
	    SchemaUtils = _require3.SchemaUtils;

	var isAbstractType = SchemaUtils.isAbstractType;


	var TYPENAME_KEY = '__typename';
	var STRING_TYPE = 'String';

	/**
	 * A transform that adds `__typename` field on any `LinkedField` of a union or
	 * interface type where there is no unaliased `__typename` selection.
	 */
	function relayGenerateTypeNameTransform(context) {
	  var stringType = assertLeafType(context.serverSchema.getType(STRING_TYPE));
	  var typenameField = {
	    kind: 'ScalarField',
	    alias: null,
	    args: [],
	    directives: [],
	    handles: null,
	    metadata: null,
	    name: TYPENAME_KEY,
	    type: stringType
	  };
	  var state = {
	    typenameField: typenameField
	  };
	  return IRTransformer.transform(context, {
	    LinkedField: visitLinkedField
	  }, function () {
	    return state;
	  });
	}

	function visitLinkedField(field, state) {
	  var transformedNode = this.traverse(field, state);
	  if (isAbstractType(transformedNode.type) && !hasUnaliasedSelection(transformedNode, TYPENAME_KEY)) {
	    return (0, _extends3['default'])({}, transformedNode, {
	      selections: [state.typenameField].concat((0, _toConsumableArray3['default'])(transformedNode.selections))
	    });
	  }
	  return transformedNode;
	}

	module.exports = {
	  transform: relayGenerateTypeNameTransform
	};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(3),
	    ASTCache = _require.ASTCache,
	    Profiler = _require.Profiler;

	var parseGraphQL = Profiler.instrument(__webpack_require__(6).parse, 'GraphQL.parse');

	var FIND_OPTIONS = {
	  validateNames: true
	};

	// Throws an error if parsing the file fails
	function parseFile(baseDir, file) {
	  var text = __webpack_require__(10).readFileSync(__webpack_require__(4).join(baseDir, file.relPath), 'utf8');

	  __webpack_require__(2)(text.indexOf('graphql') >= 0, 'RelayJSModuleParser: Files should be filtered before passed to the ' + 'parser, got unfiltered file `%s`.', file);

	  var astDefinitions = [];
	  __webpack_require__(62).memoizedFind(text, baseDir, file, FIND_OPTIONS).forEach(function (template) {
	    var ast = parseGraphQL(new (__webpack_require__(6).Source)(template, file.relPath));
	    __webpack_require__(2)(ast.definitions.length, 'RelayJSModuleParser: Expected GraphQL text to contain at least one ' + 'definition (fragment, mutation, query, subscription), got `%s`.', template);
	    astDefinitions.push.apply(astDefinitions, (0, _toConsumableArray3['default'])(ast.definitions));
	  });

	  return {
	    kind: 'Document',
	    definitions: astDefinitions
	  };
	}

	function getParser(baseDir) {
	  return new ASTCache({
	    baseDir: baseDir,
	    parse: parseFile
	  });
	}

	function getFileFilter(baseDir) {
	  return function (file) {
	    var text = __webpack_require__(10).readFileSync(__webpack_require__(4).join(baseDir, file.relPath), 'utf8');
	    return text.indexOf('graphql') >= 0;
	  };
	}

	module.exports = {
	  getParser: getParser,
	  getFileFilter: getFileFilter
	};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * All rights reserved.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(3),
	    CompilerContext = _require.CompilerContext,
	    IRTransformer = _require.IRTransformer,
	    isEquivalentType = _require.isEquivalentType;

	/**
	 * A transform that inlines fragment spreads with the @relay(mask: false)
	 * directive.
	 */
	function relayMaskTransform(context) {
	  return IRTransformer.transform(context, {
	    FragmentSpread: visitFragmentSpread,
	    Fragment: visitFragment
	  }, function () {
	    return {
	      hoistedArgDefs: new Map()
	    };
	  });
	}

	function visitFragment(fragment, state) {
	  var result = this.traverse(fragment, state);
	  /* $FlowFixMe(>=0.68.0 site=react_native_fb,react_native_oss) This comment
	   * suppresses an error found when Flow v0.68 was deployed. To see the error
	   * delete this comment and run Flow. */
	  if (state.hoistedArgDefs.length === 0) {
	    return result;
	  }
	  var existingArgDefs = new Map();
	  result.argumentDefinitions.forEach(function (argDef) {
	    existingArgDefs.set(argDef.name, argDef);
	  });
	  var combinedArgDefs = result.argumentDefinitions.slice(); // Copy array
	  state.hoistedArgDefs.forEach(function (hoistedArgDef, argName) {
	    var existingArgDef = existingArgDefs.get(argName);
	    if (existingArgDef) {
	      __webpack_require__(2)(areSameArgumentDefinitions(existingArgDef, hoistedArgDef.argDef), 'RelayMaskTransform: Cannot unmask fragment spread `%s` because ' + 'argument `%s` has been declared in `%s` and they are not the same.', hoistedArgDef.source, argName, fragment.name);
	      return;
	    }
	    combinedArgDefs.push(hoistedArgDef.argDef);
	  });
	  return (0, _extends3['default'])({}, result, {
	    argumentDefinitions: combinedArgDefs
	  });
	}

	function visitFragmentSpread(fragmentSpread, state) {
	  if (!isUnmaskedSpread(fragmentSpread)) {
	    return fragmentSpread;
	  }
	  __webpack_require__(2)(fragmentSpread.args.length === 0, 'RelayMaskTransform: Cannot unmask fragment spread `%s` with ' + 'arguments. Use the `ApplyFragmentArgumentTransform` before flattening', fragmentSpread.name);
	  var fragment = this.getContext().getFragment(fragmentSpread.name);
	  var result = {
	    kind: 'InlineFragment',
	    directives: fragmentSpread.directives,
	    metadata: fragmentSpread.metadata,
	    selections: fragment.selections,
	    typeCondition: fragment.type
	  };

	  __webpack_require__(2)(!fragment.argumentDefinitions.find(function (argDef) {
	    return argDef.kind === 'LocalArgumentDefinition';
	  }), 'RelayMaskTransform: Cannot unmask fragment spread `%s` because it has local ' + 'argument definition.', fragmentSpread.name);

	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = fragment.argumentDefinitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var _argDef = _step.value;

	      var hoistedArgDef = state.hoistedArgDefs.get(_argDef.name);
	      if (hoistedArgDef) {
	        __webpack_require__(2)(areSameArgumentDefinitions(_argDef, hoistedArgDef.argDef), 'RelayMaskTransform: Cannot unmask fragment spread `%s` because ' + 'argument `%s` has been declared in `%s` and they are not the same.', hoistedArgDef.source, _argDef.name, fragmentSpread.name);
	        continue;
	      }
	      state.hoistedArgDefs.set(_argDef.name, {
	        argDef: _argDef,
	        source: fragmentSpread.name
	      });
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator['return']) {
	        _iterator['return']();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return this.traverse(result, state);
	}

	function isUnmaskedSpread(spread) {
	  return Boolean(spread.metadata && spread.metadata.mask === false);
	}

	function areSameArgumentDefinitions(argDef1, argDef2) {
	  return argDef1.kind === argDef2.kind && argDef1.name === argDef2.name && isEquivalentType(argDef1.type, argDef2.type) &&
	  // Only LocalArgumentDefinition defines defaultValue
	  argDef1.defaultValue === argDef2.defaultValue;
	}

	module.exports = {
	  transform: relayMaskTransform
	};

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	function hasUnaliasedSelection(field, fieldName) {
	  return field.selections.some(function (selection) {
	    return selection.kind === 'ScalarField' && selection.alias == null && selection.name === fieldName;
	  });
	}

	module.exports = { hasUnaliasedSelection: hasUnaliasedSelection };

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(3),
	    Validator = _require.Validator;

	var GLOBAL_RULES = Validator.GLOBAL_RULES,
	    LOCAL_RULES = Validator.LOCAL_RULES,
	    validate = Validator.validate;


	function DisallowIdAsAliasValidationRule(context) {
	  return {
	    Field: function Field(field) {
	      if (
	      /* $FlowFixMe(>=0.68.0 site=react_native_fb,react_native_oss) This
	       * comment suppresses an error found when Flow v0.68 was deployed. To
	       * see the error delete this comment and run Flow. */
	      field.alias && field.alias.value === 'id' &&
	      /* $FlowFixMe(>=0.68.0 site=react_native_fb,react_native_oss) This
	       * comment suppresses an error found when Flow v0.68 was deployed. To
	       * see the error delete this comment and run Flow. */
	      field.name.value !== 'id') {
	        throw new Error('RelayValidator: Relay does not allow aliasing fields to `id`. ' + 'This name is reserved for the globally unique `id` field on ' + '`Node`.');
	      }
	    }
	  };
	}

	var relayGlobalRules = GLOBAL_RULES;

	var relayLocalRules = [].concat((0, _toConsumableArray3['default'])(LOCAL_RULES), [DisallowIdAsAliasValidationRule]);

	module.exports = {
	  GLOBAL_RULES: relayGlobalRules,
	  LOCAL_RULES: relayLocalRules,
	  validate: validate
	};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.ImportSpecifier = ImportSpecifier;
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
	exports.ExportSpecifier = ExportSpecifier;
	exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
	exports.ExportAllDeclaration = ExportAllDeclaration;
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	exports.ImportDeclaration = ImportDeclaration;
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;

	var t = _interopRequireWildcard(__webpack_require__(1));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function ImportSpecifier(node) {
	  if (node.importKind === "type" || node.importKind === "typeof") {
	    this.word(node.importKind);
	    this.space();
	  }

	  this.print(node.imported, node);

	  if (node.local && node.local.name !== node.imported.name) {
	    this.space();
	    this.word("as");
	    this.space();
	    this.print(node.local, node);
	  }
	}

	function ImportDefaultSpecifier(node) {
	  this.print(node.local, node);
	}

	function ExportDefaultSpecifier(node) {
	  this.print(node.exported, node);
	}

	function ExportSpecifier(node) {
	  this.print(node.local, node);

	  if (node.exported && node.local.name !== node.exported.name) {
	    this.space();
	    this.word("as");
	    this.space();
	    this.print(node.exported, node);
	  }
	}

	function ExportNamespaceSpecifier(node) {
	  this.token("*");
	  this.space();
	  this.word("as");
	  this.space();
	  this.print(node.exported, node);
	}

	function ExportAllDeclaration(node) {
	  this.word("export");
	  this.space();

	  if (node.exportKind === "type") {
	    this.word("type");
	    this.space();
	  }

	  this.token("*");
	  this.space();
	  this.word("from");
	  this.space();
	  this.print(node.source, node);
	  this.semicolon();
	}

	function ExportNamedDeclaration(node) {
	  if (t.isClassDeclaration(node.declaration)) {
	    this.printJoin(node.declaration.decorators, node);
	  }

	  this.word("export");
	  this.space();
	  ExportDeclaration.apply(this, arguments);
	}

	function ExportDefaultDeclaration(node) {
	  if (t.isClassDeclaration(node.declaration)) {
	    this.printJoin(node.declaration.decorators, node);
	  }

	  this.word("export");
	  this.space();
	  this.word("default");
	  this.space();
	  ExportDeclaration.apply(this, arguments);
	}

	function ExportDeclaration(node) {
	  if (node.declaration) {
	    var declar = node.declaration;
	    this.print(declar, node);
	    if (!t.isStatement(declar)) this.semicolon();
	  } else {
	    if (node.exportKind === "type") {
	      this.word("type");
	      this.space();
	    }

	    var specifiers = node.specifiers.slice(0);
	    var hasSpecial = false;

	    while (true) {
	      var first = specifiers[0];

	      if (t.isExportDefaultSpecifier(first) || t.isExportNamespaceSpecifier(first)) {
	        hasSpecial = true;
	        this.print(specifiers.shift(), node);

	        if (specifiers.length) {
	          this.token(",");
	          this.space();
	        }
	      } else {
	        break;
	      }
	    }

	    if (specifiers.length || !specifiers.length && !hasSpecial) {
	      this.token("{");

	      if (specifiers.length) {
	        this.space();
	        this.printList(specifiers, node);
	        this.space();
	      }

	      this.token("}");
	    }

	    if (node.source) {
	      this.space();
	      this.word("from");
	      this.space();
	      this.print(node.source, node);
	    }

	    this.semicolon();
	  }
	}

	function ImportDeclaration(node) {
	  this.word("import");
	  this.space();

	  if (node.importKind === "type" || node.importKind === "typeof") {
	    this.word(node.importKind);
	    this.space();
	  }

	  var specifiers = node.specifiers.slice(0);

	  if (specifiers && specifiers.length) {
	    while (true) {
	      var first = specifiers[0];

	      if (t.isImportDefaultSpecifier(first) || t.isImportNamespaceSpecifier(first)) {
	        this.print(specifiers.shift(), node);

	        if (specifiers.length) {
	          this.token(",");
	          this.space();
	        }
	      } else {
	        break;
	      }
	    }

	    if (specifiers.length) {
	      this.token("{");
	      this.space();
	      this.printList(specifiers, node);
	      this.space();
	      this.token("}");
	    }

	    this.space();
	    this.word("from");
	    this.space();
	  }

	  this.print(node.source, node);
	  this.semicolon();
	}

	function ImportNamespaceSpecifier(node) {
	  this.token("*");
	  this.space();
	  this.word("as");
	  this.space();
	  this.print(node.local, node);
	}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.needsWhitespace = needsWhitespace;
	exports.needsWhitespaceBefore = needsWhitespaceBefore;
	exports.needsWhitespaceAfter = needsWhitespaceAfter;
	exports.needsParens = needsParens;

	var whitespace = _interopRequireWildcard(__webpack_require__(95));

	var parens = _interopRequireWildcard(__webpack_require__(94));

	var t = _interopRequireWildcard(__webpack_require__(1));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function expandAliases(obj) {
	  var newObj = {};

	  function add(type, func) {
	    var fn = newObj[type];
	    newObj[type] = fn ? function (node, parent, stack) {
	      var result = fn(node, parent, stack);
	      return result == null ? func(node, parent, stack) : result;
	    } : func;
	  }

	  var _arr = Object.keys(obj);

	  for (var _i = 0; _i < _arr.length; _i++) {
	    var type = _arr[_i];
	    var aliases = t.FLIPPED_ALIAS_KEYS[type];

	    if (aliases) {
	      for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;

	        if (_isArray) {
	          if (_i2 >= _iterator.length) break;
	          _ref = _iterator[_i2++];
	        } else {
	          _i2 = _iterator.next();
	          if (_i2.done) break;
	          _ref = _i2.value;
	        }

	        var _alias = _ref;
	        add(_alias, obj[type]);
	      }
	    } else {
	      add(type, obj[type]);
	    }
	  }

	  return newObj;
	}

	var expandedParens = expandAliases(parens);
	var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
	var expandedWhitespaceList = expandAliases(whitespace.list);

	function find(obj, node, parent, printStack) {
	  var fn = obj[node.type];
	  return fn ? fn(node, parent, printStack) : null;
	}

	function isOrHasCallExpression(node) {
	  if (t.isCallExpression(node)) {
	    return true;
	  }

	  if (t.isMemberExpression(node)) {
	    return isOrHasCallExpression(node.object) || !node.computed && isOrHasCallExpression(node.property);
	  } else {
	    return false;
	  }
	}

	function needsWhitespace(node, parent, type) {
	  if (!node) return 0;

	  if (t.isExpressionStatement(node)) {
	    node = node.expression;
	  }

	  var linesInfo = find(expandedWhitespaceNodes, node, parent);

	  if (!linesInfo) {
	    var items = find(expandedWhitespaceList, node, parent);

	    if (items) {
	      for (var i = 0; i < items.length; i++) {
	        linesInfo = needsWhitespace(items[i], node, type);
	        if (linesInfo) break;
	      }
	    }
	  }

	  if (typeof linesInfo === "object" && linesInfo !== null) {
	    return linesInfo[type] || 0;
	  }

	  return 0;
	}

	function needsWhitespaceBefore(node, parent) {
	  return needsWhitespace(node, parent, "before");
	}

	function needsWhitespaceAfter(node, parent) {
	  return needsWhitespace(node, parent, "after");
	}

	function needsParens(node, parent, printStack) {
	  if (!parent) return false;

	  if (t.isNewExpression(parent) && parent.callee === node) {
	    if (isOrHasCallExpression(node)) return true;
	  }

	  return find(expandedParens, node, parent, printStack);
	}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = clone;

	var _cloneNode = _interopRequireDefault(__webpack_require__(16));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function clone(node) {
	  return (0, _cloneNode.default)(node, false);
	}

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports.default = addComments;

	function addComments(node, type, comments) {
	  if (!comments || !node) return node;
	  var key = type + "Comments";

	  if (node[key]) {
	    if (type === "leading") {
	      node[key] = comments.concat(node[key]);
	    } else {
	      node[key] = node[key].concat(comments);
	    }
	  } else {
	    node[key] = comments;
	  }

	  return node;
	}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = inheritInnerComments;

	var _inherit = _interopRequireDefault(__webpack_require__(26));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inheritInnerComments(child, parent) {
	  (0, _inherit.default)("innerComments", child, parent);
	}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = inheritLeadingComments;

	var _inherit = _interopRequireDefault(__webpack_require__(26));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inheritLeadingComments(child, parent) {
	  (0, _inherit.default)("leadingComments", child, parent);
	}

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = inheritTrailingComments;

	var _inherit = _interopRequireDefault(__webpack_require__(26));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inheritTrailingComments(child, parent) {
	  (0, _inherit.default)("trailingComments", child, parent);
	}

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = inheritsComments;

	var _inheritTrailingComments = _interopRequireDefault(__webpack_require__(46));

	var _inheritLeadingComments = _interopRequireDefault(__webpack_require__(45));

	var _inheritInnerComments = _interopRequireDefault(__webpack_require__(44));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inheritsComments(child, parent) {
	  (0, _inheritTrailingComments.default)(child, parent);
	  (0, _inheritLeadingComments.default)(child, parent);
	  (0, _inheritInnerComments.default)(child, parent);
	  return child;
	}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = toBlock;

	var _generated = __webpack_require__(5);

	var _generated2 = __webpack_require__(9);

	function toBlock(node, parent) {
	  if ((0, _generated.isBlockStatement)(node)) {
	    return node;
	  }

	  var blockNodes = [];

	  if ((0, _generated.isEmptyStatement)(node)) {
	    blockNodes = [];
	  } else {
	    if (!(0, _generated.isStatement)(node)) {
	      if ((0, _generated.isFunction)(parent)) {
	        node = (0, _generated2.returnStatement)(node);
	      } else {
	        node = (0, _generated2.expressionStatement)(node);
	      }
	    }

	    blockNodes = [node];
	  }

	  return (0, _generated2.blockStatement)(blockNodes);
	}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = toIdentifier;

	var _isValidIdentifier = _interopRequireDefault(__webpack_require__(17));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toIdentifier(name) {
	  name = name + "";
	  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
	  name = name.replace(/^[-0-9]+/, "");
	  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
	    return c ? c.toUpperCase() : "";
	  });

	  if (!(0, _isValidIdentifier.default)(name)) {
	    name = "_" + name;
	  }

	  return name || "_";
	}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = removeTypeDuplicates;

	var _generated = __webpack_require__(5);

	function removeTypeDuplicates(nodes) {
	  var generics = {};
	  var bases = {};
	  var typeGroups = [];
	  var types = [];

	  for (var i = 0; i < nodes.length; i++) {
	    var node = nodes[i];
	    if (!node) continue;

	    if (types.indexOf(node) >= 0) {
	      continue;
	    }

	    if ((0, _generated.isAnyTypeAnnotation)(node)) {
	      return [node];
	    }

	    if ((0, _generated.isFlowBaseAnnotation)(node)) {
	      bases[node.type] = node;
	      continue;
	    }

	    if ((0, _generated.isUnionTypeAnnotation)(node)) {
	      if (typeGroups.indexOf(node.types) < 0) {
	        nodes = nodes.concat(node.types);
	        typeGroups.push(node.types);
	      }

	      continue;
	    }

	    if ((0, _generated.isGenericTypeAnnotation)(node)) {
	      var name = node.id.name;

	      if (generics[name]) {
	        var existing = generics[name];

	        if (existing.typeParameters) {
	          if (node.typeParameters) {
	            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
	          }
	        } else {
	          existing = node.typeParameters;
	        }
	      } else {
	        generics[name] = node;
	      }

	      continue;
	    }

	    types.push(node);
	  }

	  for (var type in bases) {
	    types.push(bases[type]);
	  }

	  for (var _name in generics) {
	    types.push(generics[_name]);
	  }

	  return types;
	}

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = removeProperties;

	var _constants = __webpack_require__(13);

	var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

	var CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);

	function removeProperties(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

	  for (var _iterator = map, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref;

	    if (_isArray) {
	      if (_i >= _iterator.length) break;
	      _ref = _iterator[_i++];
	    } else {
	      _i = _iterator.next();
	      if (_i.done) break;
	      _ref = _i.value;
	    }

	    var _key2 = _ref;
	    if (node[_key2] != null) node[_key2] = undefined;
	  }

	  for (var _key in node) {
	    if (_key[0] === "_" && node[_key] != null) node[_key] = undefined;
	  }

	  var symbols = Object.getOwnPropertySymbols(node);

	  for (var _iterator2 = symbols, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	    var _ref2;

	    if (_isArray2) {
	      if (_i2 >= _iterator2.length) break;
	      _ref2 = _iterator2[_i2++];
	    } else {
	      _i2 = _iterator2.next();
	      if (_i2.done) break;
	      _ref2 = _i2.value;
	    }

	    var _sym = _ref2;
	    node[_sym] = null;
	  }
	}

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = removePropertiesDeep;

	var _traverseFast = _interopRequireDefault(__webpack_require__(53));

	var _removeProperties = _interopRequireDefault(__webpack_require__(51));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function removePropertiesDeep(tree, opts) {
	  (0, _traverseFast.default)(tree, _removeProperties.default, opts);
	  return tree;
	}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = traverseFast;

	var _definitions = __webpack_require__(11);

	function traverseFast(node, enter, opts) {
	  if (!node) return;
	  var keys = _definitions.VISITOR_KEYS[node.type];
	  if (!keys) return;
	  opts = opts || {};
	  enter(node, opts);

	  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref;

	    if (_isArray) {
	      if (_i >= _iterator.length) break;
	      _ref = _iterator[_i++];
	    } else {
	      _i = _iterator.next();
	      if (_i.done) break;
	      _ref = _i.value;
	    }

	    var _key = _ref;
	    var subNode = node[_key];

	    if (Array.isArray(subNode)) {
	      for (var _iterator2 = subNode, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;

	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }

	        var _node2 = _ref2;
	        traverseFast(_node2, enter, opts);
	      }
	    } else {
	      traverseFast(subNode, enter, opts);
	    }
	  }
	}

/***/ }),
/* 54 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports.default = shallowEqual;

	function shallowEqual(actual, expected) {
	  var keys = Object.keys(expected);
	  var _arr = keys;

	  for (var _i = 0; _i < _arr.length; _i++) {
	    var key = _arr[_i];

	    if (actual[key] !== expected[key]) {
	      return false;
	    }
	  }

	  return true;
	}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = buildMatchMemberExpression;

	var _matchesPattern = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function buildMatchMemberExpression(match, allowPartial) {
	  var parts = match.split(".");
	  return function (member) {
	    return (0, _matchesPattern.default)(member, parts, allowPartial);
	  };
	}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isLet;

	var _generated = __webpack_require__(5);

	var _constants = __webpack_require__(13);

	function isLet(node) {
	  return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
	}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isNode;

	var _definitions = __webpack_require__(11);

	function isNode(node) {
	  return !!(node && _definitions.VISITOR_KEYS[node.type]);
	}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = matchesPattern;

	var _generated = __webpack_require__(5);

	function matchesPattern(member, match, allowPartial) {
	  if (!(0, _generated.isMemberExpression)(member)) return false;
	  var parts = Array.isArray(match) ? match : match.split(".");
	  var nodes = [];
	  var node;

	  for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
	    nodes.push(node.property);
	  }

	  nodes.push(node);
	  if (nodes.length < parts.length) return false;
	  if (!allowPartial && nodes.length > parts.length) return false;

	  for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
	    var _node = nodes[j];
	    var value = void 0;

	    if ((0, _generated.isIdentifier)(_node)) {
	      value = _node.name;
	    } else if ((0, _generated.isStringLiteral)(_node)) {
	      value = _node.value;
	    } else {
	      return false;
	    }

	    if (parts[i] !== value) return false;
	  }

	  return true;
	}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = validate;

	var _definitions = __webpack_require__(11);

	function validate(node, key, val) {
	  if (!node) return;
	  var fields = _definitions.NODE_FIELDS[node.type];
	  if (!fields) return;
	  var field = fields[key];
	  if (!field || !field.validate) return;
	  if (field.optional && val == null) return;
	  field.validate(node, key, val);
	}

/***/ }),
/* 60 */
/***/ (function(module, exports) {

	module.exports = require("os");

/***/ }),
/* 61 */
/***/ (function(module, exports) {

	module.exports = require("util");

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(3),
	    Profiler = _require.Profiler;

	// Attempt to be as inclusive as possible of source text.
	var BABYLON_OPTIONS = {
	  allowImportExportEverywhere: true,
	  allowReturnOutsideFunction: true,
	  allowSuperOutsideMethod: true,
	  sourceType: 'module',
	  plugins: [
	  // Previously "*"
	  'asyncGenerators', 'classProperties', 'decorators', 'doExpressions', 'dynamicImport', 'exportExtensions', 'flow', 'functionBind', 'functionSent', 'jsx', 'objectRestSpread'],
	  strictMode: false
	};

	function find(text, filePath, _ref) {
	  var validateNames = _ref.validateNames;

	  var result = [];
	  var ast = __webpack_require__(143).parse(text, BABYLON_OPTIONS);
	  var moduleName = __webpack_require__(78)(filePath);

	  var visitors = {
	    CallExpression: function CallExpression(node) {
	      var callee = node.callee;
	      if (!(callee.type === 'Identifier' && CREATE_CONTAINER_FUNCTIONS[callee.name] || callee.kind === 'MemberExpression' && callee.object.type === 'Identifier' && callee.object.value === 'Relay' && callee.property.type === 'Identifier' && CREATE_CONTAINER_FUNCTIONS[callee.property.name])) {
	        traverse(node, visitors);
	        return;
	      }
	      var fragments = node.arguments[1];
	      if (fragments.type === 'ObjectExpression') {
	        fragments.properties.forEach(function (property) {
	          !(property.type === 'ObjectProperty' && property.key.type === 'Identifier' && property.value.type === 'TaggedTemplateExpression') ?  true ? invariant(false, 'FindGraphQLTags: `%s` expects fragment definitions to be ' + '`key: graphql`.', node.callee.name) : invariant(false) : void 0;
	          var keyName = property.key.name;
	          !isGraphQLTag(property.value.tag) ?  true ? invariant(false, 'FindGraphQLTags: `%s` expects fragment definitions to be tagged ' + 'with `graphql`, got `%s`.', node.callee.name, getSourceTextForLocation(text, property.value.tag.loc)) : invariant(false) : void 0;
	          var template = getGraphQLText(property.value.quasi);
	          if (validateNames) {
	            validateTemplate(template, moduleName, keyName, filePath, getSourceLocationOffset(property.value.quasi));
	          }
	          result.push(template);
	        });
	      } else {
	        !(fragments && fragments.type === 'TaggedTemplateExpression') ?  true ? invariant(false, 'FindGraphQLTags: `%s` expects a second argument of fragment ' + 'definitions.', node.callee.name) : invariant(false) : void 0;
	        !isGraphQLTag(fragments.tag) ?  true ? invariant(false, 'FindGraphQLTags: `%s` expects fragment definitions to be tagged ' + 'with `graphql`, got `%s`.', node.callee.name, getSourceTextForLocation(text, fragments.tag.loc)) : invariant(false) : void 0;
	        var template = getGraphQLText(fragments.quasi);
	        if (validateNames) {
	          validateTemplate(template, moduleName, null, filePath, getSourceLocationOffset(fragments.quasi));
	        }
	        result.push(template);
	      }

	      // Visit remaining arguments
	      for (var ii = 2; ii < node.arguments.length; ii++) {
	        visit(node.arguments[ii], visitors);
	      }
	    },
	    TaggedTemplateExpression: function TaggedTemplateExpression(node) {
	      if (isGraphQLTag(node.tag)) {
	        var template = getGraphQLText(node.quasi);
	        if (validateNames) {
	          validateTemplate(template, moduleName, null, filePath, getSourceLocationOffset(node.quasi));
	        }
	        result.push(node.quasi.quasis[0].value.raw);
	      }
	    }
	  };
	  visit(ast, visitors);
	  return result;
	}

	var cache = new (__webpack_require__(65))('FindGraphQLTags', 'v1');

	function memoizedFind(text, baseDir, file, options) {
	  !file.exists ?  true ? invariant(false, 'FindGraphQLTags: Called with non-existent file `%s`', file.relPath) : invariant(false) : void 0;
	  return cache.getOrCompute(file.hash + (options.validateNames ? '1' : '0'), function () {
	    var absPath = __webpack_require__(4).join(baseDir, file.relPath);
	    return find(text, absPath, options);
	  });
	}

	var CREATE_CONTAINER_FUNCTIONS = Object.create(null, {
	  createFragmentContainer: { value: true },
	  createPaginationContainer: { value: true },
	  createRefetchContainer: { value: true }
	});

	var IGNORED_KEYS = {
	  comments: true,
	  end: true,
	  leadingComments: true,
	  loc: true,
	  name: true,
	  start: true,
	  trailingComments: true,
	  type: true
	};

	function isGraphQLTag(tag) {
	  return tag.type === 'Identifier' && tag.name === 'graphql';
	}

	function getTemplateNode(quasi) {
	  var quasis = quasi.quasis;
	  !(quasis && quasis.length === 1) ?  true ? invariant(false, 'FindGraphQLTags: Substitutions are not allowed in graphql tags.') : invariant(false) : void 0;
	  return quasis[0];
	}

	function getGraphQLText(quasi) {
	  return getTemplateNode(quasi).value.raw;
	}

	function getSourceLocationOffset(quasi) {
	  var loc = getTemplateNode(quasi).loc.start;
	  return {
	    line: loc.line,
	    column: loc.column + 1 // babylon is 0-indexed, graphql expects 1-indexed
	  };
	}

	function getSourceTextForLocation(text, loc) {
	  if (loc == null) {
	    return '(source unavailable)';
	  }
	  var lines = text.split('\n').slice(loc.start.line - 1, loc.end.line);
	  lines[0] = lines[0].slice(loc.start.column);
	  lines[lines.length - 1] = lines[lines.length - 1].slice(0, loc.end.column);
	  return lines.join('\n');
	}

	function validateTemplate(template, moduleName, keyName, filePath, loc) {
	  var ast = __webpack_require__(6).parse(new (__webpack_require__(6).Source)(template, filePath, loc));
	  ast.definitions.forEach(function (def) {
	    !def.name ?  true ? invariant(false, 'FindGraphQLTags: In module `%s`, a definition of kind `%s` requires a name.', moduleName, def.kind) : invariant(false) : void 0;
	    var definitionName = def.name.value;
	    if (def.kind === 'OperationDefinition') {
	      var operationNameParts = definitionName.match(/^(.*)(Mutation|Query|Subscription)$/);
	      !(operationNameParts && definitionName.startsWith(moduleName)) ?  true ? invariant(false, 'FindGraphQLTags: Operation names in graphql tags must be prefixed ' + 'with the module name and end in "Mutation", "Query", or ' + '"Subscription". Got `%s` in module `%s`.', definitionName, moduleName) : invariant(false) : void 0;
	    } else if (def.kind === 'FragmentDefinition') {
	      if (keyName) {
	        !(definitionName === moduleName + '_' + keyName) ?  true ? invariant(false, 'FindGraphQLTags: Container fragment names must be ' + '`<ModuleName>_<propName>`. Got `%s`, expected `%s`.', definitionName, moduleName + '_' + keyName) : invariant(false) : void 0;
	      } else {
	        !definitionName.startsWith(moduleName) ?  true ? invariant(false, 'FindGraphQLTags: Fragment names in graphql tags must be prefixed ' + 'with the module name. Got `%s` in module `%s`.', definitionName, moduleName) : invariant(false) : void 0;
	      }
	    }
	  });
	}

	function invariant(condition, msg) {
	  if (!condition) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }

	    throw new Error(__webpack_require__(61).format.apply(__webpack_require__(61), [msg].concat(args)));
	  }
	}

	function visit(node, visitors) {
	  var fn = visitors[node.type];
	  if (fn != null) {
	    fn(node);
	    return;
	  }
	  traverse(node, visitors);
	}

	function traverse(node, visitors) {
	  for (var key in node) {
	    if (IGNORED_KEYS[key]) {
	      continue;
	    }
	    var prop = node[key];
	    if (prop && typeof prop === 'object' && typeof prop.type === 'string') {
	      visit(prop, visitors);
	    } else if (Array.isArray(prop)) {
	      prop.forEach(function (item) {
	        if (item && typeof item === 'object' && typeof item.type === 'string') {
	          visit(item, visitors);
	        }
	      });
	    }
	  }
	}

	module.exports = {
	  find: Profiler.instrument(find, 'FindGraphQLTags.find'),
	  memoizedFind: memoizedFind
	};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(3),
	    getIdentifierForArgumentValue = _require.getIdentifierForArgumentValue,
	    IRTransformer = _require.IRTransformer;

	var getFragmentScope = __webpack_require__(31).getFragmentScope,
	    getRootScope = __webpack_require__(31).getRootScope;

	/**
	 * A tranform that converts a set of documents containing fragments/fragment
	 * spreads *with* arguments to one where all arguments have been inlined. This
	 * is effectively static currying of functions. Nodes are changed as follows:
	 * - Fragment spreads with arguments are replaced with references to an inlined
	 *   version of the referenced fragment.
	 * - Fragments with argument definitions are cloned once per unique set of
	 *   arguments, with the name changed to original name + hash and all nested
	 *   variable references changed to the value of that variable given its
	 *   arguments.
	 * - Field & directive argument variables are replaced with the value of those
	 *   variables in context.
	 * - All nodes are cloned with updated children.
	 *
	 * The transform also handles statically passing/failing Condition nodes:
	 * - Literal Conditions with a passing value are elided and their selections
	 *   inlined in their parent.
	 * - Literal Conditions with a failing value are removed.
	 * - Nodes that would become empty as a result of the above are removed.
	 *
	 * Note that unreferenced fragments are not added to the output.
	 */


	function relayApplyFragmentArgumentTransform(context) {
	  var fragments = new Map();
	  var nextContext = IRTransformer.transform(context, {
	    Root: function Root(node) {
	      var scope = getRootScope(node.argumentDefinitions);
	      return transformNode(context, fragments, scope, node);
	    },
	    // Fragments are included below where referenced.
	    // Unreferenced fragments are not included.
	    Fragment: function Fragment() {
	      return null;
	    }
	  });

	  return Array.from(fragments.values()).reduce(function (ctx, fragment) {
	    return fragment ? ctx.add(fragment) : ctx;
	  }, nextContext);
	}

	function transformNode(context, fragments, scope, node) {
	  var selections = transformSelections(context, fragments, scope, node.selections);
	  if (!selections) {
	    return null;
	  }
	  if (node.hasOwnProperty('directives')) {
	    var directives = transformDirectives(scope, node.directives);
	    // $FlowIssue: this is a valid `Node`:
	    return (0, _extends3['default'])({}, node, {
	      directives: directives,
	      selections: selections
	    });
	  }
	  return (0, _extends3['default'])({}, node, {
	    selections: selections
	  });
	}

	function transformFragmentSpread(context, fragments, scope, spread) {
	  var directives = transformDirectives(scope, spread.directives);
	  var fragment = context.getFragment(spread.name);
	  var appliedFragment = transformFragment(context, fragments, scope, fragment, spread.args);
	  if (!appliedFragment) {
	    return null;
	  }
	  return (0, _extends3['default'])({}, spread, {
	    args: [],
	    directives: directives,
	    name: appliedFragment.name
	  });
	}

	function transformDeferrableFragmentSpread(context, fragments, scope, spread) {
	  var directives = transformDirectives(scope, spread.directives);
	  var fragment = context.getFragment(spread.name);
	  var appliedFragment = transformFragment(context, fragments, scope, fragment, spread.fragmentArgs);
	  if (!appliedFragment) {
	    return null;
	  }
	  return (0, _extends3['default'])({}, spread, {
	    fragmentArgs: [],
	    directives: directives,
	    name: appliedFragment.name
	  });
	}

	function transformField(context, fragments, scope, field) {
	  var args = transformArguments(scope, field.args);
	  var directives = transformDirectives(scope, field.directives);
	  if (field.kind === 'LinkedField') {
	    var selections = transformSelections(context, fragments, scope, field.selections);
	    if (!selections) {
	      return null;
	    }
	    // $FlowFixMe(>=0.28.0)
	    return (0, _extends3['default'])({}, field, {
	      args: args,
	      directives: directives,
	      selections: selections
	    });
	  } else {
	    return (0, _extends3['default'])({}, field, {
	      args: args,
	      directives: directives
	    });
	  }
	}

	function transformCondition(context, fragments, scope, node) {
	  var condition = transformValue(scope, node.condition);
	  __webpack_require__(2)(condition.kind === 'Literal' || condition.kind === 'Variable', 'RelayApplyFragmentArgumentTransform: A non-scalar value was applied to ' + 'an @include or @skip directive, the `if` argument value must be a ' + 'variable or a Boolean, got `%s`.', condition);
	  if (condition.kind === 'Literal' && condition.value !== node.passingValue) {
	    // Dead code, no need to traverse further.
	    return null;
	  }
	  var selections = transformSelections(context, fragments, scope, node.selections);
	  if (!selections) {
	    return null;
	  }
	  if (condition.kind === 'Literal' && condition.value === node.passingValue) {
	    // Always passes, return inlined selections
	    return selections;
	  }
	  return [(0, _extends3['default'])({}, node, {
	    condition: condition,
	    selections: selections
	  })];
	}

	function transformSelections(context, fragments, scope, selections) {
	  var nextSelections = null;
	  selections.forEach(function (selection) {
	    var nextSelection = void 0;
	    if (selection.kind === 'InlineFragment') {
	      nextSelection = transformNode(context, fragments, scope, selection);
	    } else if (selection.kind === 'FragmentSpread') {
	      nextSelection = transformFragmentSpread(context, fragments, scope, selection);
	    } else if (selection.kind === 'DeferrableFragmentSpread') {
	      nextSelection = transformDeferrableFragmentSpread(context, fragments, scope, selection);
	    } else if (selection.kind === 'Condition') {
	      var conditionSelections = transformCondition(context, fragments, scope, selection);
	      if (conditionSelections) {
	        var _nextSelections;

	        nextSelections = nextSelections || [];
	        (_nextSelections = nextSelections).push.apply(_nextSelections, (0, _toConsumableArray3['default'])(conditionSelections));
	      }
	    } else {
	      nextSelection = transformField(context, fragments, scope, selection);
	    }
	    if (nextSelection) {
	      nextSelections = nextSelections || [];
	      nextSelections.push(nextSelection);
	    }
	  });
	  return nextSelections;
	}

	function transformDirectives(scope, directives) {
	  return directives.map(function (directive) {
	    var args = transformArguments(scope, directive.args);
	    return (0, _extends3['default'])({}, directive, {
	      args: args
	    });
	  });
	}

	function transformArguments(scope, args) {
	  return args.map(function (arg) {
	    var value = transformValue(scope, arg.value);
	    return value === arg.value ? arg : (0, _extends3['default'])({}, arg, { value: value });
	  });
	}

	function transformValue(scope, value) {
	  if (value.kind === 'Variable') {
	    var scopeValue = scope[value.variableName];
	    __webpack_require__(2)(scopeValue != null, 'RelayApplyFragmentArgumentTransform: variable `%s` is not in scope.', value.variableName);
	    return scopeValue;
	  } else if (value.kind === 'ListValue') {
	    return (0, _extends3['default'])({}, value, {
	      items: value.items.map(function (item) {
	        return transformValue(scope, item);
	      })
	    });
	  } else if (value.kind === 'ObjectValue') {
	    return (0, _extends3['default'])({}, value, {
	      fields: value.fields.map(function (field) {
	        return (0, _extends3['default'])({}, field, {
	          value: transformValue(scope, field.value)
	        });
	      })
	    });
	  }
	  return value;
	}

	/**
	 * Apply arguments to a fragment, creating a new fragment (with the given name)
	 * with all values recursively applied.
	 */
	function transformFragment(context, fragments, parentScope, fragment, args) {
	  var argumentsHash = hashArguments(args, parentScope);
	  var fragmentName = argumentsHash ? fragment.name + '_' + argumentsHash : fragment.name;
	  var appliedFragment = fragments.get(fragmentName);
	  if (appliedFragment) {
	    return appliedFragment;
	  }
	  var fragmentScope = getFragmentScope(fragment.argumentDefinitions, args, parentScope);
	  __webpack_require__(2)(!fragments.has(fragmentName) || fragments.get(fragmentName) !== undefined, 'RelayApplyFragmentArgumentTransform: Found a circular reference from ' + 'fragment `%s`.', fragment.name);
	  fragments.set(fragmentName, undefined); // to detect circular references
	  var transformedFragment = null;
	  var selections = transformSelections(context, fragments, fragmentScope, fragment.selections);
	  if (selections) {
	    transformedFragment = (0, _extends3['default'])({}, fragment, {
	      selections: selections,
	      name: fragmentName,
	      argumentDefinitions: []
	    });
	  }
	  fragments.set(fragmentName, transformedFragment);
	  return transformedFragment;
	}

	function hashArguments(args, scope) {
	  if (!args.length) {
	    return null;
	  }
	  var sortedArgs = [].concat((0, _toConsumableArray3['default'])(args)).sort(function (a, b) {
	    return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
	  });
	  var printedArgs = JSON.stringify(sortedArgs.map(function (arg) {
	    var value = void 0;
	    if (arg.value.kind === 'Variable') {
	      value = scope[arg.value.variableName];
	      __webpack_require__(2)(value != null, 'RelayApplyFragmentArgumentTransform: variable `%s` is not in scope.', arg.value.variableName);
	    } else {
	      value = arg.value;
	    }
	    return {
	      name: arg.name,
	      value: getIdentifierForArgumentValue(value)
	    };
	  }));
	  return __webpack_require__(79)(printedArgs);
	}

	module.exports = {
	  transform: relayApplyFragmentArgumentTransform
	};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(18),
	    getStorageKey = _require.getStorageKey,
	    stableCopy = _require.stableCopy;

	var _require2 = __webpack_require__(6),
	    GraphQLList = _require2.GraphQLList;

	var _require3 = __webpack_require__(3),
	    IRVisitor = _require3.IRVisitor,
	    SchemaUtils = _require3.SchemaUtils;

	var getRawType = SchemaUtils.getRawType,
	    isAbstractType = SchemaUtils.isAbstractType,
	    getNullableType = SchemaUtils.getNullableType;


	/**
	 * @public
	 *
	 * Converts a GraphQLIR node into a plain JS object representation that can be
	 * used at runtime.
	 */
	function generate(node) {
	  __webpack_require__(2)(['Batch', 'Fragment'].indexOf(node.kind) >= 0, 'RelayCodeGenerator: Unknown AST kind `%s`. Source: %s.', node.kind, getErrorMessage(node));
	  return IRVisitor.visit(node, RelayCodeGenVisitor);
	}

	var RelayCodeGenVisitor = {
	  leave: {
	    Batch: function Batch(node) {
	      __webpack_require__(2)(node.requests.length !== 0, 'Batch must contain Requests.');
	      if (isSingleRequest(node)) {
	        var request = node.requests[0];
	        return {
	          kind: 'Request',
	          operationKind: request.root.operation,
	          name: node.name,
	          id: request.id,
	          text: request.text,
	          metadata: node.metadata,
	          fragment: node.fragment,
	          operation: {
	            kind: 'Operation',
	            name: request.root.name,
	            argumentDefinitions: request.root.argumentDefinitions,
	            selections: flattenArray(request.root.selections)
	          }
	        };
	      } else {
	        return {
	          kind: 'BatchRequest',
	          operationKind: node.requests[0].root.operation,
	          name: node.name,
	          metadata: node.metadata,
	          fragment: node.fragment,
	          requests: node.requests.map(function (request) {
	            var isDeferrableFragment = request.metadata && request.metadata.deferrable;
	            var operation = isDeferrableFragment ? {
	              kind: 'DeferrableOperation',
	              name: request.root.name,
	              argumentDefinitions: request.root.argumentDefinitions,
	              selections: flattenArray(request.root.selections),
	              fragmentName: request.metadata.fragmentName,
	              rootFieldVariable: request.metadata.rootFieldVariable
	            } : {
	              kind: 'Operation',
	              name: request.root.name,
	              argumentDefinitions: request.root.argumentDefinitions,
	              selections: flattenArray(request.root.selections)
	            };

	            return {
	              name: request.name,
	              id: request.id,
	              text: request.text,
	              argumentDependencies: request.argumentDependencies.map(function (dependency) {
	                return {
	                  name: dependency.argumentName,
	                  fromRequestName: dependency.fromName,
	                  fromRequestPath: dependency.fromPath,
	                  ifList: dependency.ifList,
	                  ifNull: dependency.ifNull,
	                  maxRecurse: dependency.maxRecurse
	                };
	              }),
	              operation: operation
	            };
	          })
	        };
	      }
	    },
	    Fragment: function Fragment(node) {
	      return {
	        kind: 'Fragment',
	        name: node.name,
	        type: node.type.toString(),
	        metadata: node.metadata || null,
	        argumentDefinitions: node.argumentDefinitions,
	        selections: flattenArray(node.selections)
	      };
	    },
	    LocalArgumentDefinition: function LocalArgumentDefinition(node) {
	      return {
	        kind: 'LocalArgument',
	        name: node.name,
	        type: node.type.toString(),
	        defaultValue: node.defaultValue
	      };
	    },
	    RootArgumentDefinition: function RootArgumentDefinition(node) {
	      return {
	        kind: 'RootArgument',
	        name: node.name,
	        type: node.type ? node.type.toString() : null
	      };
	    },
	    Condition: function Condition(node, key, parent, ancestors) {
	      __webpack_require__(2)(node.condition.kind === 'Variable', 'RelayCodeGenerator: Expected static `Condition` node to be ' + 'pruned or inlined. Source: %s.', getErrorMessage(ancestors[0]));
	      return {
	        kind: 'Condition',
	        passingValue: node.passingValue,
	        condition: node.condition.variableName,
	        selections: flattenArray(node.selections)
	      };
	    },
	    FragmentSpread: function FragmentSpread(node) {
	      return {
	        kind: 'FragmentSpread',
	        name: node.name,
	        args: valuesOrNull(sortByName(node.args))
	      };
	    },
	    DeferrableFragmentSpread: function DeferrableFragmentSpread(node) {
	      return {
	        kind: 'DeferrableFragmentSpread',
	        name: node.name,
	        args: valuesOrNull(sortByName(node.args)),
	        rootFieldVariable: node.rootFieldVariable,
	        storageKey: node.storageKey
	      };
	    },
	    InlineFragment: function InlineFragment(node) {
	      return {
	        kind: 'InlineFragment',
	        type: node.typeCondition.toString(),
	        selections: flattenArray(node.selections)
	      };
	    },
	    LinkedField: function LinkedField(node) {
	      // Note: it is important that the arguments of this field be sorted to
	      // ensure stable generation of storage keys for equivalent arguments
	      // which may have originally appeared in different orders across an app.
	      var handles = node.handles && node.handles.map(function (handle) {
	        return {
	          kind: 'LinkedHandle',
	          alias: node.alias,
	          name: node.name,
	          args: valuesOrNull(sortByName(node.args)),
	          handle: handle.name,
	          key: handle.key,
	          filters: handle.filters
	        };
	      }) || [];
	      var type = getRawType(node.type);
	      var field = {
	        kind: 'LinkedField',
	        alias: node.alias,
	        name: node.name,
	        storageKey: null,
	        args: valuesOrNull(sortByName(node.args)),
	        concreteType: !isAbstractType(type) ? type.toString() : null,
	        plural: isPlural(node.type),
	        selections: flattenArray(node.selections)
	      };
	      // Precompute storageKey if possible
	      field.storageKey = getStaticStorageKey(field);
	      return [field].concat(handles);
	    },
	    ScalarField: function ScalarField(node) {
	      // Note: it is important that the arguments of this field be sorted to
	      // ensure stable generation of storage keys for equivalent arguments
	      // which may have originally appeared in different orders across an app.
	      var handles = node.handles && node.handles.map(function (handle) {
	        return {
	          kind: 'ScalarHandle',
	          alias: node.alias,
	          name: node.name,
	          args: valuesOrNull(sortByName(node.args)),
	          handle: handle.name,
	          key: handle.key,
	          filters: handle.filters
	        };
	      }) || [];
	      var field = {
	        kind: 'ScalarField',
	        alias: node.alias,
	        name: node.name,
	        args: valuesOrNull(sortByName(node.args)),
	        selections: valuesOrUndefined(flattenArray(node.selections)),
	        storageKey: null
	      };
	      // Precompute storageKey if possible
	      field.storageKey = getStaticStorageKey(field);
	      return [field].concat(handles);
	    },
	    Variable: function Variable(node, key, parent) {
	      return {
	        kind: 'Variable',
	        name: parent.name,
	        variableName: node.variableName,
	        type: parent.type ? parent.type.toString() : null
	      };
	    },
	    Literal: function Literal(node, key, parent) {
	      return {
	        kind: 'Literal',
	        name: parent.name,
	        value: stableCopy(node.value),
	        type: parent.type ? parent.type.toString() : null
	      };
	    },
	    Argument: function Argument(node, key, parent, ancestors) {
	      __webpack_require__(2)(['Variable', 'Literal'].indexOf(node.value.kind) >= 0, 'RelayCodeGenerator: Complex argument values (Lists or ' + 'InputObjects with nested variables) are not supported, argument ' + '`%s` had value `%s`. Source: %s.', node.name, JSON.stringify(node.value, null, 2), getErrorMessage(ancestors[0]));
	      return node.value.value !== null ? node.value : null;
	    }
	  }
	};

	function isSingleRequest(batch) {
	  return batch.requests.length === 1 && batch.requests[0].argumentDependencies.length === 0;
	}

	function isPlural(type) {
	  return getNullableType(type) instanceof GraphQLList;
	}

	function valuesOrUndefined(array) {
	  return !array || array.length === 0 ? undefined : array;
	}

	function valuesOrNull(array) {
	  return !array || array.length === 0 ? null : array;
	}

	function flattenArray(array) {
	  return array ? Array.prototype.concat.apply([], array) : [];
	}

	function sortByName(array) {
	  return array instanceof Array ? array.sort(function (a, b) {
	    return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
	  }) : array;
	}

	function getErrorMessage(node) {
	  return 'document ' + node.name;
	}

	/**
	 * Pre-computes storage key if possible and advantageous. Storage keys are
	 * generated for fields with supplied arguments that are all statically known
	 * (ie. literals, no variables) at build time.
	 */
	function getStaticStorageKey(field) {
	  if (!field.args || field.args.length === 0 || field.args.some(function (arg) {
	    return arg.kind !== 'Literal';
	  })) {
	    return null;
	  }
	  return getStorageKey(field, {});
	}

	module.exports = { generate: generate };

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(29));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(3),
	    Profiler = _require.Profiler;

	/**
	 * A file backed cache. Values are JSON encoded on disk, so only JSON
	 * serializable values should be used.
	 */


	var RelayCompilerCache = function () {

	  /**
	   * @param name         Human readable identifier for the cache
	   * @param cacheBreaker This should be changed in order to invalidate existing
	   *                     caches.
	   */
	  function RelayCompilerCache(name, cacheBreaker) {
	    (0, _classCallCheck3['default'])(this, RelayCompilerCache);

	    // Include username in the cache dir to avoid issues with directories being
	    // owned by a different user.
	    var username = __webpack_require__(60).userInfo().username;
	    var cacheID = __webpack_require__(30).createHash('md5').update(cacheBreaker).update(username).digest('hex');
	    this._dir = __webpack_require__(4).join(__webpack_require__(60).tmpdir(), name + '-' + cacheID);
	    if (!__webpack_require__(10).existsSync(this._dir)) {
	      __webpack_require__(10).mkdirSync(this._dir);
	    }
	  }

	  RelayCompilerCache.prototype.getOrCompute = function getOrCompute(key, compute) {
	    var _this = this;

	    return Profiler.run('RelayCompilerCache.getOrCompute', function () {
	      var cacheFile = __webpack_require__(4).join(_this._dir, key);
	      if (__webpack_require__(10).existsSync(cacheFile)) {
	        return JSON.parse(__webpack_require__(10).readFileSync(cacheFile, 'utf8'));
	      }
	      var value = compute();
	      __webpack_require__(10).writeFileSync(cacheFile, JSON.stringify(value), 'utf8');
	      return value;
	    });
	  };

	  return RelayCompilerCache;
	}();

	module.exports = RelayCompilerCache;

/***/ }),
/* 66 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var AFTER = 'after';
	var BEFORE = 'before';
	var FIRST = 'first';
	var KEY = 'key';
	var LAST = 'last';

	module.exports = {
	  AFTER: AFTER,
	  BEFORE: BEFORE,
	  FIRST: FIRST,
	  KEY: KEY,
	  LAST: LAST
	};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(6),
	    doTypesOverlap = _require.doTypesOverlap,
	    getNamedType = _require.getNamedType,
	    isInputType = _require.isInputType,
	    GraphQLInterfaceType = _require.GraphQLInterfaceType,
	    GraphQLList = _require.GraphQLList,
	    GraphQLInputType = _require.GraphQLInputType;

	var _require2 = __webpack_require__(3),
	    IRTransformer = _require2.IRTransformer,
	    IRVisitor = _require2.IRVisitor;

	var DEFERRABLE_ARGUMENT_NAME = 'deferrableID';

	/**
	 * Deferrable fragment spreads are transformed into a series of individual
	 * dependent operation requests, expected to be executed as part of a batch
	 * operation.
	 *
	 * To achieve this transform, two steps are performed:
	 *
	 *   1) `transformOperations` is responsible for identifying which fragments
	 *      are deferrable and creating new root operations for them, as well as
	 *      creating the "dependent request" associations between them.
	 *
	 *   2) `transformSpreads` is responsible for replacing deferrable fragment
	 *      spreads with an `id` field. This step should only apply to the "query"
	 *      compiler phase, so that the request sent to the GraphQL server does not
	 *      contain the deferrable fragment and in its place has the information
	 *      necessary to later fulfill that fragment.
	 *
	 */
	function transform(context) {
	  // First, in an initial pass over all definitions, collect the path to each
	  // fragment spread from within a fragment or operation, as well as the set of
	  var spreadUsesWithin = new Map();
	  var deferrableFragments = new Set();
	  context.forEachDocument(function (document) {
	    var pathParts = [];
	    var spreadUses = [];
	    spreadUsesWithin.set(document, spreadUses);
	    IRVisitor.visit(document, {
	      LinkedField: {
	        enter: function enter(field) {
	          var pathPart = field.alias || field.name;
	          var fieldType = field.type;
	          while (fieldType.ofType) {
	            if (fieldType instanceof GraphQLList) {
	              pathPart += '[*]';
	            }
	            fieldType = fieldType.ofType;
	          }
	          pathParts.push(pathPart);
	        },
	        leave: function leave() {
	          pathParts.pop();
	        }
	      },
	      FragmentSpread: function FragmentSpread(spread) {
	        spreadUses.push({ spread: spread, path: pathParts.join('.') });
	        if (isDeferrable(spread)) {
	          deferrableFragments.add(context.getFragment(spread.name));
	        }
	      }
	    });
	  });

	  // If no fragments have been deferrable, then no transformation is necessary.
	  if (deferrableFragments.size === 0) {
	    return context;
	  }

	  // Next, transform any existing root operations to include references to
	  // their dependent requests.
	  var transformedContext = IRTransformer.transform(context, {
	    Root: function Root(root) {
	      var dependentRequests = createDependentRequests(context, spreadUsesWithin, root);
	      // If this operation contains deferrable spreads, then it will have
	      // additional dependent requests.
	      return dependentRequests.length === 0 ? root : (0, _extends3['default'])({}, root, {
	        dependentRequests: [].concat((0, _toConsumableArray3['default'])(root.dependentRequests), dependentRequests)
	      });
	    }
	  });

	  // Finally, add new operations representing each deferrable fragment.
	  var deferrableOperations = Array.from(deferrableFragments).map(function (fragment) {
	    // Create the deferrable operation.
	    var deferrableOperation = createDeferrableOperation(context, fragment);

	    // Include the deferrable operation along with the necessary
	    // additional variable definitions and dependent requests.
	    var argumentDefinitions = createArgumentDefinitions(context, spreadUsesWithin, fragment);
	    var dependentRequests = createDependentRequests(context, spreadUsesWithin, fragment);
	    var completeDeferrableOperation = (0, _extends3['default'])({}, deferrableOperation, {
	      argumentDefinitions: [].concat((0, _toConsumableArray3['default'])(deferrableOperation.argumentDefinitions), argumentDefinitions),
	      dependentRequests: [].concat((0, _toConsumableArray3['default'])(deferrableOperation.dependentRequests), dependentRequests)
	    });
	    return completeDeferrableOperation;
	  });

	  return transformSpreads(transformedContext, spreadUsesWithin).addAll(deferrableOperations);
	}

	/**
	 * The second step of the Deferrable transform, replacing deferrable spreads
	 * with deferrable refetch references which correspond to the dependent requests
	 */
	function transformSpreads(context, spreadUsesWithin) {
	  // Next, transform the definitions:
	  //  - Replacing deferrable spreads with refetch references.
	  //  - Adding dependent requests to operations.
	  return IRTransformer.transform(context, {
	    FragmentSpread: function FragmentSpread(spread) {
	      if (!isDeferrable(spread)) {
	        return spread;
	      }
	      // If this spread is deferrable, replace it with a refetch reference.
	      // The deferrable reference is definitionally not a FragmentSpread,
	      // though the transformer expects functions to return the same type.
	      return createDeferrableReference(context, spreadUsesWithin, spread);
	    }
	  });
	}

	// True if the FragmentSpread is marked as deferrable.
	function isDeferrable(spread) {
	  return Boolean(spread.metadata && spread.metadata.deferrable);
	}

	// Given a fragment, return the variable definitions necessary for all
	// variables used across deeply within.
	function createArgumentDefinitions(context, spreadUsesWithin, fragment) {
	  // Collect all recursively included definitions from the root.
	  var includedFragments = new Set([fragment]);
	  var nodesToVisit = [fragment];
	  while (nodesToVisit.length !== 0) {
	    var spreadUses = __webpack_require__(15)(spreadUsesWithin.get(nodesToVisit.pop()));
	    for (var i = 0; i < spreadUses.length; i++) {
	      var includedFragment = context.getFragment(spreadUses[i].spread.name);
	      if (!includedFragments.has(includedFragment)) {
	        includedFragments.add(includedFragment);
	        nodesToVisit.push(includedFragment);
	      }
	    }
	  }

	  // Then get all variables used in all included fragments to determine
	  // additional variable definitions, ensuring one definition per variable.
	  var variableDefinitions = new Map();
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = includedFragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var _includedFragment = _step.value;
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = _includedFragment.argumentDefinitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var argumentDefinition = _step2.value;

	          if (!variableDefinitions.has(argumentDefinition.name)) {
	            variableDefinitions.set(argumentDefinition.name, {
	              kind: 'LocalArgumentDefinition',
	              metadata: argumentDefinition.metadata,
	              name: argumentDefinition.name,
	              type: argumentDefinition.type,
	              defaultValue: argumentDefinition.kind === 'LocalArgumentDefinition' ? argumentDefinition.defaultValue : null
	            });
	          }
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
	            _iterator2['return']();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator['return']) {
	        _iterator['return']();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return Array.from(variableDefinitions.values());
	}

	// Given a fragment or node, return the set of dependent requests to fulfill.
	// Defines the relationship between deferrable reference selections (above) and
	// the deferrable operations dependent on them (below).
	function createDependentRequests(context, spreadUsesWithin, from) {
	  var spreadUses = getDeferrableSpreadUses(context, spreadUsesWithin, from);
	  return spreadUses.map(function (_ref) {
	    var spread = _ref.spread,
	        path = _ref.path;
	    return {
	      operationName: spread.name + '_Deferrable',
	      metadata: {
	        deferrable: true,
	        fragmentName: spread.name,
	        rootFieldVariable: DEFERRABLE_ARGUMENT_NAME
	      },
	      argumentDependencies: [{
	        kind: 'ArgumentDependency',
	        argumentName: DEFERRABLE_ARGUMENT_NAME,
	        fromName: from.name,
	        fromPath: path + '.' + deferrableAlias(spread.name),
	        ifList: 'each',
	        ifNull: 'skip'
	      }]
	    };
	  });
	}

	// A utility function which collects the paths to deferrable spreads from
	// a given starting Root or Fragment definition. Used above to determine the
	// dependent requests from an operation.
	var memoizedDeferrableSpreadUses = new WeakMap();
	function getDeferrableSpreadUses(context, spreadUsesWithin, node) {
	  var deferrableSpreadUses = memoizedDeferrableSpreadUses.get(node);
	  if (!deferrableSpreadUses) {
	    deferrableSpreadUses = [];
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;

	    try {
	      for (var _iterator3 = __webpack_require__(15)(spreadUsesWithin.get(node))[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	        var spreadUse = _step3.value;

	        if (isDeferrable(spreadUse.spread)) {
	          deferrableSpreadUses.push(spreadUse);
	        } else {
	          var nestedSpreadUses = getDeferrableSpreadUses(context, spreadUsesWithin, context.getFragment(spreadUse.spread.name));
	          var _iteratorNormalCompletion4 = true;
	          var _didIteratorError4 = false;
	          var _iteratorError4 = undefined;

	          try {
	            for (var _iterator4 = nestedSpreadUses[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	              var nestedSpreadUse = _step4.value;

	              var separator = spreadUse.path === '' || nestedSpreadUse.path === '' ? '' : '.';
	              deferrableSpreadUses.push({
	                spread: nestedSpreadUse.spread,
	                path: spreadUse.path + separator + nestedSpreadUse.path
	              });
	            }
	          } catch (err) {
	            _didIteratorError4 = true;
	            _iteratorError4 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion4 && _iterator4['return']) {
	                _iterator4['return']();
	              }
	            } finally {
	              if (_didIteratorError4) {
	                throw _iteratorError4;
	              }
	            }
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError3 = true;
	      _iteratorError3 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
	          _iterator3['return']();
	        }
	      } finally {
	        if (_didIteratorError3) {
	          throw _iteratorError3;
	        }
	      }
	    }

	    memoizedDeferrableSpreadUses.set(node, deferrableSpreadUses);
	  }
	  return deferrableSpreadUses;
	}

	// Utility function for creating a deferrable reference selection from a
	// deferrable fragment spread. This selection will be depended upon by another
	// operation in a batch request to fulfill the deferrable fragment.
	function createDeferrableReference(context, spreadUsesWithin, spread) {
	  var schema = context.clientSchema;
	  var nodeType = getNodeType(schema);
	  var idType = getIdType(schema);
	  var fragment = context.getFragment(spread.name);
	  var fragmentType = fragment.type;
	  __webpack_require__(2)(doTypesOverlap(schema, fragmentType, nodeType), 'RelayDeferrableFragmentsTransform: Cannot defer %s since objects of ' + 'type %s can never also be of type Node.', spread.name, fragmentType);
	  __webpack_require__(2)(spread.args.length === 0, 'RelayDeferrableFragmentsTransform: Cannot defer %s with arguments.', spread.name);

	  var argumentDefinitions = createArgumentDefinitions(context, spreadUsesWithin, fragment);
	  // The deferrable fragment spread is replaced with two nested inline
	  // fragments. The outer of which ensures the type condition of the original
	  // fragment applies, while the inner specfically conditions on Node, so
	  // id may be safely queried. This is a conservative application known to
	  // always be safe, however the "FlattenTransform" may remove these if they
	  // are unnecessary.
	  //
	  // The metadata and directives of the deferrable fragment spread are
	  // transferred to the deferrable id field.
	  return {
	    kind: 'InlineFragment',
	    metadata: null,
	    typeCondition: fragmentType,
	    directives: [],
	    selections: [{
	      kind: 'InlineFragment',
	      metadata: null,
	      typeCondition: nodeType,
	      directives: [],
	      selections: [deferrableFragmentSpread(spread, idType, argumentDefinitions)]
	    }]
	  };
	}

	// Utility function for creating an operation from a deferrable fragment.
	function createDeferrableOperation(context, fragment) {
	  var schema = context.clientSchema;
	  var queryType = schema.getQueryType();
	  __webpack_require__(2)(queryType, 'RelayDeferrableFragmentTransform: "Query" must be a defined type');
	  var nodeField = queryType.getFields().node;
	  __webpack_require__(2)(nodeField, 'RelayDeferrableFragmentTransform: "Query" must define the field "node"');
	  var idArg = nodeField.args.find(function (arg) {
	    return arg.name === 'id';
	  });
	  __webpack_require__(2)(idArg && isInputType(idArg.type), 'RelayDeferrableFragmentTransform: "node" field must define the argument "id"');
	  var idType = idArg.type;
	  return {
	    kind: 'Root',
	    operation: 'query',
	    metadata: { deferred: true },
	    name: fragment.name + '_Deferrable',
	    dependentRequests: [],
	    argumentDefinitions: [{
	      kind: 'LocalArgumentDefinition',
	      metadata: null,
	      name: DEFERRABLE_ARGUMENT_NAME,
	      defaultValue: null,
	      type: idType
	    }],
	    directives: [],
	    selections: [{
	      kind: 'LinkedField',
	      name: 'node',
	      alias: null,
	      args: [{
	        kind: 'Argument',
	        name: 'id',
	        metadata: null,
	        value: {
	          kind: 'Variable',
	          variableName: DEFERRABLE_ARGUMENT_NAME,
	          metadata: null,
	          type: idType
	        },
	        type: idType
	      }],
	      directives: [],
	      metadata: null,
	      handles: null,
	      selections: [{
	        kind: 'FragmentSpread',
	        args: [],
	        name: fragment.name,
	        metadata: null,
	        directives: []
	      }],
	      type: nodeField.type
	    }],
	    type: queryType
	  };
	}

	function deferrableAlias(name) {
	  return name + '_' + DEFERRABLE_ARGUMENT_NAME;
	}

	function deferrableFragmentSpread(spread, idType, argumentDefinitions) {
	  return {
	    kind: 'DeferrableFragmentSpread',
	    name: spread.name,
	    directives: [],
	    fragmentArgs: spread.args,
	    args: argumentDefinitions.map(function (x) {
	      return {
	        kind: 'Argument',
	        metadata: null,
	        name: x.name,
	        type: x.type,
	        value: {
	          kind: 'Variable',
	          metadata: null,
	          type: x.type,
	          variableName: x.name
	        }
	      };
	    }).concat([{
	      kind: 'Argument',
	      metadata: null,
	      name: DEFERRABLE_ARGUMENT_NAME,
	      type: idType,
	      value: {
	        kind: 'Variable',
	        metadata: null,
	        type: idType,
	        variableName: DEFERRABLE_ARGUMENT_NAME
	      }
	    }]),
	    rootFieldVariable: DEFERRABLE_ARGUMENT_NAME,
	    storageKey: 'id',
	    alias: deferrableAlias(spread.name)
	  };
	}

	function getNodeType(schema) {
	  var nodeType = schema.getType('Node');
	  __webpack_require__(2)(nodeType instanceof GraphQLInterfaceType, 'RelayDeferrableFragmentTransform: Schema must define the interface "Node".');
	  return nodeType;
	}

	function getIdType(schema) {
	  var nodeType = getNodeType(schema);
	  var idField = nodeType.getFields().id;
	  __webpack_require__(2)(idField, 'RelayDeferrableFragmentTransform: "Node" must define the field "id"');
	  var idType = getNamedType(idField.type);
	  __webpack_require__(2)(isInputType(idType), 'RelayDeferrableFragmentTransform: "Node" must define the scalar field "id"');
	  return idType;
	}

	module.exports = { transform: transform };

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(18),
	    getRelayHandleKey = _require.getRelayHandleKey;

	var _require2 = __webpack_require__(3),
	    CompilerContext = _require2.CompilerContext,
	    IRTransformer = _require2.IRTransformer;

	function relayFieldHandleTransform(context) {
	  return IRTransformer.transform(context, {
	    LinkedField: visitField,
	    ScalarField: visitField
	  });
	}

	/**
	 * @internal
	 */
	function visitField(field) {
	  if (field.kind === 'LinkedField') {
	    field = this.traverse(field);
	  }
	  var handles = field.handles;
	  if (!handles || !handles.length) {
	    return field;
	  }
	  // ensure exactly one handle
	  __webpack_require__(2)(handles.length === 1, 'RelayFieldHandleTransform: Expected fields to have at most one ' + '"handle" property, got `%s`.', handles.join(', '));
	  var alias = field.alias || field.name;
	  var handle = handles[0];
	  var name = getRelayHandleKey(handle.name, handle.key, field.name);
	  var filters = handle.filters;
	  var args = filters ? field.args.filter(function (arg) {
	    return filters.indexOf(arg.name) > -1;
	  }) : [];

	  return (0, _extends3['default'])({}, field, {
	    args: args,
	    alias: alias,
	    name: name,
	    handles: null
	  });
	}

	module.exports = {
	  transform: relayFieldHandleTransform
	};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _asyncToGenerator2 = __webpack_require__(28);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(29));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(3),
	    ASTConvert = _require.ASTConvert,
	    CodegenDirectory = _require.CodegenDirectory,
	    CompilerContext = _require.CompilerContext,
	    Profiler = _require.Profiler,
	    SchemaUtils = _require.SchemaUtils;

	var _require2 = __webpack_require__(146),
	    ImmutableMap = _require2.Map;

	var isExecutableDefinitionAST = SchemaUtils.isExecutableDefinitionAST;

	var RelayFileWriter = function () {
	  function RelayFileWriter(_ref) {
	    var config = _ref.config,
	        onlyValidate = _ref.onlyValidate,
	        baseDocuments = _ref.baseDocuments,
	        documents = _ref.documents,
	        schema = _ref.schema,
	        reporter = _ref.reporter,
	        sourceControl = _ref.sourceControl;
	    (0, _classCallCheck3['default'])(this, RelayFileWriter);

	    this._baseDocuments = baseDocuments || ImmutableMap();
	    this._baseSchema = schema;
	    this._config = config;
	    this._documents = documents;
	    this._onlyValidate = onlyValidate;
	    this._reporter = reporter;
	    this._sourceControl = sourceControl;

	    validateConfig(this._config);
	  }

	  RelayFileWriter.prototype.writeAll = function writeAll() {
	    var _this = this;

	    return Profiler.asyncContext('RelayFileWriter.writeAll', (0, _asyncToGenerator3.default)(function* () {
	      // Can't convert to IR unless the schema already has Relay-local extensions
	      var transformedSchema = ASTConvert.transformASTSchema(_this._baseSchema, _this._config.schemaExtensions);
	      var extendedSchema = ASTConvert.extendASTSchema(transformedSchema, _this._baseDocuments.merge(_this._documents).valueSeq().toArray());

	      // Build a context from all the documents
	      var baseDefinitionNames = new Set();
	      _this._baseDocuments.forEach(function (doc) {
	        doc.definitions.forEach(function (def) {
	          if (isExecutableDefinitionAST(def) && def.name) {
	            baseDefinitionNames.add(def.name.value);
	          }
	        });
	      });
	      var definitionsMeta = new Map();
	      var getDefinitionMeta = function getDefinitionMeta(definitionName) {
	        var definitionMeta = definitionsMeta.get(definitionName);
	        __webpack_require__(2)(definitionMeta, 'RelayFileWriter: Could not determine source for definition: `%s`.', definitionName);
	        return definitionMeta;
	      };
	      var allOutputDirectories = new Map();
	      var addCodegenDir = function addCodegenDir(dirPath) {
	        var codegenDir = new CodegenDirectory(dirPath, {
	          onlyValidate: _this._onlyValidate
	        });
	        allOutputDirectories.set(dirPath, codegenDir);
	        return codegenDir;
	      };

	      var configOutputDirectory = void 0;
	      if (_this._config.outputDir) {
	        configOutputDirectory = addCodegenDir(_this._config.outputDir);
	      }

	      _this._documents.forEach(function (doc, filePath) {
	        doc.definitions.forEach(function (def) {
	          if (def.name) {
	            definitionsMeta.set(def.name.value, {
	              dir: __webpack_require__(4).join(_this._config.baseDir, __webpack_require__(4).dirname(filePath)),
	              ast: def
	            });
	          }
	        });
	      });

	      // Verify using local and global rules, can run global verifications here
	      // because all files are processed together
	      var validationRules = [].concat((0, _toConsumableArray3['default'])(__webpack_require__(39).LOCAL_RULES), (0, _toConsumableArray3['default'])(__webpack_require__(39).GLOBAL_RULES));
	      var customizedValidationRules = _this._config.validationRules;
	      if (customizedValidationRules) {
	        validationRules = [].concat((0, _toConsumableArray3['default'])(validationRules), (0, _toConsumableArray3['default'])(customizedValidationRules.LOCAL_RULES || []), (0, _toConsumableArray3['default'])(customizedValidationRules.GLOBAL_RULES || []));
	      }

	      var definitions = ASTConvert.convertASTDocumentsWithBase(extendedSchema, _this._baseDocuments.valueSeq().toArray(), _this._documents.valueSeq().toArray(), validationRules, __webpack_require__(21).transform.bind(__webpack_require__(21)));

	      var compilerContext = new CompilerContext(_this._baseSchema, extendedSchema).addAll(definitions);

	      var getGeneratedDirectory = function getGeneratedDirectory(definitionName) {
	        if (configOutputDirectory) {
	          return configOutputDirectory;
	        }
	        var generatedPath = __webpack_require__(4).join(getDefinitionMeta(definitionName).dir, '__generated__');
	        var cachedDir = allOutputDirectories.get(generatedPath);
	        if (!cachedDir) {
	          cachedDir = addCodegenDir(generatedPath);
	        }
	        return cachedDir;
	      };

	      var transformedFlowContext = compilerContext.applyTransforms(__webpack_require__(34).flowTransforms, _this._reporter);
	      var transformedQueryContext = compilerContext.applyTransforms([].concat((0, _toConsumableArray3['default'])(_this._config.compilerTransforms.commonTransforms), (0, _toConsumableArray3['default'])(_this._config.compilerTransforms.queryTransforms)), _this._reporter);
	      var artifacts = __webpack_require__(74)(compilerContext, _this._config.compilerTransforms, _this._reporter);

	      var existingFragmentNames = new Set(definitions.map(function (definition) {
	        return definition.name;
	      }));

	      // TODO(T22651734): improve this to correctly account for fragments that
	      // have generated flow types.
	      baseDefinitionNames.forEach(function (baseDefinitionName) {
	        existingFragmentNames['delete'](baseDefinitionName);
	      });

	      var formatModule = Profiler.instrument(_this._config.formatModule, 'RelayFileWriter:formatModule');

	      var persistQuery = _this._config.persistQuery ? Profiler.instrumentWait(_this._config.persistQuery, 'RelayFileWriter:persistQuery') : null;

	      try {
	        yield Promise.all(artifacts.map((() => {
	          var _ref3 = (0, _asyncToGenerator3.default)(function* (node) {
	            if (baseDefinitionNames.has(node.name)) {
	              // don't add definitions that were part of base context
	              return;
	            }
	            if (node.metadata && node.metadata.deferred) {
	              // don't write deferred operations, the batch request is
	              // responsible for them
	              return;
	            }
	            var relayRuntimeModule = _this._config.relayRuntimeModule || 'relay-runtime';

	            var flowNode = transformedFlowContext.get(node.name);
	            __webpack_require__(2)(flowNode, 'RelayFileWriter: did not compile flow types for: %s', node.name);

	            var flowTypes = __webpack_require__(34).generate(flowNode, {
	              customScalars: _this._config.customScalars,
	              enumsHasteModule: _this._config.enumsHasteModule,
	              existingFragmentNames: existingFragmentNames,
	              inputFieldWhiteList: _this._config.inputFieldWhiteListForFlow,
	              relayRuntimeModule: relayRuntimeModule,
	              useHaste: _this._config.useHaste,
	              noFutureProofEnums: _this._config.noFutureProofEnums
	            });

	            var sourceHash = Profiler.run('hashGraphQL', function () {
	              return md5(__webpack_require__(6).print(getDefinitionMeta(node.name).ast));
	            });

	            yield __webpack_require__(81)(getGeneratedDirectory(node.name), node, formatModule, flowTypes, persistQuery, _this._config.platform, relayRuntimeModule, sourceHash);
	          });

	          return function (_x) {
	            return _ref3.apply(this, arguments);
	          };
	        })()));

	        var _generateExtraFiles = _this._config.generateExtraFiles;
	        if (_generateExtraFiles) {
	          Profiler.run('RelayFileWriter:generateExtraFiles', function () {
	            var configDirectory = _this._config.outputDir;
	            _generateExtraFiles(function (dir) {
	              var outputDirectory = dir || configDirectory;
	              __webpack_require__(2)(outputDirectory, 'RelayFileWriter: cannot generate extra files without specifying ' + 'an outputDir in the config or passing it in.');
	              var outputDir = allOutputDirectories.get(outputDirectory);
	              if (!outputDir) {
	                outputDir = addCodegenDir(outputDirectory);
	              }
	              return outputDir;
	            }, transformedQueryContext, getGeneratedDirectory);
	          });
	        }

	        // clean output directories
	        allOutputDirectories.forEach(function (dir) {
	          dir.deleteExtraFiles();
	        });
	        if (_this._sourceControl && !_this._onlyValidate) {
	          yield CodegenDirectory.sourceControlAddRemove(_this._sourceControl, Array.from(allOutputDirectories.values()));
	        }
	      } catch (error) {
	        var details = void 0;
	        try {
	          details = JSON.parse(error.message);
	        } catch (_) {}
	        if (details && details.name === 'GraphQL2Exception' && details.message) {
	          throw new Error('GraphQL error writing modules:\n' + details.message);
	        }
	        throw new Error('Error writing modules:\n' + String(error.stack || error));
	      }

	      return allOutputDirectories;
	    }));
	  };

	  return RelayFileWriter;
	}();

	function md5(x) {
	  return __webpack_require__(30).createHash('md5').update(x, 'utf8').digest('hex');
	}

	function validateConfig(config) {
	  if (config.buildCommand) {
	    process.stderr.write('WARNING: RelayFileWriter: For RelayFileWriter to work you must ' + 'replace config.buildCommand with config.formatModule.\n');
	  }
	}

	module.exports = RelayFileWriter;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(33),
	    readOnlyArrayOfType = _require.readOnlyArrayOfType;

	var _require2 = __webpack_require__(6),
	    GraphQLEnumType = _require2.GraphQLEnumType,
	    GraphQLInputType = _require2.GraphQLInputType,
	    GraphQLInputObjectType = _require2.GraphQLInputObjectType,
	    GraphQLInterfaceType = _require2.GraphQLInterfaceType,
	    GraphQLList = _require2.GraphQLList,
	    GraphQLNonNull = _require2.GraphQLNonNull,
	    GraphQLObjectType = _require2.GraphQLObjectType,
	    GraphQLScalarType = _require2.GraphQLScalarType,
	    GraphQLType = _require2.GraphQLType,
	    GraphQLUnionType = _require2.GraphQLUnionType;

	function getInputObjectTypeIdentifier(type) {
	  return type.name;
	}

	function transformScalarType(type, state, objectProps) {
	  if (type instanceof GraphQLNonNull) {
	    return transformNonNullableScalarType(type.ofType, state, objectProps);
	  } else {
	    return __webpack_require__(1).nullableTypeAnnotation(transformNonNullableScalarType(type, state, objectProps));
	  }
	}

	function transformNonNullableScalarType(type, state, objectProps) {
	  if (type instanceof GraphQLList) {
	    return readOnlyArrayOfType(transformScalarType(type.ofType, state, objectProps));
	  } else if (type instanceof GraphQLObjectType || type instanceof GraphQLUnionType || type instanceof GraphQLInterfaceType) {
	    return objectProps;
	  } else if (type instanceof GraphQLScalarType) {
	    return transformGraphQLScalarType(type, state);
	  } else if (type instanceof GraphQLEnumType) {
	    return transformGraphQLEnumType(type, state);
	  } else {
	    throw new Error('Could not convert from GraphQL type ' + type.toString());
	  }
	}

	function transformGraphQLScalarType(type, state) {
	  var customType = state.customScalars[type.name];
	  switch (customType || type.name) {
	    case 'ID':
	    case 'String':
	      return __webpack_require__(1).stringTypeAnnotation();
	    case 'Float':
	    case 'Int':
	      return __webpack_require__(1).numberTypeAnnotation();
	    case 'Boolean':
	      return __webpack_require__(1).booleanTypeAnnotation();
	    default:
	      return customType == null ? __webpack_require__(1).anyTypeAnnotation() : __webpack_require__(1).genericTypeAnnotation(__webpack_require__(1).identifier(customType));
	  }
	}

	function transformGraphQLEnumType(type, state) {
	  state.usedEnums[type.name] = type;
	  return __webpack_require__(1).genericTypeAnnotation(__webpack_require__(1).identifier(type.name));
	}

	function transformInputType(type, state) {
	  if (type instanceof GraphQLNonNull) {
	    return transformNonNullableInputType(type.ofType, state);
	  } else {
	    return __webpack_require__(1).nullableTypeAnnotation(transformNonNullableInputType(type, state));
	  }
	}

	function transformNonNullableInputType(type, state) {
	  if (type instanceof GraphQLList) {
	    return readOnlyArrayOfType(transformInputType(type.ofType, state));
	  } else if (type instanceof GraphQLScalarType) {
	    return transformGraphQLScalarType(type, state);
	  } else if (type instanceof GraphQLEnumType) {
	    return transformGraphQLEnumType(type, state);
	  } else if (type instanceof GraphQLInputObjectType) {
	    var typeIdentifier = getInputObjectTypeIdentifier(type);
	    if (state.generatedInputObjectTypes[typeIdentifier]) {
	      return __webpack_require__(1).genericTypeAnnotation(__webpack_require__(1).identifier(typeIdentifier));
	    }
	    state.generatedInputObjectTypes[typeIdentifier] = 'pending';
	    var fields = type.getFields();
	    var props = Object.keys(fields).map(function (key) {
	      return fields[key];
	    }).filter(function (field) {
	      return state.inputFieldWhiteList.indexOf(field.name) < 0;
	    }).map(function (field) {
	      var property = __webpack_require__(1).objectTypeProperty(__webpack_require__(1).identifier(field.name), transformInputType(field.type, state));
	      if (!(field.type instanceof GraphQLNonNull)) {
	        property.optional = true;
	      }
	      return property;
	    });
	    state.generatedInputObjectTypes[typeIdentifier] = __webpack_require__(1).objectTypeAnnotation(props);
	    return __webpack_require__(1).genericTypeAnnotation(__webpack_require__(1).identifier(typeIdentifier));
	  } else {
	    throw new Error('Could not convert from GraphQL type ' + type.toString());
	  }
	}

	module.exports = {
	  transformInputType: transformInputType,
	  transformScalarType: transformScalarType
	};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(38),
	    hasUnaliasedSelection = _require.hasUnaliasedSelection;

	var _require2 = __webpack_require__(6),
	    assertAbstractType = _require2.assertAbstractType,
	    assertCompositeType = _require2.assertCompositeType,
	    assertLeafType = _require2.assertLeafType;

	var _require3 = __webpack_require__(3),
	    CompilerContext = _require3.CompilerContext,
	    SchemaUtils = _require3.SchemaUtils,
	    IRTransformer = _require3.IRTransformer;

	var canHaveSelections = SchemaUtils.canHaveSelections,
	    getRawType = SchemaUtils.getRawType,
	    hasID = SchemaUtils.hasID,
	    implementsInterface = SchemaUtils.implementsInterface,
	    isAbstractType = SchemaUtils.isAbstractType,
	    mayImplement = SchemaUtils.mayImplement;


	var ID = 'id';
	var ID_TYPE = 'ID';
	var NODE_TYPE = 'Node';

	/**
	 * A transform that adds an `id` field on any type that has an id field but
	 * where there is no unaliased `id` selection.
	 */
	function relayGenerateIDFieldTransform(context) {
	  var idType = assertLeafType(context.serverSchema.getType(ID_TYPE));
	  var idField = {
	    kind: 'ScalarField',
	    alias: null,
	    args: [],
	    directives: [],
	    handles: null,
	    metadata: null,
	    name: ID,
	    type: idType
	  };
	  var state = {
	    idField: idField
	  };
	  return IRTransformer.transform(context, {
	    LinkedField: visitLinkedField
	  }, function () {
	    return state;
	  });
	}

	function visitLinkedField(field, state) {
	  var transformedNode = this.traverse(field, state);

	  // If the field already has an unaliased `id` field, do nothing
	  if (hasUnaliasedSelection(field, ID)) {
	    return transformedNode;
	  }

	  var context = this.getContext();
	  var schema = context.serverSchema;
	  var unmodifiedType = assertCompositeType(getRawType(field.type));

	  // If the field type has an `id` subfield add an `id` selection
	  if (canHaveSelections(unmodifiedType) && hasID(schema, unmodifiedType)) {
	    return (0, _extends3['default'])({}, transformedNode, {
	      selections: [].concat((0, _toConsumableArray3['default'])(transformedNode.selections), [state.idField])
	    });
	  }

	  // If the field type is abstract, then generate a `... on Node { id }`
	  // fragment if *any* concrete type implements Node. Then generate a
	  // `... on PossibleType { id }` for every concrete type that does *not*
	  // implement `Node`
	  if (isAbstractType(unmodifiedType)) {
	    var selections = [].concat((0, _toConsumableArray3['default'])(transformedNode.selections));
	    if (mayImplement(schema, unmodifiedType, NODE_TYPE)) {
	      var nodeType = assertCompositeType(schema.getType(NODE_TYPE));
	      selections.push(buildIDFragment(nodeType, state.idField));
	    }
	    var abstractType = assertAbstractType(unmodifiedType);
	    schema.getPossibleTypes(abstractType).forEach(function (possibleType) {
	      if (!implementsInterface(possibleType, NODE_TYPE) && hasID(schema, possibleType)) {
	        selections.push(buildIDFragment(possibleType, state.idField));
	      }
	    });
	    return (0, _extends3['default'])({}, transformedNode, {
	      selections: selections
	    });
	  }

	  return transformedNode;
	}

	/**
	 * @internal
	 *
	 * Returns IR for `... on FRAGMENT_TYPE { id }`
	 */
	function buildIDFragment(fragmentType, idField) {
	  return {
	    kind: 'InlineFragment',
	    directives: [],
	    metadata: null,
	    typeCondition: fragmentType,
	    selections: [idField]
	  };
	}

	module.exports = {
	  transform: relayGenerateIDFieldTransform
	};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(3),
	    CompilerContext = _require.CompilerContext,
	    IRTransformer = _require.IRTransformer;

	/**
	 * A transform that removes field `handles`. Intended for use when e.g.
	 * printing queries to send to a GraphQL server.
	 */
	function relaySkipHandleFieldTransform(context) {
	  return IRTransformer.transform(context, {
	    LinkedField: visitField,
	    ScalarField: visitField
	  });
	}

	function visitField(field) {
	  var transformedNode = this.traverse(field);
	  if (transformedNode.handles) {
	    return (0, _extends3['default'])({}, transformedNode, {
	      handles: null
	    });
	  }
	  return transformedNode;
	}

	module.exports = {
	  transform: relaySkipHandleFieldTransform
	};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(18),
	    DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;

	var _require2 = __webpack_require__(6),
	    GraphQLObjectType = _require2.GraphQLObjectType;

	var _require3 = __webpack_require__(3),
	    IRTransformer = _require3.IRTransformer,
	    SchemaUtils = _require3.SchemaUtils;

	var getRawType = SchemaUtils.getRawType;


	var ID = 'id';
	var VIEWER_HANDLE = 'viewer';
	var VIEWER_TYPE = 'Viewer';

	/**
	 * A transform that adds a "viewer" handle to all fields whose type is `Viewer`.
	 */
	function relayViewerHandleTransform(context) {
	  var viewerType = context.serverSchema.getType(VIEWER_TYPE);
	  if (viewerType == null || !(viewerType instanceof GraphQLObjectType) || viewerType.getFields()[ID] != null) {
	    return context;
	  }
	  return IRTransformer.transform(context, {
	    LinkedField: visitLinkedField
	  });
	}

	function visitLinkedField(field) {
	  var transformedNode = this.traverse(field);
	  if (getRawType(field.type).name !== VIEWER_TYPE) {
	    return transformedNode;
	  }
	  var handles = transformedNode.handles;
	  var viewerHandle = {
	    name: VIEWER_HANDLE,
	    key: DEFAULT_HANDLE_KEY,
	    filters: null
	  };

	  if (handles && !handles.find(function (handle) {
	    return handle.name === VIEWER_HANDLE;
	  })) {
	    handles = [].concat((0, _toConsumableArray3['default'])(handles), [viewerHandle]);
	  } else if (!handles) {
	    handles = [viewerHandle];
	  }
	  return handles !== transformedNode.handles ? (0, _extends3['default'])({}, transformedNode, { handles: handles }) : transformedNode;
	}

	module.exports = {
	  transform: relayViewerHandleTransform
	};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(8));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(3),
	    Profiler = _require.Profiler;

	/**
	 * Transforms the provided compiler context
	 *
	 * compileRelayArtifacts generates artifacts for Relay's runtime as a result of
	 * applying a series of transforms. Each kind of artifact is dependent on
	 * transforms being applied in the following order:
	 *
	 *   - Fragment Readers: commonTransforms, fragmentTransforms
	 *   - Operation Writers: commonTransforms, queryTransforms, codegenTransforms
	 *   - GraphQL Text: commonTransforms, queryTransforms, printTransforms
	 *
	 * The order of the transforms applied for each artifact below is important.
	 * CompilerContext will memoize applying each transform, so while
	 * `commonTransforms` appears in each artifacts' application, it will not result
	 * in repeated work as long as the order remains consistent across each context.
	 */
	function compileRelayArtifacts(context, transforms, reporter) {
	  return Profiler.run('GraphQLCompiler.compile', function () {
	    // The fragment is used for reading data from the normalized store.
	    var fragmentContext = context.applyTransforms([].concat((0, _toConsumableArray3['default'])(transforms.commonTransforms), (0, _toConsumableArray3['default'])(transforms.fragmentTransforms)), reporter);

	    // The unflattened query is used for printing, since flattening creates an
	    // invalid query.
	    var printContext = context.applyTransforms([].concat((0, _toConsumableArray3['default'])(transforms.commonTransforms), (0, _toConsumableArray3['default'])(transforms.queryTransforms), (0, _toConsumableArray3['default'])(transforms.printTransforms)), reporter);

	    // The flattened query is used for codegen in order to reduce the number of
	    // duplicate fields that must be processed during response normalization.
	    var codeGenContext = context.applyTransforms([].concat((0, _toConsumableArray3['default'])(transforms.commonTransforms), (0, _toConsumableArray3['default'])(transforms.queryTransforms), (0, _toConsumableArray3['default'])(transforms.codegenTransforms)), reporter);

	    return fragmentContext.documents().map(function (node) {
	      return __webpack_require__(64).generate(node.kind === 'Fragment' ? node : {
	        kind: 'Batch',
	        metadata: codeGenContext.getRoot(node.name).metadata || {},
	        name: node.name,
	        fragment: {
	          kind: 'Fragment',
	          argumentDefinitions: node.argumentDefinitions,
	          directives: node.directives,
	          metadata: null,
	          name: node.name,
	          selections: node.selections,
	          type: node.type
	        },
	        requests: __webpack_require__(80)(printContext, codeGenContext, node.name)
	      });
	    });
	  });
	}

	module.exports = compileRelayArtifacts;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	/**
	 * This function works similar to JSON.stringify except that for the case there
	 * are multiple common subtrees, it generates a string for a IIFE that re-uses
	 * the same objects for the duplicate subtrees.
	 */

	function dedupeJSONStringify(jsonValue) {
	  var metadataForHash = new Map();
	  var metadataForVal = new WeakMap();
	  var varDefs = [];
	  collectMetadata(jsonValue);
	  collectDuplicates(jsonValue);
	  var code = printJSCode(false, '', jsonValue);
	  return varDefs.length === 0 ? code : '(function(){\nvar ' + varDefs.join(',\n') + ';\nreturn ' + code + ';\n})()';

	  // Collect common metadata for each object in the value tree, ensuring that
	  // equivalent values have the *same reference* to the same metadata. Note that
	  // the hashes generated are not exactly JSON, but still identify equivalent
	  // values. Runs in linear time due to hashing in a bottom-up recursion.
	  function collectMetadata(value) {
	    if (value == null || typeof value !== 'object') {
	      return JSON.stringify(value);
	    }
	    var hash = void 0;
	    if (Array.isArray(value)) {
	      hash = '[';
	      for (var i = 0; i < value.length; i++) {
	        hash += collectMetadata(value[i]) + ',';
	      }
	    } else {
	      hash = '{';
	      for (var k in value) {
	        if (value.hasOwnProperty(k) && value[k] !== undefined) {
	          hash += k + ':' + collectMetadata(value[k]) + ',';
	        }
	      }
	    }
	    var metadata = metadataForHash.get(hash);
	    if (!metadata) {
	      metadata = { value: value, hash: hash, isDuplicate: false };
	      metadataForHash.set(hash, metadata);
	    }
	    metadataForVal.set(value, metadata);
	    return hash;
	  }

	  // Using top-down recursion, linearly scan the JSON tree to determine which
	  // values should be deduplicated.
	  function collectDuplicates(value) {
	    if (value == null || typeof value !== 'object') {
	      return;
	    }
	    var metadata = metadataForVal.get(value);
	    // Only consider duplicates with hashes longer than 2 (excludes [] and {}).
	    if (metadata && metadata.value !== value && metadata.hash.length > 2) {
	      metadata.isDuplicate = true;
	      return;
	    }
	    if (Array.isArray(value)) {
	      for (var i = 0; i < value.length; i++) {
	        collectDuplicates(value[i]);
	      }
	    } else {
	      for (var k in value) {
	        if (value.hasOwnProperty(k) && value[k] !== undefined) {
	          collectDuplicates(value[k]);
	        }
	      }
	    }
	  }

	  // Stringify JS, replacing duplicates with variable references.
	  function printJSCode(isDupedVar, depth, value) {
	    if (value == null || typeof value !== 'object') {
	      return JSON.stringify(value);
	    }
	    // Only use variable references at depth beyond the top level.
	    if (depth !== '') {
	      var metadata = metadataForVal.get(value);
	      if (metadata && metadata.isDuplicate) {
	        if (!metadata.varName) {
	          var refCode = printJSCode(true, '', value);
	          metadata.varName = 'v' + varDefs.length;
	          varDefs.push(metadata.varName + ' = ' + refCode);
	        }
	        return metadata.varName;
	      }
	    }
	    var str = void 0;
	    var isEmpty = true;
	    var depth2 = depth + '  ';
	    if (Array.isArray(value)) {
	      // Empty arrays can only have one inferred flow type and then conflict if
	      // used in different places, this is unsound if we would write to them but
	      // this whole module is based on the idea of a read only JSON tree.
	      if (isDupedVar && value.length === 0) {
	        return '([]/*: any*/)';
	      }
	      str = '[';
	      for (var i = 0; i < value.length; i++) {
	        str += (isEmpty ? '\n' : ',\n') + depth2 + printJSCode(isDupedVar, depth2, value[i]);
	        isEmpty = false;
	      }
	      str += isEmpty ? ']' : '\n' + depth + ']';
	    } else {
	      str = '{';
	      for (var k in value) {
	        if (value.hasOwnProperty(k) && value[k] !== undefined) {
	          str += (isEmpty ? '\n' : ',\n') + depth2 + JSON.stringify(k) + ': ' + printJSCode(isDupedVar, depth2, value[k]);
	          isEmpty = false;
	        }
	      }
	      str += isEmpty ? '}' : '\n' + depth + '}';
	    }
	    return str;
	  }
	}

	module.exports = dedupeJSONStringify;

/***/ }),
/* 76 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	/**
	 * Given a object of nested properties, return JavaScript text that would merge
	 * in an object named `objectName` by a series of individual assignments.
	 */

	function deepMergeAssignments(objectName, properties) {
	  var assignments = [];
	  collectAssignmentsInto(assignments, [], properties);
	  var jsAssignments = assignments.map(function (_ref) {
	    var path = _ref.path,
	        value = _ref.value;
	    return formatJSAssignment(objectName, path, value);
	  });
	  return jsAssignments.length === 0 ? '' : jsAssignments.join('\n');
	}

	// Recursively collect assignments
	function collectAssignmentsInto(assignments, parentPath, parentValue) {
	  // Iterate over the entries in the array or object.
	  forEach(parentValue, function (value, key) {
	    // The "path" is the sequence of keys to arrive at this assignment.
	    var path = parentPath.concat(key);
	    // For each entry, either add an assignment or recurse.
	    if (typeof value === 'object' && value !== null) {
	      collectAssignmentsInto(assignments, path, value);
	    } else {
	      assignments.push({ path: path, value: value });
	    }
	  });
	}

	// Print a path/value pair as a JS assignment expression.
	function formatJSAssignment(objectName, path, value) {
	  var assignmentPath = path.map(function (p) {
	    return typeof p === 'string' ? '.' + p : '[' + p + ']';
	  }).join('');
	  var jsValue = value === undefined ? 'undefined' : JSON.stringify(value);
	  return '' + objectName + assignmentPath + ' = ' + jsValue + ';';
	}

	// Utility for looping over entries in both Arrays and Objects.
	function forEach(value, fn) {
	  if (Array.isArray(value)) {
	    for (var i = 0; i < value.length; i++) {
	      fn(value[i], i);
	    }
	  } else {
	    for (var k in value) {
	      if (value.hasOwnProperty(k)) {
	        fn(value[k], k);
	      }
	    }
	  }
	}

	module.exports = deepMergeAssignments;

/***/ }),
/* 77 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var formatGeneratedModule = function formatGeneratedModule(_ref) {
	  var moduleName = _ref.moduleName,
	      documentType = _ref.documentType,
	      docText = _ref.docText,
	      concreteText = _ref.concreteText,
	      flowText = _ref.flowText,
	      hash = _ref.hash,
	      relayRuntimeModule = _ref.relayRuntimeModule,
	      sourceHash = _ref.sourceHash;

	  var docTextComment = docText ? '\n/*\n' + docText.trim() + '\n*/\n' : '';
	  var hashText = hash ? '\n * ' + hash : '';
	  return '/**\n * ' + '@' + 'flow' + hashText + '\n */\n\n/* eslint-disable */\n\n\'use strict\';\n\n/*::\nimport type { ' + documentType + ' } from \'' + relayRuntimeModule + '\';\n' + (flowText || '') + '\n*/\n\n' + docTextComment + '\nconst node/*: ' + documentType + '*/ = ' + concreteText + ';\n// prettier-ignore\n(node/*: any*/).hash = \'' + sourceHash + '\';\nmodule.exports = node;\n';
	};

	module.exports = formatGeneratedModule;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	function getModuleName(filePath) {
	  // index.js -> index
	  // index.js.flow -> index.js
	  var filename = __webpack_require__(4).basename(filePath, __webpack_require__(4).extname(filePath));

	  // index.js -> index (when extension has multiple segments)
	  filename = filename.replace(/(?:\.\w+)+/, '');

	  // /path/to/button/index.js -> button
	  var moduleName = filename === 'index' ? __webpack_require__(4).basename(__webpack_require__(4).dirname(filePath)) : filename;

	  // Example.ios -> Example
	  // Example.product.android -> Example
	  moduleName = moduleName.replace(/(?:\.\w+)+/, '');

	  // foo-bar -> fooBar
	  // Relay compatibility mode splits on _, so we can't use that here.
	  moduleName = moduleName.replace(/[^a-zA-Z0-9]+(\w?)/g, function (match, next) {
	    return next.toUpperCase();
	  });

	  return moduleName;
	}

	module.exports = getModuleName;

/***/ }),
/* 79 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * Based on implementations by Gary Court and Austin Appleby, 2011, MIT.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var BASE62 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

	/**
	 * @param {string} key A UTF-16 or ASCII string
	 * @return {string} a base62 murmur hash
	 */
	function murmurHash(str) {
	  /* eslint-disable no-bitwise */
	  var length = str.length;
	  var rem = length & 3;
	  var len = length ^ rem;

	  var h = 0;
	  var i = 0;
	  var k = void 0;

	  while (i !== len) {
	    var ch4 = str.charCodeAt(i + 3);

	    k = str.charCodeAt(i) ^ str.charCodeAt(i + 1) << 8 ^ str.charCodeAt(i + 2) << 16 ^ (ch4 & 0xff) << 24 ^ (ch4 & 0xff00) >> 8;

	    i += 4;

	    k = k * 0x2d51 + (k & 0xffff) * 0xcc9e0000 >>> 0;
	    k = k << 15 | k >>> 17;
	    k = k * 0x3593 + (k & 0xffff) * 0x1b870000 >>> 0;
	    h ^= k;
	    h = h << 13 | h >>> 19;
	    h = h * 5 + 0xe6546b64 >>> 0;
	  }

	  k = 0;
	  switch (rem) {
	    /* eslint-disable no-fallthrough */
	    case 3:
	      k ^= str.charCodeAt(len + 2) << 16;
	    case 2:
	      k ^= str.charCodeAt(len + 1) << 8;
	    case 1:
	      k ^= str.charCodeAt(len);

	      k = k * 0x2d51 + (k & 0xffff) * 0xcc9e0000 >>> 0;
	      k = k << 15 | k >>> 17;
	      k = k * 0x3593 + (k & 0xffff) * 0x1b870000 >>> 0;
	      h ^= k;
	  }

	  h ^= length;
	  h ^= h >>> 16;
	  h = h * 0xca6b + (h & 0xffff) * 0x85eb0000 >>> 0;
	  h ^= h >>> 13;
	  h = h * 0xae35 + (h & 0xffff) * 0xc2b20000 >>> 0;
	  h ^= h >>> 16;

	  h >>>= 0;

	  if (!h) {
	    return '0';
	  }

	  var s = '';
	  while (h) {
	    var d = h % 62;
	    s = BASE62[d] + s;
	    h = (h - d) / 62;
	  }
	  return s;
	}

	module.exports = murmurHash;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(3),
	    filterContextForNode = _require.filterContextForNode,
	    Printer = _require.Printer;

	function requestsForOperation(printContext, codeGenContext, initialRootName) {
	  var operationToRequestName = new Map();
	  return requestsInto([], {
	    operationName: initialRootName,
	    argumentDependencies: []
	  });
	  function requestsInto(requests, dependent) {
	    var name = dependent.operationName;
	    // Create a unique name for this request.
	    var num = 0;
	    var requestName = void 0;
	    do {
	      requestName = name + (++num > 1 ? num : '');
	    } while (requests.some(function (request) {
	      return request.name === requestName;
	    }));
	    operationToRequestName.set(name, requestName);
	    // Collect the dependent arguments for this request.
	    var codeGenRoot = codeGenContext.getRoot(name);
	    var argumentDependencies = dependent.argumentDependencies;
	    var dependentRequests = codeGenRoot.dependentRequests;
	    var rerunDependency = dependentRequests.find(function (next) {
	      return next.operationName === dependent.operationName;
	    });
	    if (rerunDependency) {
	      dependentRequests = dependentRequests.filter(function (next) {
	        return next !== rerunDependency;
	      });
	      argumentDependencies = argumentDependencies.concat(rerunDependency.argumentDependencies);
	    }
	    // Create a request for this operation.
	    requests.push({
	      kind: 'Request',
	      name: requestName,
	      id: null,
	      text: printOperation(printContext, name),
	      argumentDependencies: argumentDependencies.map(function (argDep) {
	        return (0, _extends3['default'])({}, argDep, {
	          fromName: operationToRequestName.get(argDep.fromName)
	        });
	      }),
	      root: codeGenRoot,
	      /* $FlowFixMe(>=0.68.0 site=react_native_fb,react_native_oss) This comment
	       * suppresses an error found when Flow v0.68 was deployed. To see the
	       * error delete this comment and run Flow. */
	      metadata: dependent.metadata || undefined
	    });
	    // Collect any requests that were dependent on this one as well.
	    return dependentRequests.reduce(requestsInto, requests);
	  }
	}

	function printOperation(printContext, name) {
	  var printableRoot = printContext.getRoot(name);
	  return filterContextForNode(printableRoot, printContext).documents().map(Printer.print).join('\n');
	}

	module.exports = requestsForOperation;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _asyncToGenerator2 = __webpack_require__(28);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	let writeRelayGeneratedFile = (() => {
	  var _ref = (0, _asyncToGenerator3.default)(function* (codegenDir, generatedNode, formatModule, flowText, _persistQuery, platform, relayRuntimeModule, sourceHash) {
	    // Copy to const so Flow can refine.
	    var persistQuery = _persistQuery;
	    var moduleName = generatedNode.name + '.graphql';
	    var platformName = platform ? moduleName + '.' + platform : moduleName;
	    var filename = platformName + '.js';
	    var flowTypeName = generatedNode.kind === RelayConcreteNode.FRAGMENT ? 'ConcreteFragment' : generatedNode.kind === RelayConcreteNode.REQUEST ? 'ConcreteRequest' : generatedNode.kind === RelayConcreteNode.BATCH_REQUEST ? 'ConcreteBatchRequest' : 'empty';
	    var devOnlyProperties = {};

	    var docText = void 0;
	    if (generatedNode.kind === RelayConcreteNode.REQUEST) {
	      docText = generatedNode.text;
	    } else if (generatedNode.kind === RelayConcreteNode.BATCH_REQUEST) {
	      docText = generatedNode.requests.map(function (request) {
	        return request.text;
	      }).join('\n\n');
	    }

	    var hash = null;
	    if (generatedNode.kind === RelayConcreteNode.REQUEST || generatedNode.kind === RelayConcreteNode.BATCH_REQUEST) {
	      var oldHash = Profiler.run('RelayFileWriter:compareHash', function () {
	        var oldContent = codegenDir.read(filename);
	        // Hash the concrete node including the query text.
	        var hasher = __webpack_require__(30).createHash('md5');
	        hasher.update('cache-breaker-7');
	        hasher.update(JSON.stringify(generatedNode));
	        hasher.update(sourceHash);
	        if (flowText) {
	          hasher.update(flowText);
	        }
	        if (persistQuery) {
	          hasher.update('persisted');
	        }
	        hash = hasher.digest('hex');
	        return extractHash(oldContent);
	      });
	      if (hash === oldHash) {
	        codegenDir.markUnchanged(filename);
	        return null;
	      }
	      if (codegenDir.onlyValidate) {
	        codegenDir.markUpdated(filename);
	        return null;
	      }
	      if (persistQuery) {
	        switch (generatedNode.kind) {
	          case RelayConcreteNode.REQUEST:
	            devOnlyProperties.text = generatedNode.text;
	            generatedNode = (0, _extends3['default'])({}, generatedNode, {
	              text: null,
	              id: yield persistQuery(__webpack_require__(15)(generatedNode.text))
	            });
	            break;
	          case RelayConcreteNode.BATCH_REQUEST:
	            devOnlyProperties.requests = generatedNode.requests.map(function (request) {
	              return {
	                text: request.text
	              };
	            });
	            generatedNode = (0, _extends3['default'])({}, generatedNode, {
	              requests: yield Promise.all(generatedNode.requests.map((() => {
	                var _ref2 = (0, _asyncToGenerator3.default)(function* (request) {
	                  return (0, _extends3['default'])({}, request, {
	                    text: null,
	                    id: yield persistQuery(__webpack_require__(15)(request.text))
	                  });
	                });

	                return function (_x9) {
	                  return _ref2.apply(this, arguments);
	                };
	              })()))
	            });
	            break;
	          case RelayConcreteNode.FRAGMENT:
	            // Do not persist fragments.
	            break;
	          default:
	            generatedNode.kind;
	        }
	      }
	    }

	    var devOnlyAssignments = __webpack_require__(76)('node', devOnlyProperties);

	    var moduleText = formatModule({
	      moduleName: moduleName,
	      documentType: flowTypeName,
	      docText: docText,
	      flowText: flowText,
	      hash: hash ? '@relayHash ' + hash : null,
	      concreteText: __webpack_require__(75)(generatedNode),
	      devOnlyAssignments: devOnlyAssignments,
	      relayRuntimeModule: relayRuntimeModule,
	      sourceHash: sourceHash
	    });

	    codegenDir.writeFile(filename, moduleText);
	    return generatedNode;
	  });

	  return function writeRelayGeneratedFile(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {
	    return _ref.apply(this, arguments);
	  };
	})();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(18),
	    RelayConcreteNode = _require.RelayConcreteNode;

	var _require2 = __webpack_require__(3),
	    Profiler = _require2.Profiler;

	/**
	 * Generate a module for the given document name/text.
	 */


	function extractHash(text) {
	  if (!text) {
	    return null;
	  }
	  if (/<<<<<|>>>>>/.test(text)) {
	    // looks like a merge conflict
	    return null;
	  }
	  var match = text.match(/@relayHash (\w{32})\b/m);
	  return match && match[1];
	}

	module.exports = writeRelayGeneratedFile;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = void 0;

	var _trimRight = _interopRequireDefault(__webpack_require__(157));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var SPACES_RE = /^[ \t]+$/;

	var Buffer = function () {
	  function Buffer(map) {
	    this._map = null;
	    this._buf = [];
	    this._last = "";
	    this._queue = [];
	    this._position = {
	      line: 1,
	      column: 0
	    };
	    this._sourcePosition = {
	      identifierName: null,
	      line: null,
	      column: null,
	      filename: null
	    };
	    this._map = map;
	  }

	  var _proto = Buffer.prototype;

	  _proto.get = function get() {
	    this._flush();

	    var map = this._map;
	    var result = {
	      code: (0, _trimRight.default)(this._buf.join("")),
	      map: null,
	      rawMappings: map && map.getRawMappings()
	    };

	    if (map) {
	      Object.defineProperty(result, "map", {
	        configurable: true,
	        enumerable: true,
	        get: function get() {
	          return this.map = map.get();
	        },
	        set: function set(value) {
	          Object.defineProperty(this, "map", {
	            value: value,
	            writable: true
	          });
	        }
	      });
	    }

	    return result;
	  };

	  _proto.append = function append(str) {
	    this._flush();

	    var _sourcePosition = this._sourcePosition,
	        line = _sourcePosition.line,
	        column = _sourcePosition.column,
	        filename = _sourcePosition.filename,
	        identifierName = _sourcePosition.identifierName;

	    this._append(str, line, column, identifierName, filename);
	  };

	  _proto.queue = function queue(str) {
	    if (str === "\n") {
	      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
	        this._queue.shift();
	      }
	    }

	    var _sourcePosition2 = this._sourcePosition,
	        line = _sourcePosition2.line,
	        column = _sourcePosition2.column,
	        filename = _sourcePosition2.filename,
	        identifierName = _sourcePosition2.identifierName;

	    this._queue.unshift([str, line, column, identifierName, filename]);
	  };

	  _proto._flush = function _flush() {
	    var item;

	    while (item = this._queue.pop()) {
	      this._append.apply(this, item);
	    }
	  };

	  _proto._append = function _append(str, line, column, identifierName, filename) {
	    if (this._map && str[0] !== "\n") {
	      this._map.mark(this._position.line, this._position.column, line, column, identifierName, filename);
	    }

	    this._buf.push(str);

	    this._last = str[str.length - 1];

	    for (var i = 0; i < str.length; i++) {
	      if (str[i] === "\n") {
	        this._position.line++;
	        this._position.column = 0;
	      } else {
	        this._position.column++;
	      }
	    }
	  };

	  _proto.removeTrailingNewline = function removeTrailingNewline() {
	    if (this._queue.length > 0 && this._queue[0][0] === "\n") {
	      this._queue.shift();
	    }
	  };

	  _proto.removeLastSemicolon = function removeLastSemicolon() {
	    if (this._queue.length > 0 && this._queue[0][0] === ";") {
	      this._queue.shift();
	    }
	  };

	  _proto.endsWith = function endsWith(suffix) {
	    if (suffix.length === 1) {
	      var last;

	      if (this._queue.length > 0) {
	        var str = this._queue[0][0];
	        last = str[str.length - 1];
	      } else {
	        last = this._last;
	      }

	      return last === suffix;
	    }

	    var end = this._last + this._queue.reduce(function (acc, item) {
	      return item[0] + acc;
	    }, "");

	    if (suffix.length <= end.length) {
	      return end.slice(-suffix.length) === suffix;
	    }

	    return false;
	  };

	  _proto.hasContent = function hasContent() {
	    return this._queue.length > 0 || !!this._last;
	  };

	  _proto.source = function source(prop, loc) {
	    if (prop && !loc) return;
	    var pos = loc ? loc[prop] : null;
	    this._sourcePosition.identifierName = loc && loc.identifierName || null;
	    this._sourcePosition.line = pos ? pos.line : null;
	    this._sourcePosition.column = pos ? pos.column : null;
	    this._sourcePosition.filename = loc && loc.filename || null;
	  };

	  _proto.withSource = function withSource(prop, loc, cb) {
	    if (!this._map) return cb();
	    var originalLine = this._sourcePosition.line;
	    var originalColumn = this._sourcePosition.column;
	    var originalFilename = this._sourcePosition.filename;
	    var originalIdentifierName = this._sourcePosition.identifierName;
	    this.source(prop, loc);
	    cb();
	    this._sourcePosition.line = originalLine;
	    this._sourcePosition.column = originalColumn;
	    this._sourcePosition.filename = originalFilename;
	    this._sourcePosition.identifierName = originalIdentifierName;
	  };

	  _proto.getCurrentColumn = function getCurrentColumn() {
	    var extra = this._queue.reduce(function (acc, item) {
	      return item[0] + acc;
	    }, "");

	    var lastIndex = extra.lastIndexOf("\n");
	    return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
	  };

	  _proto.getCurrentLine = function getCurrentLine() {
	    var extra = this._queue.reduce(function (acc, item) {
	      return item[0] + acc;
	    }, "");

	    var count = 0;

	    for (var i = 0; i < extra.length; i++) {
	      if (extra[i] === "\n") count++;
	    }

	    return this._position.line + count;
	  };

	  return Buffer;
	}();

	exports.default = Buffer;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.File = File;
	exports.Program = Program;
	exports.BlockStatement = BlockStatement;
	exports.Noop = Noop;
	exports.Directive = Directive;
	exports.DirectiveLiteral = void 0;

	var _types = __webpack_require__(23);

	exports.DirectiveLiteral = _types.StringLiteral;

	function File(node) {
	  this.print(node.program, node);
	}

	function Program(node) {
	  this.printInnerComments(node, false);
	  this.printSequence(node.directives, node);
	  if (node.directives && node.directives.length) this.newline();
	  this.printSequence(node.body, node);
	}

	function BlockStatement(node) {
	  this.token("{");
	  this.printInnerComments(node);
	  var hasDirectives = node.directives && node.directives.length;

	  if (node.body.length || hasDirectives) {
	    this.newline();
	    this.printSequence(node.directives, node, {
	      indent: true
	    });
	    if (hasDirectives) this.newline();
	    this.printSequence(node.body, node, {
	      indent: true
	    });
	    this.removeTrailingNewline();
	    this.source("end", node.loc);
	    if (!this.endsWith("\n")) this.newline();
	    this.rightBrace();
	  } else {
	    this.source("end", node.loc);
	    this.token("}");
	  }
	}

	function Noop() {}

	function Directive(node) {
	  this.print(node.value, node);
	  this.semicolon();
	}

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
	exports.ClassBody = ClassBody;
	exports.ClassProperty = ClassProperty;
	exports.ClassMethod = ClassMethod;
	exports._classMethodHead = _classMethodHead;

	var t = _interopRequireWildcard(__webpack_require__(1));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function ClassDeclaration(node, parent) {
	  if (!t.isExportDefaultDeclaration(parent) && !t.isExportNamedDeclaration(parent)) {
	    this.printJoin(node.decorators, node);
	  }

	  if (node.declare) {
	    this.word("declare");
	    this.space();
	  }

	  if (node.abstract) {
	    this.word("abstract");
	    this.space();
	  }

	  this.word("class");

	  if (node.id) {
	    this.space();
	    this.print(node.id, node);
	  }

	  this.print(node.typeParameters, node);

	  if (node.superClass) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.print(node.superClass, node);
	    this.print(node.superTypeParameters, node);
	  }

	  if (node.implements) {
	    this.space();
	    this.word("implements");
	    this.space();
	    this.printList(node.implements, node);
	  }

	  this.space();
	  this.print(node.body, node);
	}

	function ClassBody(node) {
	  this.token("{");
	  this.printInnerComments(node);

	  if (node.body.length === 0) {
	    this.token("}");
	  } else {
	    this.newline();
	    this.indent();
	    this.printSequence(node.body, node);
	    this.dedent();
	    if (!this.endsWith("\n")) this.newline();
	    this.rightBrace();
	  }
	}

	function ClassProperty(node) {
	  this.printJoin(node.decorators, node);

	  if (node.accessibility) {
	    this.word(node.accessibility);
	    this.space();
	  }

	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  if (node.abstract) {
	    this.word("abstract");
	    this.space();
	  }

	  if (node.readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  if (node.computed) {
	    this.token("[");
	    this.print(node.key, node);
	    this.token("]");
	  } else {
	    this._variance(node);

	    this.print(node.key, node);
	  }

	  if (node.optional) {
	    this.token("?");
	  }

	  this.print(node.typeAnnotation, node);

	  if (node.value) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.value, node);
	  }

	  this.semicolon();
	}

	function ClassMethod(node) {
	  this._classMethodHead(node);

	  this.space();
	  this.print(node.body, node);
	}

	function _classMethodHead(node) {
	  this.printJoin(node.decorators, node);

	  if (node.accessibility) {
	    this.word(node.accessibility);
	    this.space();
	  }

	  if (node.abstract) {
	    this.word("abstract");
	    this.space();
	  }

	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  this._methodHead(node);
	}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.UnaryExpression = UnaryExpression;
	exports.DoExpression = DoExpression;
	exports.ParenthesizedExpression = ParenthesizedExpression;
	exports.UpdateExpression = UpdateExpression;
	exports.ConditionalExpression = ConditionalExpression;
	exports.NewExpression = NewExpression;
	exports.SequenceExpression = SequenceExpression;
	exports.ThisExpression = ThisExpression;
	exports.Super = Super;
	exports.Decorator = Decorator;
	exports.OptionalMemberExpression = OptionalMemberExpression;
	exports.OptionalCallExpression = OptionalCallExpression;
	exports.CallExpression = CallExpression;
	exports.Import = Import;
	exports.EmptyStatement = EmptyStatement;
	exports.ExpressionStatement = ExpressionStatement;
	exports.AssignmentPattern = AssignmentPattern;
	exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
	exports.BindExpression = BindExpression;
	exports.MemberExpression = MemberExpression;
	exports.MetaProperty = MetaProperty;
	exports.AwaitExpression = exports.YieldExpression = void 0;

	var t = _interopRequireWildcard(__webpack_require__(1));

	var n = _interopRequireWildcard(__webpack_require__(41));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function UnaryExpression(node) {
	  if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof") {
	    this.word(node.operator);
	    this.space();
	  } else {
	    this.token(node.operator);
	  }

	  this.print(node.argument, node);
	}

	function DoExpression(node) {
	  this.word("do");
	  this.space();
	  this.print(node.body, node);
	}

	function ParenthesizedExpression(node) {
	  this.token("(");
	  this.print(node.expression, node);
	  this.token(")");
	}

	function UpdateExpression(node) {
	  if (node.prefix) {
	    this.token(node.operator);
	    this.print(node.argument, node);
	  } else {
	    this.startTerminatorless(true);
	    this.print(node.argument, node);
	    this.endTerminatorless();
	    this.token(node.operator);
	  }
	}

	function ConditionalExpression(node) {
	  this.print(node.test, node);
	  this.space();
	  this.token("?");
	  this.space();
	  this.print(node.consequent, node);
	  this.space();
	  this.token(":");
	  this.space();
	  this.print(node.alternate, node);
	}

	function NewExpression(node, parent) {
	  this.word("new");
	  this.space();
	  this.print(node.callee, node);

	  if (this.format.minified && node.arguments.length === 0 && !node.optional && !t.isCallExpression(parent, {
	    callee: node
	  }) && !t.isMemberExpression(parent) && !t.isNewExpression(parent)) {
	    return;
	  }

	  this.print(node.typeParameters, node);

	  if (node.optional) {
	    this.token("?.");
	  }

	  this.token("(");
	  this.printList(node.arguments, node);
	  this.token(")");
	}

	function SequenceExpression(node) {
	  this.printList(node.expressions, node);
	}

	function ThisExpression() {
	  this.word("this");
	}

	function Super() {
	  this.word("super");
	}

	function Decorator(node) {
	  this.token("@");
	  this.print(node.expression, node);
	  this.newline();
	}

	function OptionalMemberExpression(node) {
	  this.print(node.object, node);

	  if (!node.computed && t.isMemberExpression(node.property)) {
	    throw new TypeError("Got a MemberExpression for MemberExpression property");
	  }

	  var computed = node.computed;

	  if (t.isLiteral(node.property) && typeof node.property.value === "number") {
	    computed = true;
	  }

	  if (node.optional) {
	    this.token("?.");
	  }

	  if (computed) {
	    this.token("[");
	    this.print(node.property, node);
	    this.token("]");
	  } else {
	    if (!node.optional) {
	      this.token(".");
	    }

	    this.print(node.property, node);
	  }
	}

	function OptionalCallExpression(node) {
	  this.print(node.callee, node);
	  this.print(node.typeParameters, node);

	  if (node.optional) {
	    this.token("?.");
	  }

	  this.token("(");
	  this.printList(node.arguments, node);
	  this.token(")");
	}

	function CallExpression(node) {
	  this.print(node.callee, node);
	  this.print(node.typeParameters, node);
	  this.token("(");
	  this.printList(node.arguments, node);
	  this.token(")");
	}

	function Import() {
	  this.word("import");
	}

	function buildYieldAwait(keyword) {
	  return function (node) {
	    this.word(keyword);

	    if (node.delegate) {
	      this.token("*");
	    }

	    if (node.argument) {
	      this.space();
	      var terminatorState = this.startTerminatorless();
	      this.print(node.argument, node);
	      this.endTerminatorless(terminatorState);
	    }
	  };
	}

	var YieldExpression = buildYieldAwait("yield");
	exports.YieldExpression = YieldExpression;
	var AwaitExpression = buildYieldAwait("await");
	exports.AwaitExpression = AwaitExpression;

	function EmptyStatement() {
	  this.semicolon(true);
	}

	function ExpressionStatement(node) {
	  this.print(node.expression, node);
	  this.semicolon();
	}

	function AssignmentPattern(node) {
	  this.print(node.left, node);
	  if (node.left.optional) this.token("?");
	  this.print(node.left.typeAnnotation, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(node.right, node);
	}

	function AssignmentExpression(node, parent) {
	  var parens = this.inForStatementInitCounter && node.operator === "in" && !n.needsParens(node, parent);

	  if (parens) {
	    this.token("(");
	  }

	  this.print(node.left, node);
	  this.space();

	  if (node.operator === "in" || node.operator === "instanceof") {
	    this.word(node.operator);
	  } else {
	    this.token(node.operator);
	  }

	  this.space();
	  this.print(node.right, node);

	  if (parens) {
	    this.token(")");
	  }
	}

	function BindExpression(node) {
	  this.print(node.object, node);
	  this.token("::");
	  this.print(node.callee, node);
	}

	function MemberExpression(node) {
	  this.print(node.object, node);

	  if (!node.computed && t.isMemberExpression(node.property)) {
	    throw new TypeError("Got a MemberExpression for MemberExpression property");
	  }

	  var computed = node.computed;

	  if (t.isLiteral(node.property) && typeof node.property.value === "number") {
	    computed = true;
	  }

	  if (computed) {
	    this.token("[");
	    this.print(node.property, node);
	    this.token("]");
	  } else {
	    this.token(".");
	    this.print(node.property, node);
	  }
	}

	function MetaProperty(node) {
	  this.print(node.meta, node);
	  this.token(".");
	  this.print(node.property, node);
	}

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.AnyTypeAnnotation = AnyTypeAnnotation;
	exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
	exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
	exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
	exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
	exports.DeclareClass = DeclareClass;
	exports.DeclareFunction = DeclareFunction;
	exports.InferredPredicate = InferredPredicate;
	exports.DeclaredPredicate = DeclaredPredicate;
	exports.DeclareInterface = DeclareInterface;
	exports.DeclareModule = DeclareModule;
	exports.DeclareModuleExports = DeclareModuleExports;
	exports.DeclareTypeAlias = DeclareTypeAlias;
	exports.DeclareOpaqueType = DeclareOpaqueType;
	exports.DeclareVariable = DeclareVariable;
	exports.DeclareExportDeclaration = DeclareExportDeclaration;
	exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
	exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
	exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
	exports.FunctionTypeParam = FunctionTypeParam;
	exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
	exports._interfaceish = _interfaceish;
	exports._variance = _variance;
	exports.InterfaceDeclaration = InterfaceDeclaration;
	exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
	exports.MixedTypeAnnotation = MixedTypeAnnotation;
	exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
	exports.NullableTypeAnnotation = NullableTypeAnnotation;
	exports.NumberTypeAnnotation = NumberTypeAnnotation;
	exports.StringTypeAnnotation = StringTypeAnnotation;
	exports.ThisTypeAnnotation = ThisTypeAnnotation;
	exports.TupleTypeAnnotation = TupleTypeAnnotation;
	exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
	exports.TypeAlias = TypeAlias;
	exports.TypeAnnotation = TypeAnnotation;
	exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
	exports.TypeParameter = TypeParameter;
	exports.OpaqueType = OpaqueType;
	exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
	exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
	exports.ObjectTypeIndexer = ObjectTypeIndexer;
	exports.ObjectTypeProperty = ObjectTypeProperty;
	exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
	exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
	exports.UnionTypeAnnotation = UnionTypeAnnotation;
	exports.TypeCastExpression = TypeCastExpression;
	exports.Variance = Variance;
	exports.VoidTypeAnnotation = VoidTypeAnnotation;
	exports.StringLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = void 0;

	var t = _interopRequireWildcard(__webpack_require__(1));

	var _modules = __webpack_require__(40);

	var _types2 = __webpack_require__(23);

	exports.NumberLiteralTypeAnnotation = _types2.NumericLiteral;
	exports.StringLiteralTypeAnnotation = _types2.StringLiteral;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function AnyTypeAnnotation() {
	  this.word("any");
	}

	function ArrayTypeAnnotation(node) {
	  this.print(node.elementType, node);
	  this.token("[");
	  this.token("]");
	}

	function BooleanTypeAnnotation() {
	  this.word("boolean");
	}

	function BooleanLiteralTypeAnnotation(node) {
	  this.word(node.value ? "true" : "false");
	}

	function NullLiteralTypeAnnotation() {
	  this.word("null");
	}

	function DeclareClass(node, parent) {
	  if (!t.isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("class");
	  this.space();

	  this._interfaceish(node);
	}

	function DeclareFunction(node, parent) {
	  if (!t.isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("function");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.id.typeAnnotation.typeAnnotation, node);

	  if (node.predicate) {
	    this.space();
	    this.print(node.predicate, node);
	  }

	  this.semicolon();
	}

	function InferredPredicate() {
	  this.token("%");
	  this.word("checks");
	}

	function DeclaredPredicate(node) {
	  this.token("%");
	  this.word("checks");
	  this.token("(");
	  this.print(node.value, node);
	  this.token(")");
	}

	function DeclareInterface(node) {
	  this.word("declare");
	  this.space();
	  this.InterfaceDeclaration(node);
	}

	function DeclareModule(node) {
	  this.word("declare");
	  this.space();
	  this.word("module");
	  this.space();
	  this.print(node.id, node);
	  this.space();
	  this.print(node.body, node);
	}

	function DeclareModuleExports(node) {
	  this.word("declare");
	  this.space();
	  this.word("module");
	  this.token(".");
	  this.word("exports");
	  this.print(node.typeAnnotation, node);
	}

	function DeclareTypeAlias(node) {
	  this.word("declare");
	  this.space();
	  this.TypeAlias(node);
	}

	function DeclareOpaqueType(node, parent) {
	  if (!t.isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.OpaqueType(node);
	}

	function DeclareVariable(node, parent) {
	  if (!t.isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("var");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.id.typeAnnotation, node);
	  this.semicolon();
	}

	function DeclareExportDeclaration(node) {
	  this.word("declare");
	  this.space();
	  this.word("export");
	  this.space();

	  if (node.default) {
	    this.word("default");
	    this.space();
	  }

	  FlowExportDeclaration.apply(this, arguments);
	}

	function DeclareExportAllDeclaration() {
	  this.word("declare");
	  this.space();

	  _modules.ExportAllDeclaration.apply(this, arguments);
	}

	function FlowExportDeclaration(node) {
	  if (node.declaration) {
	    var declar = node.declaration;
	    this.print(declar, node);
	    if (!t.isStatement(declar)) this.semicolon();
	  } else {
	    this.token("{");

	    if (node.specifiers.length) {
	      this.space();
	      this.printList(node.specifiers, node);
	      this.space();
	    }

	    this.token("}");

	    if (node.source) {
	      this.space();
	      this.word("from");
	      this.space();
	      this.print(node.source, node);
	    }

	    this.semicolon();
	  }
	}

	function ExistsTypeAnnotation() {
	  this.token("*");
	}

	function FunctionTypeAnnotation(node, parent) {
	  this.print(node.typeParameters, node);
	  this.token("(");
	  this.printList(node.params, node);

	  if (node.rest) {
	    if (node.params.length) {
	      this.token(",");
	      this.space();
	    }

	    this.token("...");
	    this.print(node.rest, node);
	  }

	  this.token(")");

	  if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) {
	    this.token(":");
	  } else {
	    this.space();
	    this.token("=>");
	  }

	  this.space();
	  this.print(node.returnType, node);
	}

	function FunctionTypeParam(node) {
	  this.print(node.name, node);
	  if (node.optional) this.token("?");
	  this.token(":");
	  this.space();
	  this.print(node.typeAnnotation, node);
	}

	function InterfaceExtends(node) {
	  this.print(node.id, node);
	  this.print(node.typeParameters, node);
	}

	function _interfaceish(node) {
	  this.print(node.id, node);
	  this.print(node.typeParameters, node);

	  if (node.extends.length) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.printList(node.extends, node);
	  }

	  if (node.mixins && node.mixins.length) {
	    this.space();
	    this.word("mixins");
	    this.space();
	    this.printList(node.mixins, node);
	  }

	  this.space();
	  this.print(node.body, node);
	}

	function _variance(node) {
	  if (node.variance) {
	    if (node.variance.kind === "plus") {
	      this.token("+");
	    } else if (node.variance.kind === "minus") {
	      this.token("-");
	    }
	  }
	}

	function InterfaceDeclaration(node) {
	  this.word("interface");
	  this.space();

	  this._interfaceish(node);
	}

	function andSeparator() {
	  this.space();
	  this.token("&");
	  this.space();
	}

	function IntersectionTypeAnnotation(node) {
	  this.printJoin(node.types, node, {
	    separator: andSeparator
	  });
	}

	function MixedTypeAnnotation() {
	  this.word("mixed");
	}

	function EmptyTypeAnnotation() {
	  this.word("empty");
	}

	function NullableTypeAnnotation(node) {
	  this.token("?");
	  this.print(node.typeAnnotation, node);
	}

	function NumberTypeAnnotation() {
	  this.word("number");
	}

	function StringTypeAnnotation() {
	  this.word("string");
	}

	function ThisTypeAnnotation() {
	  this.word("this");
	}

	function TupleTypeAnnotation(node) {
	  this.token("[");
	  this.printList(node.types, node);
	  this.token("]");
	}

	function TypeofTypeAnnotation(node) {
	  this.word("typeof");
	  this.space();
	  this.print(node.argument, node);
	}

	function TypeAlias(node) {
	  this.word("type");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.typeParameters, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(node.right, node);
	  this.semicolon();
	}

	function TypeAnnotation(node) {
	  this.token(":");
	  this.space();
	  if (node.optional) this.token("?");
	  this.print(node.typeAnnotation, node);
	}

	function TypeParameterInstantiation(node) {
	  this.token("<");
	  this.printList(node.params, node, {});
	  this.token(">");
	}

	function TypeParameter(node) {
	  this._variance(node);

	  this.word(node.name);

	  if (node.bound) {
	    this.print(node.bound, node);
	  }

	  if (node.default) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.default, node);
	  }
	}

	function OpaqueType(node) {
	  this.word("opaque");
	  this.space();
	  this.word("type");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.typeParameters, node);

	  if (node.supertype) {
	    this.token(":");
	    this.space();
	    this.print(node.supertype, node);
	  }

	  if (node.impltype) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.impltype, node);
	  }

	  this.semicolon();
	}

	function ObjectTypeAnnotation(node) {
	  var _this = this;

	  if (node.exact) {
	    this.token("{|");
	  } else {
	    this.token("{");
	  }

	  var props = node.properties.concat(node.callProperties || [], node.indexers || []);

	  if (props.length) {
	    this.space();
	    this.printJoin(props, node, {
	      addNewlines: function addNewlines(leading) {
	        if (leading && !props[0]) return 1;
	      },
	      indent: true,
	      statement: true,
	      iterator: function iterator() {
	        if (props.length !== 1) {
	          _this.token(",");

	          _this.space();
	        }
	      }
	    });
	    this.space();
	  }

	  if (node.exact) {
	    this.token("|}");
	  } else {
	    this.token("}");
	  }
	}

	function ObjectTypeCallProperty(node) {
	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  this.print(node.value, node);
	}

	function ObjectTypeIndexer(node) {
	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  this._variance(node);

	  this.token("[");

	  if (node.id) {
	    this.print(node.id, node);
	    this.token(":");
	    this.space();
	  }

	  this.print(node.key, node);
	  this.token("]");
	  this.token(":");
	  this.space();
	  this.print(node.value, node);
	}

	function ObjectTypeProperty(node) {
	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  this._variance(node);

	  this.print(node.key, node);
	  if (node.optional) this.token("?");

	  if (!node.method) {
	    this.token(":");
	    this.space();
	  }

	  this.print(node.value, node);
	}

	function ObjectTypeSpreadProperty(node) {
	  this.token("...");
	  this.print(node.argument, node);
	}

	function QualifiedTypeIdentifier(node) {
	  this.print(node.qualification, node);
	  this.token(".");
	  this.print(node.id, node);
	}

	function orSeparator() {
	  this.space();
	  this.token("|");
	  this.space();
	}

	function UnionTypeAnnotation(node) {
	  this.printJoin(node.types, node, {
	    separator: orSeparator
	  });
	}

	function TypeCastExpression(node) {
	  this.token("(");
	  this.print(node.expression, node);
	  this.print(node.typeAnnotation, node);
	  this.token(")");
	}

	function Variance(node) {
	  if (node.kind === "plus") {
	    this.token("+");
	  } else {
	    this.token("-");
	  }
	}

	function VoidTypeAnnotation() {
	  this.word("void");
	}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _templateLiterals = __webpack_require__(91);

	Object.keys(_templateLiterals).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  exports[key] = _templateLiterals[key];
	});

	var _expressions = __webpack_require__(85);

	Object.keys(_expressions).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  exports[key] = _expressions[key];
	});

	var _statements = __webpack_require__(90);

	Object.keys(_statements).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  exports[key] = _statements[key];
	});

	var _classes = __webpack_require__(84);

	Object.keys(_classes).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  exports[key] = _classes[key];
	});

	var _methods = __webpack_require__(89);

	Object.keys(_methods).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  exports[key] = _methods[key];
	});

	var _modules = __webpack_require__(40);

	Object.keys(_modules).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  exports[key] = _modules[key];
	});

	var _types = __webpack_require__(23);

	Object.keys(_types).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  exports[key] = _types[key];
	});

	var _flow = __webpack_require__(86);

	Object.keys(_flow).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  exports[key] = _flow[key];
	});

	var _base = __webpack_require__(83);

	Object.keys(_base).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  exports[key] = _base[key];
	});

	var _jsx = __webpack_require__(88);

	Object.keys(_jsx).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  exports[key] = _jsx[key];
	});

	var _typescript = __webpack_require__(92);

	Object.keys(_typescript).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  exports[key] = _typescript[key];
	});

/***/ }),
/* 88 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports.JSXAttribute = JSXAttribute;
	exports.JSXIdentifier = JSXIdentifier;
	exports.JSXNamespacedName = JSXNamespacedName;
	exports.JSXMemberExpression = JSXMemberExpression;
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	exports.JSXExpressionContainer = JSXExpressionContainer;
	exports.JSXSpreadChild = JSXSpreadChild;
	exports.JSXText = JSXText;
	exports.JSXElement = JSXElement;
	exports.JSXOpeningElement = JSXOpeningElement;
	exports.JSXClosingElement = JSXClosingElement;
	exports.JSXEmptyExpression = JSXEmptyExpression;
	exports.JSXFragment = JSXFragment;
	exports.JSXOpeningFragment = JSXOpeningFragment;
	exports.JSXClosingFragment = JSXClosingFragment;

	function JSXAttribute(node) {
	  this.print(node.name, node);

	  if (node.value) {
	    this.token("=");
	    this.print(node.value, node);
	  }
	}

	function JSXIdentifier(node) {
	  this.word(node.name);
	}

	function JSXNamespacedName(node) {
	  this.print(node.namespace, node);
	  this.token(":");
	  this.print(node.name, node);
	}

	function JSXMemberExpression(node) {
	  this.print(node.object, node);
	  this.token(".");
	  this.print(node.property, node);
	}

	function JSXSpreadAttribute(node) {
	  this.token("{");
	  this.token("...");
	  this.print(node.argument, node);
	  this.token("}");
	}

	function JSXExpressionContainer(node) {
	  this.token("{");
	  this.print(node.expression, node);
	  this.token("}");
	}

	function JSXSpreadChild(node) {
	  this.token("{");
	  this.token("...");
	  this.print(node.expression, node);
	  this.token("}");
	}

	function JSXText(node) {
	  var raw = this.getPossibleRaw(node);

	  if (raw != null) {
	    this.token(raw);
	  } else {
	    this.token(node.value);
	  }
	}

	function JSXElement(node) {
	  var open = node.openingElement;
	  this.print(open, node);
	  if (open.selfClosing) return;
	  this.indent();
	  var _arr = node.children;

	  for (var _i = 0; _i < _arr.length; _i++) {
	    var child = _arr[_i];
	    this.print(child, node);
	  }

	  this.dedent();
	  this.print(node.closingElement, node);
	}

	function spaceSeparator() {
	  this.space();
	}

	function JSXOpeningElement(node) {
	  this.token("<");
	  this.print(node.name, node);

	  if (node.attributes.length > 0) {
	    this.space();
	    this.printJoin(node.attributes, node, {
	      separator: spaceSeparator
	    });
	  }

	  if (node.selfClosing) {
	    this.space();
	    this.token("/>");
	  } else {
	    this.token(">");
	  }
	}

	function JSXClosingElement(node) {
	  this.token("</");
	  this.print(node.name, node);
	  this.token(">");
	}

	function JSXEmptyExpression(node) {
	  this.printInnerComments(node);
	}

	function JSXFragment(node) {
	  this.print(node.openingFragment, node);
	  this.indent();
	  var _arr2 = node.children;

	  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	    var child = _arr2[_i2];
	    this.print(child, node);
	  }

	  this.dedent();
	  this.print(node.closingFragment, node);
	}

	function JSXOpeningFragment() {
	  this.token("<");
	  this.token(">");
	}

	function JSXClosingFragment() {
	  this.token("</");
	  this.token(">");
	}

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports._params = _params;
	exports._parameters = _parameters;
	exports._param = _param;
	exports._methodHead = _methodHead;
	exports._predicate = _predicate;
	exports._functionHead = _functionHead;
	exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
	exports.ArrowFunctionExpression = ArrowFunctionExpression;

	var t = _interopRequireWildcard(__webpack_require__(1));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function _params(node) {
	  this.print(node.typeParameters, node);
	  this.token("(");

	  this._parameters(node.params, node);

	  this.token(")");
	  this.print(node.returnType, node);
	}

	function _parameters(parameters, parent) {
	  for (var i = 0; i < parameters.length; i++) {
	    this._param(parameters[i], parent);

	    if (i < parameters.length - 1) {
	      this.token(",");
	      this.space();
	    }
	  }
	}

	function _param(parameter, parent) {
	  this.printJoin(parameter.decorators, parameter);
	  this.print(parameter, parent);
	  if (parameter.optional) this.token("?");
	  this.print(parameter.typeAnnotation, parameter);
	}

	function _methodHead(node) {
	  var kind = node.kind;
	  var key = node.key;

	  if (kind === "get" || kind === "set") {
	    this.word(kind);
	    this.space();
	  }

	  if (node.async) {
	    this.word("async");
	    this.space();
	  }

	  if (kind === "method" || kind === "init") {
	    if (node.generator) {
	      this.token("*");
	    }
	  }

	  if (node.computed) {
	    this.token("[");
	    this.print(key, node);
	    this.token("]");
	  } else {
	    this.print(key, node);
	  }

	  if (node.optional) {
	    this.token("?");
	  }

	  this._params(node);
	}

	function _predicate(node) {
	  if (node.predicate) {
	    if (!node.returnType) {
	      this.token(":");
	    }

	    this.space();
	    this.print(node.predicate, node);
	  }
	}

	function _functionHead(node) {
	  if (node.async) {
	    this.word("async");
	    this.space();
	  }

	  this.word("function");
	  if (node.generator) this.token("*");
	  this.space();

	  if (node.id) {
	    this.print(node.id, node);
	  }

	  this._params(node);

	  this._predicate(node);
	}

	function FunctionExpression(node) {
	  this._functionHead(node);

	  this.space();
	  this.print(node.body, node);
	}

	function ArrowFunctionExpression(node) {
	  if (node.async) {
	    this.word("async");
	    this.space();
	  }

	  var firstParam = node.params[0];

	  if (node.params.length === 1 && t.isIdentifier(firstParam) && !hasTypes(node, firstParam)) {
	    this.print(firstParam, node);
	  } else {
	    this._params(node);
	  }

	  this._predicate(node);

	  this.space();
	  this.token("=>");
	  this.space();
	  this.print(node.body, node);
	}

	function hasTypes(node, param) {
	  return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;
	}

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.WithStatement = WithStatement;
	exports.IfStatement = IfStatement;
	exports.ForStatement = ForStatement;
	exports.WhileStatement = WhileStatement;
	exports.DoWhileStatement = DoWhileStatement;
	exports.LabeledStatement = LabeledStatement;
	exports.TryStatement = TryStatement;
	exports.CatchClause = CatchClause;
	exports.SwitchStatement = SwitchStatement;
	exports.SwitchCase = SwitchCase;
	exports.DebuggerStatement = DebuggerStatement;
	exports.VariableDeclaration = VariableDeclaration;
	exports.VariableDeclarator = VariableDeclarator;
	exports.ThrowStatement = exports.BreakStatement = exports.ReturnStatement = exports.ContinueStatement = exports.ForOfStatement = exports.ForInStatement = void 0;

	var t = _interopRequireWildcard(__webpack_require__(1));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function WithStatement(node) {
	  this.word("with");
	  this.space();
	  this.token("(");
	  this.print(node.object, node);
	  this.token(")");
	  this.printBlock(node);
	}

	function IfStatement(node) {
	  this.word("if");
	  this.space();
	  this.token("(");
	  this.print(node.test, node);
	  this.token(")");
	  this.space();
	  var needsBlock = node.alternate && t.isIfStatement(getLastStatement(node.consequent));

	  if (needsBlock) {
	    this.token("{");
	    this.newline();
	    this.indent();
	  }

	  this.printAndIndentOnComments(node.consequent, node);

	  if (needsBlock) {
	    this.dedent();
	    this.newline();
	    this.token("}");
	  }

	  if (node.alternate) {
	    if (this.endsWith("}")) this.space();
	    this.word("else");
	    this.space();
	    this.printAndIndentOnComments(node.alternate, node);
	  }
	}

	function getLastStatement(statement) {
	  if (!t.isStatement(statement.body)) return statement;
	  return getLastStatement(statement.body);
	}

	function ForStatement(node) {
	  this.word("for");
	  this.space();
	  this.token("(");
	  this.inForStatementInitCounter++;
	  this.print(node.init, node);
	  this.inForStatementInitCounter--;
	  this.token(";");

	  if (node.test) {
	    this.space();
	    this.print(node.test, node);
	  }

	  this.token(";");

	  if (node.update) {
	    this.space();
	    this.print(node.update, node);
	  }

	  this.token(")");
	  this.printBlock(node);
	}

	function WhileStatement(node) {
	  this.word("while");
	  this.space();
	  this.token("(");
	  this.print(node.test, node);
	  this.token(")");
	  this.printBlock(node);
	}

	var buildForXStatement = function buildForXStatement(op) {
	  return function (node) {
	    this.word("for");
	    this.space();

	    if (op === "of" && node.await) {
	      this.word("await");
	      this.space();
	    }

	    this.token("(");
	    this.print(node.left, node);
	    this.space();
	    this.word(op);
	    this.space();
	    this.print(node.right, node);
	    this.token(")");
	    this.printBlock(node);
	  };
	};

	var ForInStatement = buildForXStatement("in");
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = buildForXStatement("of");
	exports.ForOfStatement = ForOfStatement;

	function DoWhileStatement(node) {
	  this.word("do");
	  this.space();
	  this.print(node.body, node);
	  this.space();
	  this.word("while");
	  this.space();
	  this.token("(");
	  this.print(node.test, node);
	  this.token(")");
	  this.semicolon();
	}

	function buildLabelStatement(prefix, key) {
	  if (key === void 0) {
	    key = "label";
	  }

	  return function (node) {
	    this.word(prefix);
	    var label = node[key];

	    if (label) {
	      this.space();
	      var isLabel = key == "label";
	      var terminatorState = this.startTerminatorless(isLabel);
	      this.print(label, node);
	      this.endTerminatorless(terminatorState);
	    }

	    this.semicolon();
	  };
	}

	var ContinueStatement = buildLabelStatement("continue");
	exports.ContinueStatement = ContinueStatement;
	var ReturnStatement = buildLabelStatement("return", "argument");
	exports.ReturnStatement = ReturnStatement;
	var BreakStatement = buildLabelStatement("break");
	exports.BreakStatement = BreakStatement;
	var ThrowStatement = buildLabelStatement("throw", "argument");
	exports.ThrowStatement = ThrowStatement;

	function LabeledStatement(node) {
	  this.print(node.label, node);
	  this.token(":");
	  this.space();
	  this.print(node.body, node);
	}

	function TryStatement(node) {
	  this.word("try");
	  this.space();
	  this.print(node.block, node);
	  this.space();

	  if (node.handlers) {
	    this.print(node.handlers[0], node);
	  } else {
	    this.print(node.handler, node);
	  }

	  if (node.finalizer) {
	    this.space();
	    this.word("finally");
	    this.space();
	    this.print(node.finalizer, node);
	  }
	}

	function CatchClause(node) {
	  this.word("catch");
	  this.space();

	  if (node.param) {
	    this.token("(");
	    this.print(node.param, node);
	    this.token(")");
	    this.space();
	  }

	  this.print(node.body, node);
	}

	function SwitchStatement(node) {
	  this.word("switch");
	  this.space();
	  this.token("(");
	  this.print(node.discriminant, node);
	  this.token(")");
	  this.space();
	  this.token("{");
	  this.printSequence(node.cases, node, {
	    indent: true,
	    addNewlines: function addNewlines(leading, cas) {
	      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
	    }
	  });
	  this.token("}");
	}

	function SwitchCase(node) {
	  if (node.test) {
	    this.word("case");
	    this.space();
	    this.print(node.test, node);
	    this.token(":");
	  } else {
	    this.word("default");
	    this.token(":");
	  }

	  if (node.consequent.length) {
	    this.newline();
	    this.printSequence(node.consequent, node, {
	      indent: true
	    });
	  }
	}

	function DebuggerStatement() {
	  this.word("debugger");
	  this.semicolon();
	}

	function variableDeclarationIndent() {
	  this.token(",");
	  this.newline();
	  if (this.endsWith("\n")) for (var i = 0; i < 4; i++) {
	    this.space(true);
	  }
	}

	function constDeclarationIndent() {
	  this.token(",");
	  this.newline();
	  if (this.endsWith("\n")) for (var i = 0; i < 6; i++) {
	    this.space(true);
	  }
	}

	function VariableDeclaration(node, parent) {
	  if (node.declare) {
	    this.word("declare");
	    this.space();
	  }

	  this.word(node.kind);
	  this.space();
	  var hasInits = false;

	  if (!t.isFor(parent)) {
	    var _arr = node.declarations;

	    for (var _i = 0; _i < _arr.length; _i++) {
	      var declar = _arr[_i];

	      if (declar.init) {
	        hasInits = true;
	      }
	    }
	  }

	  var separator;

	  if (hasInits) {
	    separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
	  }

	  this.printList(node.declarations, node, {
	    separator: separator
	  });

	  if (t.isFor(parent)) {
	    if (parent.left === node || parent.init === node) return;
	  }

	  this.semicolon();
	}

	function VariableDeclarator(node) {
	  this.print(node.id, node);
	  this.print(node.id.typeAnnotation, node);

	  if (node.init) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.init, node);
	  }
	}

/***/ }),
/* 91 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	exports.TemplateElement = TemplateElement;
	exports.TemplateLiteral = TemplateLiteral;

	function TaggedTemplateExpression(node) {
	  this.print(node.tag, node);
	  this.print(node.quasi, node);
	}

	function TemplateElement(node, parent) {
	  var isFirst = parent.quasis[0] === node;
	  var isLast = parent.quasis[parent.quasis.length - 1] === node;
	  var value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
	  this.token(value);
	}

	function TemplateLiteral(node) {
	  var quasis = node.quasis;

	  for (var i = 0; i < quasis.length; i++) {
	    this.print(quasis[i], node);

	    if (i + 1 < quasis.length) {
	      this.print(node.expressions[i], node);
	    }
	  }
	}

/***/ }),
/* 92 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports.TSTypeAnnotation = TSTypeAnnotation;
	exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
	exports.TSTypeParameter = TSTypeParameter;
	exports.TSParameterProperty = TSParameterProperty;
	exports.TSDeclareFunction = TSDeclareFunction;
	exports.TSDeclareMethod = TSDeclareMethod;
	exports.TSQualifiedName = TSQualifiedName;
	exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
	exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
	exports.TSPropertySignature = TSPropertySignature;
	exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
	exports.TSMethodSignature = TSMethodSignature;
	exports.TSIndexSignature = TSIndexSignature;
	exports.TSAnyKeyword = TSAnyKeyword;
	exports.TSNumberKeyword = TSNumberKeyword;
	exports.TSObjectKeyword = TSObjectKeyword;
	exports.TSBooleanKeyword = TSBooleanKeyword;
	exports.TSStringKeyword = TSStringKeyword;
	exports.TSSymbolKeyword = TSSymbolKeyword;
	exports.TSVoidKeyword = TSVoidKeyword;
	exports.TSUndefinedKeyword = TSUndefinedKeyword;
	exports.TSNullKeyword = TSNullKeyword;
	exports.TSNeverKeyword = TSNeverKeyword;
	exports.TSThisType = TSThisType;
	exports.TSFunctionType = TSFunctionType;
	exports.TSConstructorType = TSConstructorType;
	exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
	exports.TSTypeReference = TSTypeReference;
	exports.TSTypePredicate = TSTypePredicate;
	exports.TSTypeQuery = TSTypeQuery;
	exports.TSTypeLiteral = TSTypeLiteral;
	exports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
	exports.tsPrintBraced = tsPrintBraced;
	exports.TSArrayType = TSArrayType;
	exports.TSTupleType = TSTupleType;
	exports.TSUnionType = TSUnionType;
	exports.TSIntersectionType = TSIntersectionType;
	exports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;
	exports.TSParenthesizedType = TSParenthesizedType;
	exports.TSTypeOperator = TSTypeOperator;
	exports.TSIndexedAccessType = TSIndexedAccessType;
	exports.TSMappedType = TSMappedType;
	exports.TSLiteralType = TSLiteralType;
	exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
	exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
	exports.TSInterfaceBody = TSInterfaceBody;
	exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
	exports.TSAsExpression = TSAsExpression;
	exports.TSTypeAssertion = TSTypeAssertion;
	exports.TSEnumDeclaration = TSEnumDeclaration;
	exports.TSEnumMember = TSEnumMember;
	exports.TSModuleDeclaration = TSModuleDeclaration;
	exports.TSModuleBlock = TSModuleBlock;
	exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
	exports.TSExternalModuleReference = TSExternalModuleReference;
	exports.TSNonNullExpression = TSNonNullExpression;
	exports.TSExportAssignment = TSExportAssignment;
	exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
	exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;

	function TSTypeAnnotation(node) {
	  this.token(":");
	  this.space();
	  if (node.optional) this.token("?");
	  this.print(node.typeAnnotation, node);
	}

	function TSTypeParameterInstantiation(node) {
	  this.token("<");
	  this.printList(node.params, node, {});
	  this.token(">");
	}

	function TSTypeParameter(node) {
	  this.word(node.name);

	  if (node.constraint) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.print(node.constraint, node);
	  }

	  if (node.default) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.default, node);
	  }
	}

	function TSParameterProperty(node) {
	  if (node.accessibility) {
	    this.word(node.accessibility);
	    this.space();
	  }

	  if (node.readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  this._param(node.parameter);
	}

	function TSDeclareFunction(node) {
	  if (node.declare) {
	    this.word("declare");
	    this.space();
	  }

	  this._functionHead(node);

	  this.token(";");
	}

	function TSDeclareMethod(node) {
	  this._classMethodHead(node);

	  this.token(";");
	}

	function TSQualifiedName(node) {
	  this.print(node.left, node);
	  this.token(".");
	  this.print(node.right, node);
	}

	function TSCallSignatureDeclaration(node) {
	  this.tsPrintSignatureDeclarationBase(node);
	}

	function TSConstructSignatureDeclaration(node) {
	  this.word("new");
	  this.space();
	  this.tsPrintSignatureDeclarationBase(node);
	}

	function TSPropertySignature(node) {
	  var readonly = node.readonly,
	      initializer = node.initializer;

	  if (readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  this.tsPrintPropertyOrMethodName(node);
	  this.print(node.typeAnnotation, node);

	  if (initializer) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(initializer, node);
	  }

	  this.token(";");
	}

	function tsPrintPropertyOrMethodName(node) {
	  if (node.computed) {
	    this.token("[");
	  }

	  this.print(node.key, node);

	  if (node.computed) {
	    this.token("]");
	  }

	  if (node.optional) {
	    this.token("?");
	  }
	}

	function TSMethodSignature(node) {
	  this.tsPrintPropertyOrMethodName(node);
	  this.tsPrintSignatureDeclarationBase(node);
	  this.token(";");
	}

	function TSIndexSignature(node) {
	  var readonly = node.readonly;

	  if (readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  this.token("[");

	  this._parameters(node.parameters, node);

	  this.token("]");
	  this.print(node.typeAnnotation, node);
	  this.token(";");
	}

	function TSAnyKeyword() {
	  this.word("any");
	}

	function TSNumberKeyword() {
	  this.word("number");
	}

	function TSObjectKeyword() {
	  this.word("object");
	}

	function TSBooleanKeyword() {
	  this.word("boolean");
	}

	function TSStringKeyword() {
	  this.word("string");
	}

	function TSSymbolKeyword() {
	  this.word("symbol");
	}

	function TSVoidKeyword() {
	  this.word("void");
	}

	function TSUndefinedKeyword() {
	  this.word("undefined");
	}

	function TSNullKeyword() {
	  this.word("null");
	}

	function TSNeverKeyword() {
	  this.word("never");
	}

	function TSThisType() {
	  this.word("this");
	}

	function TSFunctionType(node) {
	  this.tsPrintFunctionOrConstructorType(node);
	}

	function TSConstructorType(node) {
	  this.word("new");
	  this.space();
	  this.tsPrintFunctionOrConstructorType(node);
	}

	function tsPrintFunctionOrConstructorType(node) {
	  var typeParameters = node.typeParameters,
	      parameters = node.parameters;
	  this.print(typeParameters, node);
	  this.token("(");

	  this._parameters(parameters, node);

	  this.token(")");
	  this.space();
	  this.token("=>");
	  this.space();
	  this.print(node.typeAnnotation.typeAnnotation, node);
	}

	function TSTypeReference(node) {
	  this.print(node.typeName, node);
	  this.print(node.typeParameters, node);
	}

	function TSTypePredicate(node) {
	  this.print(node.parameterName);
	  this.space();
	  this.word("is");
	  this.space();
	  this.print(node.typeAnnotation.typeAnnotation);
	}

	function TSTypeQuery(node) {
	  this.word("typeof");
	  this.space();
	  this.print(node.exprName);
	}

	function TSTypeLiteral(node) {
	  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
	}

	function tsPrintTypeLiteralOrInterfaceBody(members, node) {
	  this.tsPrintBraced(members, node);
	}

	function tsPrintBraced(members, node) {
	  this.token("{");

	  if (members.length) {
	    this.indent();
	    this.newline();

	    for (var _iterator = members, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	      var _ref;

	      if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref = _iterator[_i++];
	      } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref = _i.value;
	      }

	      var _member = _ref;
	      this.print(_member, node);
	      this.newline();
	    }

	    this.dedent();
	    this.rightBrace();
	  } else {
	    this.token("}");
	  }
	}

	function TSArrayType(node) {
	  this.print(node.elementType);
	  this.token("[]");
	}

	function TSTupleType(node) {
	  this.token("[");
	  this.printList(node.elementTypes, node);
	  this.token("]");
	}

	function TSUnionType(node) {
	  this.tsPrintUnionOrIntersectionType(node, "|");
	}

	function TSIntersectionType(node) {
	  this.tsPrintUnionOrIntersectionType(node, "&");
	}

	function tsPrintUnionOrIntersectionType(node, sep) {
	  this.printJoin(node.types, node, {
	    separator: function separator() {
	      this.space();
	      this.token(sep);
	      this.space();
	    }
	  });
	}

	function TSParenthesizedType(node) {
	  this.token("(");
	  this.print(node.typeAnnotation, node);
	  this.token(")");
	}

	function TSTypeOperator(node) {
	  this.token(node.operator);
	  this.space();
	  this.print(node.typeAnnotation, node);
	}

	function TSIndexedAccessType(node) {
	  this.print(node.objectType, node);
	  this.token("[");
	  this.print(node.indexType, node);
	  this.token("]");
	}

	function TSMappedType(node) {
	  var readonly = node.readonly,
	      typeParameter = node.typeParameter,
	      optional = node.optional;
	  this.token("{");
	  this.space();

	  if (readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  this.token("[");
	  this.word(typeParameter.name);
	  this.space();
	  this.word("in");
	  this.space();
	  this.print(typeParameter.constraint, typeParameter);
	  this.token("]");

	  if (optional) {
	    this.token("?");
	  }

	  this.token(":");
	  this.space();
	  this.print(node.typeAnnotation, node);
	  this.space();
	  this.token("}");
	}

	function TSLiteralType(node) {
	  this.print(node.literal, node);
	}

	function TSExpressionWithTypeArguments(node) {
	  this.print(node.expression, node);
	  this.print(node.typeParameters, node);
	}

	function TSInterfaceDeclaration(node) {
	  var declare = node.declare,
	      id = node.id,
	      typeParameters = node.typeParameters,
	      extendz = node.extends,
	      body = node.body;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("interface");
	  this.space();
	  this.print(id, node);
	  this.print(typeParameters, node);

	  if (extendz) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.printList(extendz, node);
	  }

	  this.space();
	  this.print(body, node);
	}

	function TSInterfaceBody(node) {
	  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
	}

	function TSTypeAliasDeclaration(node) {
	  var declare = node.declare,
	      id = node.id,
	      typeParameters = node.typeParameters,
	      typeAnnotation = node.typeAnnotation;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("type");
	  this.space();
	  this.print(id, node);
	  this.print(typeParameters, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(typeAnnotation, node);
	  this.token(";");
	}

	function TSAsExpression(node) {
	  var expression = node.expression,
	      typeAnnotation = node.typeAnnotation;
	  this.print(expression, node);
	  this.space();
	  this.word("as");
	  this.space();
	  this.print(typeAnnotation, node);
	}

	function TSTypeAssertion(node) {
	  var typeAnnotation = node.typeAnnotation,
	      expression = node.expression;
	  this.token("<");
	  this.print(typeAnnotation, node);
	  this.token(">");
	  this.space();
	  this.print(expression, node);
	}

	function TSEnumDeclaration(node) {
	  var declare = node.declare,
	      isConst = node.const,
	      id = node.id,
	      members = node.members;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  if (isConst) {
	    this.word("const");
	    this.space();
	  }

	  this.word("enum");
	  this.space();
	  this.print(id, node);
	  this.space();
	  this.tsPrintBraced(members, node);
	}

	function TSEnumMember(node) {
	  var id = node.id,
	      initializer = node.initializer;
	  this.print(id, node);

	  if (initializer) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(initializer, node);
	  }

	  this.token(",");
	}

	function TSModuleDeclaration(node) {
	  var declare = node.declare,
	      id = node.id;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  if (!node.global) {
	    this.word(id.type === "Identifier" ? "namespace" : "module");
	    this.space();
	  }

	  this.print(id, node);

	  if (!node.body) {
	    this.token(";");
	    return;
	  }

	  var body = node.body;

	  while (body.type === "TSModuleDeclaration") {
	    this.token(".");
	    this.print(body.id, body);
	    body = body.body;
	  }

	  this.space();
	  this.print(body, node);
	}

	function TSModuleBlock(node) {
	  this.tsPrintBraced(node.body, node);
	}

	function TSImportEqualsDeclaration(node) {
	  var isExport = node.isExport,
	      id = node.id,
	      moduleReference = node.moduleReference;

	  if (isExport) {
	    this.word("export");
	    this.space();
	  }

	  this.word("import");
	  this.space();
	  this.print(id, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(moduleReference, node);
	  this.token(";");
	}

	function TSExternalModuleReference(node) {
	  this.token("require(");
	  this.print(node.expression, node);
	  this.token(")");
	}

	function TSNonNullExpression(node) {
	  this.print(node.expression, node);
	  this.token("!");
	}

	function TSExportAssignment(node) {
	  this.word("export");
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(node.expression, node);
	  this.token(";");
	}

	function TSNamespaceExportDeclaration(node) {
	  this.word("export");
	  this.space();
	  this.word("as");
	  this.space();
	  this.word("namespace");
	  this.space();
	  this.print(node.id, node);
	}

	function tsPrintSignatureDeclarationBase(node) {
	  var typeParameters = node.typeParameters,
	      parameters = node.parameters;
	  this.print(typeParameters, node);
	  this.token("(");

	  this._parameters(parameters, node);

	  this.token(")");
	  this.print(node.typeAnnotation, node);
	}

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = _default;
	exports.CodeGenerator = void 0;

	var _sourceMap = _interopRequireDefault(__webpack_require__(97));

	var _printer = _interopRequireDefault(__webpack_require__(96));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

	var Generator = function (_Printer) {
	  _inheritsLoose(Generator, _Printer);

	  function Generator(ast, opts, code) {
	    var _this;

	    if (opts === void 0) {
	      opts = {};
	    }

	    var format = normalizeOptions(code, opts);
	    var map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
	    _this = _Printer.call(this, format, map) || this;
	    _this.ast = ast;
	    return _this;
	  }

	  var _proto = Generator.prototype;

	  _proto.generate = function generate() {
	    return _Printer.prototype.generate.call(this, this.ast);
	  };

	  return Generator;
	}(_printer.default);

	function normalizeOptions(code, opts) {
	  var format = {
	    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
	    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
	    shouldPrintComment: opts.shouldPrintComment,
	    retainLines: opts.retainLines,
	    retainFunctionParens: opts.retainFunctionParens,
	    comments: opts.comments == null || opts.comments,
	    compact: opts.compact,
	    minified: opts.minified,
	    concise: opts.concise,
	    jsonCompatibleStrings: opts.jsonCompatibleStrings,
	    indent: {
	      adjustMultilineComment: true,
	      style: "  ",
	      base: 0
	    }
	  };

	  if (format.minified) {
	    format.compact = true;

	    format.shouldPrintComment = format.shouldPrintComment || function () {
	      return format.comments;
	    };
	  } else {
	    format.shouldPrintComment = format.shouldPrintComment || function (value) {
	      return format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0;
	    };
	  }

	  if (format.compact === "auto") {
	    format.compact = code.length > 500000;

	    if (format.compact) {
	      console.error("[BABEL] Note: The code generator has deoptimised the styling of " + (opts.filename + " as it exceeds the max of " + "500KB" + "."));
	    }
	  }

	  if (format.compact) {
	    format.indent.adjustMultilineComment = false;
	  }

	  return format;
	}

	var CodeGenerator = function () {
	  function CodeGenerator(ast, opts, code) {
	    this._generator = new Generator(ast, opts, code);
	  }

	  var _proto2 = CodeGenerator.prototype;

	  _proto2.generate = function generate() {
	    return this._generator.generate();
	  };

	  return CodeGenerator;
	}();

	exports.CodeGenerator = CodeGenerator;

	function _default(ast, opts, code) {
	  var gen = new Generator(ast, opts, code);
	  return gen.generate();
	}

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.FunctionTypeAnnotation = exports.NullableTypeAnnotation = NullableTypeAnnotation;
	exports.UpdateExpression = UpdateExpression;
	exports.ObjectExpression = ObjectExpression;
	exports.DoExpression = DoExpression;
	exports.Binary = Binary;
	exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
	exports.TSAsExpression = TSAsExpression;
	exports.TSTypeAssertion = TSTypeAssertion;
	exports.BinaryExpression = BinaryExpression;
	exports.SequenceExpression = SequenceExpression;
	exports.AwaitExpression = exports.YieldExpression = YieldExpression;
	exports.ClassExpression = ClassExpression;
	exports.UnaryLike = UnaryLike;
	exports.FunctionExpression = FunctionExpression;
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	exports.ConditionalExpression = ConditionalExpression;
	exports.AssignmentExpression = AssignmentExpression;
	exports.NewExpression = NewExpression;

	var t = _interopRequireWildcard(__webpack_require__(1));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	var PRECEDENCE = {
	  "||": 0,
	  "&&": 1,
	  "|": 2,
	  "^": 3,
	  "&": 4,
	  "==": 5,
	  "===": 5,
	  "!=": 5,
	  "!==": 5,
	  "<": 6,
	  ">": 6,
	  "<=": 6,
	  ">=": 6,
	  in: 6,
	  instanceof: 6,
	  ">>": 7,
	  "<<": 7,
	  ">>>": 7,
	  "+": 8,
	  "-": 8,
	  "*": 9,
	  "/": 9,
	  "%": 9,
	  "**": 10
	};

	var isClassExtendsClause = function isClassExtendsClause(node, parent) {
	  return (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;
	};

	function NullableTypeAnnotation(node, parent) {
	  return t.isArrayTypeAnnotation(parent);
	}

	function UpdateExpression(node, parent) {
	  return t.isMemberExpression(parent, {
	    object: node
	  }) || t.isCallExpression(parent, {
	    callee: node
	  }) || t.isNewExpression(parent, {
	    callee: node
	  }) || isClassExtendsClause(node, parent);
	}

	function ObjectExpression(node, parent, printStack) {
	  return isFirstInStatement(printStack, {
	    considerArrow: true
	  });
	}

	function DoExpression(node, parent, printStack) {
	  return isFirstInStatement(printStack);
	}

	function Binary(node, parent) {
	  if (node.operator === "**" && t.isBinaryExpression(parent, {
	    operator: "**"
	  })) {
	    return parent.left === node;
	  }

	  if (isClassExtendsClause(node, parent)) {
	    return true;
	  }

	  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isUnaryLike(parent) || t.isMemberExpression(parent) && parent.object === node || t.isAwaitExpression(parent)) {
	    return true;
	  }

	  if (t.isBinary(parent)) {
	    var parentOp = parent.operator;
	    var parentPos = PRECEDENCE[parentOp];
	    var nodeOp = node.operator;
	    var nodePos = PRECEDENCE[nodeOp];

	    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {
	      return true;
	    }
	  }

	  return false;
	}

	function UnionTypeAnnotation(node, parent) {
	  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);
	}

	function TSAsExpression() {
	  return true;
	}

	function TSTypeAssertion() {
	  return true;
	}

	function BinaryExpression(node, parent) {
	  return node.operator === "in" && (t.isVariableDeclarator(parent) || t.isFor(parent));
	}

	function SequenceExpression(node, parent) {
	  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {
	    return false;
	  }

	  return true;
	}

	function YieldExpression(node, parent) {
	  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
	}

	function ClassExpression(node, parent, printStack) {
	  return isFirstInStatement(printStack, {
	    considerDefaultExports: true
	  });
	}

	function UnaryLike(node, parent) {
	  return t.isMemberExpression(parent, {
	    object: node
	  }) || t.isCallExpression(parent, {
	    callee: node
	  }) || t.isNewExpression(parent, {
	    callee: node
	  }) || t.isBinaryExpression(parent, {
	    operator: "**",
	    left: node
	  }) || isClassExtendsClause(node, parent);
	}

	function FunctionExpression(node, parent, printStack) {
	  return isFirstInStatement(printStack, {
	    considerDefaultExports: true
	  });
	}

	function ArrowFunctionExpression(node, parent) {
	  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);
	}

	function ConditionalExpression(node, parent) {
	  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {
	    test: node
	  }) || t.isAwaitExpression(parent) || t.isTaggedTemplateExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {
	    return true;
	  }

	  return UnaryLike(node, parent);
	}

	function AssignmentExpression(node) {
	  if (t.isObjectPattern(node.left)) {
	    return true;
	  } else {
	    return ConditionalExpression.apply(void 0, arguments);
	  }
	}

	function NewExpression(node, parent) {
	  return isClassExtendsClause(node, parent);
	}

	function isFirstInStatement(printStack, _temp) {
	  var _ref = _temp === void 0 ? {} : _temp,
	      _ref$considerArrow = _ref.considerArrow,
	      considerArrow = _ref$considerArrow === void 0 ? false : _ref$considerArrow,
	      _ref$considerDefaultE = _ref.considerDefaultExports,
	      considerDefaultExports = _ref$considerDefaultE === void 0 ? false : _ref$considerDefaultE;

	  var i = printStack.length - 1;
	  var node = printStack[i];
	  i--;
	  var parent = printStack[i];

	  while (i > 0) {
	    if (t.isExpressionStatement(parent, {
	      expression: node
	    }) || t.isTaggedTemplateExpression(parent) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {
	      declaration: node
	    }) || considerArrow && t.isArrowFunctionExpression(parent, {
	      body: node
	    })) {
	      return true;
	    }

	    if (t.isCallExpression(parent, {
	      callee: node
	    }) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isMemberExpression(parent, {
	      object: node
	    }) || t.isConditional(parent, {
	      test: node
	    }) || t.isBinary(parent, {
	      left: node
	    }) || t.isAssignmentExpression(parent, {
	      left: node
	    })) {
	      node = parent;
	      i--;
	      parent = printStack[i];
	    } else {
	      return false;
	    }
	  }

	  return false;
	}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.list = exports.nodes = void 0;

	var _map = _interopRequireDefault(__webpack_require__(152));

	var t = _interopRequireWildcard(__webpack_require__(1));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function crawl(node, state) {
	  if (state === void 0) {
	    state = {};
	  }

	  if (t.isMemberExpression(node)) {
	    crawl(node.object, state);
	    if (node.computed) crawl(node.property, state);
	  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
	    crawl(node.left, state);
	    crawl(node.right, state);
	  } else if (t.isCallExpression(node)) {
	    state.hasCall = true;
	    crawl(node.callee, state);
	  } else if (t.isFunction(node)) {
	    state.hasFunction = true;
	  } else if (t.isIdentifier(node)) {
	    state.hasHelper = state.hasHelper || isHelper(node.callee);
	  }

	  return state;
	}

	function isHelper(node) {
	  if (t.isMemberExpression(node)) {
	    return isHelper(node.object) || isHelper(node.property);
	  } else if (t.isIdentifier(node)) {
	    return node.name === "require" || node.name[0] === "_";
	  } else if (t.isCallExpression(node)) {
	    return isHelper(node.callee);
	  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
	    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
	  } else {
	    return false;
	  }
	}

	function isType(node) {
	  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);
	}

	var nodes = {
	  AssignmentExpression: function AssignmentExpression(node) {
	    var state = crawl(node.right);

	    if (state.hasCall && state.hasHelper || state.hasFunction) {
	      return {
	        before: state.hasFunction,
	        after: true
	      };
	    }
	  },
	  SwitchCase: function SwitchCase(node, parent) {
	    return {
	      before: node.consequent.length || parent.cases[0] === node,
	      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
	    };
	  },
	  LogicalExpression: function LogicalExpression(node) {
	    if (t.isFunction(node.left) || t.isFunction(node.right)) {
	      return {
	        after: true
	      };
	    }
	  },
	  Literal: function Literal(node) {
	    if (node.value === "use strict") {
	      return {
	        after: true
	      };
	    }
	  },
	  CallExpression: function CallExpression(node) {
	    if (t.isFunction(node.callee) || isHelper(node)) {
	      return {
	        before: true,
	        after: true
	      };
	    }
	  },
	  VariableDeclaration: function VariableDeclaration(node) {
	    for (var i = 0; i < node.declarations.length; i++) {
	      var declar = node.declarations[i];
	      var enabled = isHelper(declar.id) && !isType(declar.init);

	      if (!enabled) {
	        var state = crawl(declar.init);
	        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
	      }

	      if (enabled) {
	        return {
	          before: true,
	          after: true
	        };
	      }
	    }
	  },
	  IfStatement: function IfStatement(node) {
	    if (t.isBlockStatement(node.consequent)) {
	      return {
	        before: true,
	        after: true
	      };
	    }
	  }
	};
	exports.nodes = nodes;

	nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
	  if (parent.properties[0] === node) {
	    return {
	      before: true
	    };
	  }
	};

	nodes.ObjectTypeCallProperty = function (node, parent) {
	  if (parent.callProperties[0] === node && (!parent.properties || !parent.properties.length)) {
	    return {
	      before: true
	    };
	  }
	};

	nodes.ObjectTypeIndexer = function (node, parent) {
	  if (parent.indexers[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length)) {
	    return {
	      before: true
	    };
	  }
	};

	var list = {
	  VariableDeclaration: function VariableDeclaration(node) {
	    return (0, _map.default)(node.declarations, "init");
	  },
	  ArrayExpression: function ArrayExpression(node) {
	    return node.elements;
	  },
	  ObjectExpression: function ObjectExpression(node) {
	    return node.properties;
	  }
	};
	exports.list = list;
	[["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function (_ref) {
	  var type = _ref[0],
	      amounts = _ref[1];

	  if (typeof amounts === "boolean") {
	    amounts = {
	      after: amounts,
	      before: amounts
	    };
	  }

	  [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
	    nodes[type] = function () {
	      return amounts;
	    };
	  });
	});

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = void 0;

	var _isInteger = _interopRequireDefault(__webpack_require__(149));

	var _repeat = _interopRequireDefault(__webpack_require__(153));

	var _buffer = _interopRequireDefault(__webpack_require__(82));

	var n = _interopRequireWildcard(__webpack_require__(41));

	var t = _interopRequireWildcard(__webpack_require__(1));

	var generatorFunctions = _interopRequireWildcard(__webpack_require__(87));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var SCIENTIFIC_NOTATION = /e/i;
	var ZERO_DECIMAL_INTEGER = /\.0+$/;
	var NON_DECIMAL_LITERAL = /^0[box]/;

	var Printer = function () {
	  function Printer(format, map) {
	    this.inForStatementInitCounter = 0;
	    this._printStack = [];
	    this._indent = 0;
	    this._insideAux = false;
	    this._printedCommentStarts = {};
	    this._parenPushNewlineState = null;
	    this._noLineTerminator = false;
	    this._printAuxAfterOnNextUserNode = false;
	    this._printedComments = new WeakSet();
	    this._endsWithInteger = false;
	    this._endsWithWord = false;
	    this.format = format || {};
	    this._buf = new _buffer.default(map);
	  }

	  var _proto = Printer.prototype;

	  _proto.generate = function generate(ast) {
	    this.print(ast);

	    this._maybeAddAuxComment();

	    return this._buf.get();
	  };

	  _proto.indent = function indent() {
	    if (this.format.compact || this.format.concise) return;
	    this._indent++;
	  };

	  _proto.dedent = function dedent() {
	    if (this.format.compact || this.format.concise) return;
	    this._indent--;
	  };

	  _proto.semicolon = function semicolon(force) {
	    if (force === void 0) {
	      force = false;
	    }

	    this._maybeAddAuxComment();

	    this._append(";", !force);
	  };

	  _proto.rightBrace = function rightBrace() {
	    if (this.format.minified) {
	      this._buf.removeLastSemicolon();
	    }

	    this.token("}");
	  };

	  _proto.space = function space(force) {
	    if (force === void 0) {
	      force = false;
	    }

	    if (this.format.compact) return;

	    if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
	      this._space();
	    }
	  };

	  _proto.word = function word(str) {
	    if (this._endsWithWord || this.endsWith("/") && str.indexOf("/") === 0) {
	      this._space();
	    }

	    this._maybeAddAuxComment();

	    this._append(str);

	    this._endsWithWord = true;
	  };

	  _proto.number = function number(str) {
	    this.word(str);
	    this._endsWithInteger = (0, _isInteger.default)(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
	  };

	  _proto.token = function token(str) {
	    if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
	      this._space();
	    }

	    this._maybeAddAuxComment();

	    this._append(str);
	  };

	  _proto.newline = function newline(i) {
	    if (this.format.retainLines || this.format.compact) return;

	    if (this.format.concise) {
	      this.space();
	      return;
	    }

	    if (this.endsWith("\n\n")) return;
	    if (typeof i !== "number") i = 1;
	    i = Math.min(2, i);
	    if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
	    if (i <= 0) return;

	    for (var j = 0; j < i; j++) {
	      this._newline();
	    }
	  };

	  _proto.endsWith = function endsWith(str) {
	    return this._buf.endsWith(str);
	  };

	  _proto.removeTrailingNewline = function removeTrailingNewline() {
	    this._buf.removeTrailingNewline();
	  };

	  _proto.source = function source(prop, loc) {
	    this._catchUp(prop, loc);

	    this._buf.source(prop, loc);
	  };

	  _proto.withSource = function withSource(prop, loc, cb) {
	    this._catchUp(prop, loc);

	    this._buf.withSource(prop, loc, cb);
	  };

	  _proto._space = function _space() {
	    this._append(" ", true);
	  };

	  _proto._newline = function _newline() {
	    this._append("\n", true);
	  };

	  _proto._append = function _append(str, queue) {
	    if (queue === void 0) {
	      queue = false;
	    }

	    this._maybeAddParen(str);

	    this._maybeIndent(str);

	    if (queue) this._buf.queue(str);else this._buf.append(str);
	    this._endsWithWord = false;
	    this._endsWithInteger = false;
	  };

	  _proto._maybeIndent = function _maybeIndent(str) {
	    if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
	      this._buf.queue(this._getIndent());
	    }
	  };

	  _proto._maybeAddParen = function _maybeAddParen(str) {
	    var parenPushNewlineState = this._parenPushNewlineState;
	    if (!parenPushNewlineState) return;
	    this._parenPushNewlineState = null;
	    var i;

	    for (i = 0; i < str.length && str[i] === " "; i++) {
	      continue;
	    }

	    if (i === str.length) return;
	    var cha = str[i];

	    if (cha !== "\n") {
	      if (cha !== "/") return;
	      if (i + 1 === str.length) return;
	      var chaPost = str[i + 1];
	      if (chaPost !== "/" && chaPost !== "*") return;
	    }

	    this.token("(");
	    this.indent();
	    parenPushNewlineState.printed = true;
	  };

	  _proto._catchUp = function _catchUp(prop, loc) {
	    if (!this.format.retainLines) return;
	    var pos = loc ? loc[prop] : null;

	    if (pos && pos.line !== null) {
	      var count = pos.line - this._buf.getCurrentLine();

	      for (var i = 0; i < count; i++) {
	        this._newline();
	      }
	    }
	  };

	  _proto._getIndent = function _getIndent() {
	    return (0, _repeat.default)(this.format.indent.style, this._indent);
	  };

	  _proto.startTerminatorless = function startTerminatorless(isLabel) {
	    if (isLabel === void 0) {
	      isLabel = false;
	    }

	    if (isLabel) {
	      this._noLineTerminator = true;
	      return null;
	    } else {
	      return this._parenPushNewlineState = {
	        printed: false
	      };
	    }
	  };

	  _proto.endTerminatorless = function endTerminatorless(state) {
	    this._noLineTerminator = false;

	    if (state && state.printed) {
	      this.dedent();
	      this.newline();
	      this.token(")");
	    }
	  };

	  _proto.print = function print(node, parent) {
	    var _this = this;

	    if (!node) return;
	    var oldConcise = this.format.concise;

	    if (node._compact) {
	      this.format.concise = true;
	    }

	    var printMethod = this[node.type];

	    if (!printMethod) {
	      throw new ReferenceError("unknown node of type " + JSON.stringify(node.type) + " with constructor " + JSON.stringify(node && node.constructor.name));
	    }

	    this._printStack.push(node);

	    var oldInAux = this._insideAux;
	    this._insideAux = !node.loc;

	    this._maybeAddAuxComment(this._insideAux && !oldInAux);

	    var needsParens = n.needsParens(node, parent, this._printStack);

	    if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
	      needsParens = true;
	    }

	    if (needsParens) this.token("(");

	    this._printLeadingComments(node, parent);

	    var loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;
	    this.withSource("start", loc, function () {
	      _this[node.type](node, parent);
	    });

	    this._printTrailingComments(node, parent);

	    if (needsParens) this.token(")");

	    this._printStack.pop();

	    this.format.concise = oldConcise;
	    this._insideAux = oldInAux;
	  };

	  _proto._maybeAddAuxComment = function _maybeAddAuxComment(enteredPositionlessNode) {
	    if (enteredPositionlessNode) this._printAuxBeforeComment();
	    if (!this._insideAux) this._printAuxAfterComment();
	  };

	  _proto._printAuxBeforeComment = function _printAuxBeforeComment() {
	    if (this._printAuxAfterOnNextUserNode) return;
	    this._printAuxAfterOnNextUserNode = true;
	    var comment = this.format.auxiliaryCommentBefore;

	    if (comment) {
	      this._printComment({
	        type: "CommentBlock",
	        value: comment
	      });
	    }
	  };

	  _proto._printAuxAfterComment = function _printAuxAfterComment() {
	    if (!this._printAuxAfterOnNextUserNode) return;
	    this._printAuxAfterOnNextUserNode = false;
	    var comment = this.format.auxiliaryCommentAfter;

	    if (comment) {
	      this._printComment({
	        type: "CommentBlock",
	        value: comment
	      });
	    }
	  };

	  _proto.getPossibleRaw = function getPossibleRaw(node) {
	    var extra = node.extra;

	    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
	      return extra.raw;
	    }
	  };

	  _proto.printJoin = function printJoin(nodes, parent, opts) {
	    if (opts === void 0) {
	      opts = {};
	    }

	    if (!nodes || !nodes.length) return;
	    if (opts.indent) this.indent();
	    var newlineOpts = {
	      addNewlines: opts.addNewlines
	    };

	    for (var i = 0; i < nodes.length; i++) {
	      var node = nodes[i];
	      if (!node) continue;
	      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
	      this.print(node, parent);

	      if (opts.iterator) {
	        opts.iterator(node, i);
	      }

	      if (opts.separator && i < nodes.length - 1) {
	        opts.separator.call(this);
	      }

	      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
	    }

	    if (opts.indent) this.dedent();
	  };

	  _proto.printAndIndentOnComments = function printAndIndentOnComments(node, parent) {
	    var indent = node.leadingComments && node.leadingComments.length > 0;
	    if (indent) this.indent();
	    this.print(node, parent);
	    if (indent) this.dedent();
	  };

	  _proto.printBlock = function printBlock(parent) {
	    var node = parent.body;

	    if (!t.isEmptyStatement(node)) {
	      this.space();
	    }

	    this.print(node, parent);
	  };

	  _proto._printTrailingComments = function _printTrailingComments(node, parent) {
	    this._printComments(this._getComments(false, node, parent));
	  };

	  _proto._printLeadingComments = function _printLeadingComments(node, parent) {
	    this._printComments(this._getComments(true, node, parent));
	  };

	  _proto.printInnerComments = function printInnerComments(node, indent) {
	    if (indent === void 0) {
	      indent = true;
	    }

	    if (!node.innerComments || !node.innerComments.length) return;
	    if (indent) this.indent();

	    this._printComments(node.innerComments);

	    if (indent) this.dedent();
	  };

	  _proto.printSequence = function printSequence(nodes, parent, opts) {
	    if (opts === void 0) {
	      opts = {};
	    }

	    opts.statement = true;
	    return this.printJoin(nodes, parent, opts);
	  };

	  _proto.printList = function printList(items, parent, opts) {
	    if (opts === void 0) {
	      opts = {};
	    }

	    if (opts.separator == null) {
	      opts.separator = commaSeparator;
	    }

	    return this.printJoin(items, parent, opts);
	  };

	  _proto._printNewline = function _printNewline(leading, node, parent, opts) {
	    if (this.format.retainLines || this.format.compact) return;

	    if (this.format.concise) {
	      this.space();
	      return;
	    }

	    var lines = 0;

	    if (this._buf.hasContent()) {
	      if (!leading) lines++;
	      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
	      var needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;
	      if (needs(node, parent)) lines++;
	    }

	    this.newline(lines);
	  };

	  _proto._getComments = function _getComments(leading, node) {
	    return node && (leading ? node.leadingComments : node.trailingComments) || [];
	  };

	  _proto._printComment = function _printComment(comment) {
	    var _this2 = this;

	    if (!this.format.shouldPrintComment(comment.value)) return;
	    if (comment.ignore) return;
	    if (this._printedComments.has(comment)) return;

	    this._printedComments.add(comment);

	    if (comment.start != null) {
	      if (this._printedCommentStarts[comment.start]) return;
	      this._printedCommentStarts[comment.start] = true;
	    }

	    var isBlockComment = comment.type === "CommentBlock";
	    this.newline(this._buf.hasContent() && !this._noLineTerminator && isBlockComment ? 1 : 0);
	    if (!this.endsWith("[") && !this.endsWith("{")) this.space();
	    var val = !isBlockComment && !this._noLineTerminator ? "//" + comment.value + "\n" : "/*" + comment.value + "*/";

	    if (isBlockComment && this.format.indent.adjustMultilineComment) {
	      var offset = comment.loc && comment.loc.start.column;

	      if (offset) {
	        var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
	        val = val.replace(newlineRegex, "\n");
	      }

	      var indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());
	      val = val.replace(/\n(?!$)/g, "\n" + (0, _repeat.default)(" ", indentSize));
	    }

	    if (this.endsWith("/")) this._space();
	    this.withSource("start", comment.loc, function () {
	      _this2._append(val);
	    });
	    this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);
	  };

	  _proto._printComments = function _printComments(comments) {
	    if (!comments || !comments.length) return;

	    for (var _iterator = comments, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	      var _ref;

	      if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref = _iterator[_i++];
	      } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref = _i.value;
	      }

	      var _comment2 = _ref;

	      this._printComment(_comment2);
	    }
	  };

	  return Printer;
	}();

	exports.default = Printer;
	Object.assign(Printer.prototype, generatorFunctions);

	function commaSeparator() {
	  this.token(",");
	  this.space();
	}

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = void 0;

	var _sourceMap = _interopRequireDefault(__webpack_require__(155));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var SourceMap = function () {
	  function SourceMap(opts, code) {
	    this._cachedMap = null;
	    this._code = code;
	    this._opts = opts;
	    this._rawMappings = [];
	  }

	  var _proto = SourceMap.prototype;

	  _proto.get = function get() {
	    if (!this._cachedMap) {
	      var map = this._cachedMap = new _sourceMap.default.SourceMapGenerator({
	        file: this._opts.sourceMapTarget,
	        sourceRoot: this._opts.sourceRoot
	      });
	      var code = this._code;

	      if (typeof code === "string") {
	        map.setSourceContent(this._opts.sourceFileName, code);
	      } else if (typeof code === "object") {
	        Object.keys(code).forEach(function (sourceFileName) {
	          map.setSourceContent(sourceFileName, code[sourceFileName]);
	        });
	      }

	      this._rawMappings.forEach(map.addMapping, map);
	    }

	    return this._cachedMap.toJSON();
	  };

	  _proto.getRawMappings = function getRawMappings() {
	    return this._rawMappings.slice();
	  };

	  _proto.mark = function mark(generatedLine, generatedColumn, line, column, identifierName, filename) {
	    if (this._lastGenLine !== generatedLine && line === null) return;

	    if (this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
	      return;
	    }

	    this._cachedMap = null;
	    this._lastGenLine = generatedLine;
	    this._lastSourceLine = line;
	    this._lastSourceColumn = column;

	    this._rawMappings.push({
	      name: identifierName || undefined,
	      generated: {
	        line: generatedLine,
	        column: generatedColumn
	      },
	      source: line == null ? undefined : filename || this._opts.sourceFileName,
	      original: line == null ? undefined : {
	        line: line,
	        column: column
	      }
	    });
	  };

	  return SourceMap;
	}();

	exports.default = SourceMap;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = assertNode;

	var _isNode = _interopRequireDefault(__webpack_require__(57));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function assertNode(node) {
	  if (!(0, _isNode.default)(node)) {
	    var type = node && node.type || JSON.stringify(node);
	    throw new TypeError("Not a valid node of type \"" + type + "\"");
	  }
	}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.assertArrayExpression = assertArrayExpression;
	exports.assertAssignmentExpression = assertAssignmentExpression;
	exports.assertBinaryExpression = assertBinaryExpression;
	exports.assertDirective = assertDirective;
	exports.assertDirectiveLiteral = assertDirectiveLiteral;
	exports.assertBlockStatement = assertBlockStatement;
	exports.assertBreakStatement = assertBreakStatement;
	exports.assertCallExpression = assertCallExpression;
	exports.assertCatchClause = assertCatchClause;
	exports.assertConditionalExpression = assertConditionalExpression;
	exports.assertContinueStatement = assertContinueStatement;
	exports.assertDebuggerStatement = assertDebuggerStatement;
	exports.assertDoWhileStatement = assertDoWhileStatement;
	exports.assertEmptyStatement = assertEmptyStatement;
	exports.assertExpressionStatement = assertExpressionStatement;
	exports.assertFile = assertFile;
	exports.assertForInStatement = assertForInStatement;
	exports.assertForStatement = assertForStatement;
	exports.assertFunctionDeclaration = assertFunctionDeclaration;
	exports.assertFunctionExpression = assertFunctionExpression;
	exports.assertIdentifier = assertIdentifier;
	exports.assertIfStatement = assertIfStatement;
	exports.assertLabeledStatement = assertLabeledStatement;
	exports.assertStringLiteral = assertStringLiteral;
	exports.assertNumericLiteral = assertNumericLiteral;
	exports.assertNullLiteral = assertNullLiteral;
	exports.assertBooleanLiteral = assertBooleanLiteral;
	exports.assertRegExpLiteral = assertRegExpLiteral;
	exports.assertLogicalExpression = assertLogicalExpression;
	exports.assertMemberExpression = assertMemberExpression;
	exports.assertNewExpression = assertNewExpression;
	exports.assertProgram = assertProgram;
	exports.assertObjectExpression = assertObjectExpression;
	exports.assertObjectMethod = assertObjectMethod;
	exports.assertObjectProperty = assertObjectProperty;
	exports.assertRestElement = assertRestElement;
	exports.assertReturnStatement = assertReturnStatement;
	exports.assertSequenceExpression = assertSequenceExpression;
	exports.assertSwitchCase = assertSwitchCase;
	exports.assertSwitchStatement = assertSwitchStatement;
	exports.assertThisExpression = assertThisExpression;
	exports.assertThrowStatement = assertThrowStatement;
	exports.assertTryStatement = assertTryStatement;
	exports.assertUnaryExpression = assertUnaryExpression;
	exports.assertUpdateExpression = assertUpdateExpression;
	exports.assertVariableDeclaration = assertVariableDeclaration;
	exports.assertVariableDeclarator = assertVariableDeclarator;
	exports.assertWhileStatement = assertWhileStatement;
	exports.assertWithStatement = assertWithStatement;
	exports.assertAssignmentPattern = assertAssignmentPattern;
	exports.assertArrayPattern = assertArrayPattern;
	exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
	exports.assertClassBody = assertClassBody;
	exports.assertClassDeclaration = assertClassDeclaration;
	exports.assertClassExpression = assertClassExpression;
	exports.assertExportAllDeclaration = assertExportAllDeclaration;
	exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
	exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
	exports.assertExportSpecifier = assertExportSpecifier;
	exports.assertForOfStatement = assertForOfStatement;
	exports.assertImportDeclaration = assertImportDeclaration;
	exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
	exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
	exports.assertImportSpecifier = assertImportSpecifier;
	exports.assertMetaProperty = assertMetaProperty;
	exports.assertClassMethod = assertClassMethod;
	exports.assertObjectPattern = assertObjectPattern;
	exports.assertSpreadElement = assertSpreadElement;
	exports.assertSuper = assertSuper;
	exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
	exports.assertTemplateElement = assertTemplateElement;
	exports.assertTemplateLiteral = assertTemplateLiteral;
	exports.assertYieldExpression = assertYieldExpression;
	exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
	exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
	exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
	exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
	exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
	exports.assertClassImplements = assertClassImplements;
	exports.assertDeclareClass = assertDeclareClass;
	exports.assertDeclareFunction = assertDeclareFunction;
	exports.assertDeclareInterface = assertDeclareInterface;
	exports.assertDeclareModule = assertDeclareModule;
	exports.assertDeclareModuleExports = assertDeclareModuleExports;
	exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
	exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
	exports.assertDeclareVariable = assertDeclareVariable;
	exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
	exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
	exports.assertDeclaredPredicate = assertDeclaredPredicate;
	exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
	exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
	exports.assertFunctionTypeParam = assertFunctionTypeParam;
	exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
	exports.assertInferredPredicate = assertInferredPredicate;
	exports.assertInterfaceExtends = assertInterfaceExtends;
	exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
	exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
	exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
	exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
	exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
	exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
	exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
	exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
	exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
	exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
	exports.assertObjectTypeProperty = assertObjectTypeProperty;
	exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
	exports.assertOpaqueType = assertOpaqueType;
	exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
	exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
	exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
	exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
	exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
	exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
	exports.assertTypeAlias = assertTypeAlias;
	exports.assertTypeAnnotation = assertTypeAnnotation;
	exports.assertTypeCastExpression = assertTypeCastExpression;
	exports.assertTypeParameter = assertTypeParameter;
	exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
	exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
	exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
	exports.assertVariance = assertVariance;
	exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
	exports.assertJSXAttribute = assertJSXAttribute;
	exports.assertJSXClosingElement = assertJSXClosingElement;
	exports.assertJSXElement = assertJSXElement;
	exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
	exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
	exports.assertJSXSpreadChild = assertJSXSpreadChild;
	exports.assertJSXIdentifier = assertJSXIdentifier;
	exports.assertJSXMemberExpression = assertJSXMemberExpression;
	exports.assertJSXNamespacedName = assertJSXNamespacedName;
	exports.assertJSXOpeningElement = assertJSXOpeningElement;
	exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
	exports.assertJSXText = assertJSXText;
	exports.assertJSXFragment = assertJSXFragment;
	exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
	exports.assertJSXClosingFragment = assertJSXClosingFragment;
	exports.assertNoop = assertNoop;
	exports.assertParenthesizedExpression = assertParenthesizedExpression;
	exports.assertAwaitExpression = assertAwaitExpression;
	exports.assertBindExpression = assertBindExpression;
	exports.assertClassProperty = assertClassProperty;
	exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
	exports.assertOptionalCallExpression = assertOptionalCallExpression;
	exports.assertImport = assertImport;
	exports.assertDecorator = assertDecorator;
	exports.assertDoExpression = assertDoExpression;
	exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
	exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
	exports.assertTSParameterProperty = assertTSParameterProperty;
	exports.assertTSDeclareFunction = assertTSDeclareFunction;
	exports.assertTSDeclareMethod = assertTSDeclareMethod;
	exports.assertTSQualifiedName = assertTSQualifiedName;
	exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
	exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
	exports.assertTSPropertySignature = assertTSPropertySignature;
	exports.assertTSMethodSignature = assertTSMethodSignature;
	exports.assertTSIndexSignature = assertTSIndexSignature;
	exports.assertTSAnyKeyword = assertTSAnyKeyword;
	exports.assertTSNumberKeyword = assertTSNumberKeyword;
	exports.assertTSObjectKeyword = assertTSObjectKeyword;
	exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
	exports.assertTSStringKeyword = assertTSStringKeyword;
	exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
	exports.assertTSVoidKeyword = assertTSVoidKeyword;
	exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
	exports.assertTSNullKeyword = assertTSNullKeyword;
	exports.assertTSNeverKeyword = assertTSNeverKeyword;
	exports.assertTSThisType = assertTSThisType;
	exports.assertTSFunctionType = assertTSFunctionType;
	exports.assertTSConstructorType = assertTSConstructorType;
	exports.assertTSTypeReference = assertTSTypeReference;
	exports.assertTSTypePredicate = assertTSTypePredicate;
	exports.assertTSTypeQuery = assertTSTypeQuery;
	exports.assertTSTypeLiteral = assertTSTypeLiteral;
	exports.assertTSArrayType = assertTSArrayType;
	exports.assertTSTupleType = assertTSTupleType;
	exports.assertTSUnionType = assertTSUnionType;
	exports.assertTSIntersectionType = assertTSIntersectionType;
	exports.assertTSParenthesizedType = assertTSParenthesizedType;
	exports.assertTSTypeOperator = assertTSTypeOperator;
	exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
	exports.assertTSMappedType = assertTSMappedType;
	exports.assertTSLiteralType = assertTSLiteralType;
	exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
	exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
	exports.assertTSInterfaceBody = assertTSInterfaceBody;
	exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
	exports.assertTSAsExpression = assertTSAsExpression;
	exports.assertTSTypeAssertion = assertTSTypeAssertion;
	exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
	exports.assertTSEnumMember = assertTSEnumMember;
	exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
	exports.assertTSModuleBlock = assertTSModuleBlock;
	exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
	exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
	exports.assertTSNonNullExpression = assertTSNonNullExpression;
	exports.assertTSExportAssignment = assertTSExportAssignment;
	exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
	exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
	exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
	exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
	exports.assertTSTypeParameter = assertTSTypeParameter;
	exports.assertExpression = assertExpression;
	exports.assertBinary = assertBinary;
	exports.assertScopable = assertScopable;
	exports.assertBlockParent = assertBlockParent;
	exports.assertBlock = assertBlock;
	exports.assertStatement = assertStatement;
	exports.assertTerminatorless = assertTerminatorless;
	exports.assertCompletionStatement = assertCompletionStatement;
	exports.assertConditional = assertConditional;
	exports.assertLoop = assertLoop;
	exports.assertWhile = assertWhile;
	exports.assertExpressionWrapper = assertExpressionWrapper;
	exports.assertFor = assertFor;
	exports.assertForXStatement = assertForXStatement;
	exports.assertFunction = assertFunction;
	exports.assertFunctionParent = assertFunctionParent;
	exports.assertPureish = assertPureish;
	exports.assertDeclaration = assertDeclaration;
	exports.assertPatternLike = assertPatternLike;
	exports.assertLVal = assertLVal;
	exports.assertTSEntityName = assertTSEntityName;
	exports.assertLiteral = assertLiteral;
	exports.assertImmutable = assertImmutable;
	exports.assertUserWhitespacable = assertUserWhitespacable;
	exports.assertMethod = assertMethod;
	exports.assertObjectMember = assertObjectMember;
	exports.assertProperty = assertProperty;
	exports.assertUnaryLike = assertUnaryLike;
	exports.assertPattern = assertPattern;
	exports.assertClass = assertClass;
	exports.assertModuleDeclaration = assertModuleDeclaration;
	exports.assertExportDeclaration = assertExportDeclaration;
	exports.assertModuleSpecifier = assertModuleSpecifier;
	exports.assertFlow = assertFlow;
	exports.assertFlowType = assertFlowType;
	exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
	exports.assertFlowDeclaration = assertFlowDeclaration;
	exports.assertFlowPredicate = assertFlowPredicate;
	exports.assertJSX = assertJSX;
	exports.assertTSTypeElement = assertTSTypeElement;
	exports.assertTSType = assertTSType;
	exports.assertNumberLiteral = assertNumberLiteral;
	exports.assertRegexLiteral = assertRegexLiteral;
	exports.assertRestProperty = assertRestProperty;
	exports.assertSpreadProperty = assertSpreadProperty;

	var _is = _interopRequireDefault(__webpack_require__(20));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function assert(type, node, opts) {
	  if (!(0, _is.default)(type, node, opts)) {
	    throw new Error("Expected type \"" + type + "\" with option " + JSON.stringify(opts) + ", but instead got \"" + node.type + "\".");
	  }
	}

	function assertArrayExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ArrayExpression", node, opts);
	}

	function assertAssignmentExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("AssignmentExpression", node, opts);
	}

	function assertBinaryExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("BinaryExpression", node, opts);
	}

	function assertDirective(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Directive", node, opts);
	}

	function assertDirectiveLiteral(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DirectiveLiteral", node, opts);
	}

	function assertBlockStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("BlockStatement", node, opts);
	}

	function assertBreakStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("BreakStatement", node, opts);
	}

	function assertCallExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("CallExpression", node, opts);
	}

	function assertCatchClause(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("CatchClause", node, opts);
	}

	function assertConditionalExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ConditionalExpression", node, opts);
	}

	function assertContinueStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ContinueStatement", node, opts);
	}

	function assertDebuggerStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DebuggerStatement", node, opts);
	}

	function assertDoWhileStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DoWhileStatement", node, opts);
	}

	function assertEmptyStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("EmptyStatement", node, opts);
	}

	function assertExpressionStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ExpressionStatement", node, opts);
	}

	function assertFile(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("File", node, opts);
	}

	function assertForInStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ForInStatement", node, opts);
	}

	function assertForStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ForStatement", node, opts);
	}

	function assertFunctionDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("FunctionDeclaration", node, opts);
	}

	function assertFunctionExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("FunctionExpression", node, opts);
	}

	function assertIdentifier(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Identifier", node, opts);
	}

	function assertIfStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("IfStatement", node, opts);
	}

	function assertLabeledStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("LabeledStatement", node, opts);
	}

	function assertStringLiteral(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("StringLiteral", node, opts);
	}

	function assertNumericLiteral(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("NumericLiteral", node, opts);
	}

	function assertNullLiteral(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("NullLiteral", node, opts);
	}

	function assertBooleanLiteral(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("BooleanLiteral", node, opts);
	}

	function assertRegExpLiteral(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("RegExpLiteral", node, opts);
	}

	function assertLogicalExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("LogicalExpression", node, opts);
	}

	function assertMemberExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("MemberExpression", node, opts);
	}

	function assertNewExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("NewExpression", node, opts);
	}

	function assertProgram(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Program", node, opts);
	}

	function assertObjectExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ObjectExpression", node, opts);
	}

	function assertObjectMethod(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ObjectMethod", node, opts);
	}

	function assertObjectProperty(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ObjectProperty", node, opts);
	}

	function assertRestElement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("RestElement", node, opts);
	}

	function assertReturnStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ReturnStatement", node, opts);
	}

	function assertSequenceExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("SequenceExpression", node, opts);
	}

	function assertSwitchCase(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("SwitchCase", node, opts);
	}

	function assertSwitchStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("SwitchStatement", node, opts);
	}

	function assertThisExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ThisExpression", node, opts);
	}

	function assertThrowStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ThrowStatement", node, opts);
	}

	function assertTryStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TryStatement", node, opts);
	}

	function assertUnaryExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("UnaryExpression", node, opts);
	}

	function assertUpdateExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("UpdateExpression", node, opts);
	}

	function assertVariableDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("VariableDeclaration", node, opts);
	}

	function assertVariableDeclarator(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("VariableDeclarator", node, opts);
	}

	function assertWhileStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("WhileStatement", node, opts);
	}

	function assertWithStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("WithStatement", node, opts);
	}

	function assertAssignmentPattern(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("AssignmentPattern", node, opts);
	}

	function assertArrayPattern(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ArrayPattern", node, opts);
	}

	function assertArrowFunctionExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ArrowFunctionExpression", node, opts);
	}

	function assertClassBody(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ClassBody", node, opts);
	}

	function assertClassDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ClassDeclaration", node, opts);
	}

	function assertClassExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ClassExpression", node, opts);
	}

	function assertExportAllDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ExportAllDeclaration", node, opts);
	}

	function assertExportDefaultDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ExportDefaultDeclaration", node, opts);
	}

	function assertExportNamedDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ExportNamedDeclaration", node, opts);
	}

	function assertExportSpecifier(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ExportSpecifier", node, opts);
	}

	function assertForOfStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ForOfStatement", node, opts);
	}

	function assertImportDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ImportDeclaration", node, opts);
	}

	function assertImportDefaultSpecifier(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ImportDefaultSpecifier", node, opts);
	}

	function assertImportNamespaceSpecifier(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ImportNamespaceSpecifier", node, opts);
	}

	function assertImportSpecifier(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ImportSpecifier", node, opts);
	}

	function assertMetaProperty(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("MetaProperty", node, opts);
	}

	function assertClassMethod(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ClassMethod", node, opts);
	}

	function assertObjectPattern(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ObjectPattern", node, opts);
	}

	function assertSpreadElement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("SpreadElement", node, opts);
	}

	function assertSuper(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Super", node, opts);
	}

	function assertTaggedTemplateExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TaggedTemplateExpression", node, opts);
	}

	function assertTemplateElement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TemplateElement", node, opts);
	}

	function assertTemplateLiteral(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TemplateLiteral", node, opts);
	}

	function assertYieldExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("YieldExpression", node, opts);
	}

	function assertAnyTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("AnyTypeAnnotation", node, opts);
	}

	function assertArrayTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ArrayTypeAnnotation", node, opts);
	}

	function assertBooleanTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("BooleanTypeAnnotation", node, opts);
	}

	function assertBooleanLiteralTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("BooleanLiteralTypeAnnotation", node, opts);
	}

	function assertNullLiteralTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("NullLiteralTypeAnnotation", node, opts);
	}

	function assertClassImplements(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ClassImplements", node, opts);
	}

	function assertDeclareClass(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DeclareClass", node, opts);
	}

	function assertDeclareFunction(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DeclareFunction", node, opts);
	}

	function assertDeclareInterface(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DeclareInterface", node, opts);
	}

	function assertDeclareModule(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DeclareModule", node, opts);
	}

	function assertDeclareModuleExports(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DeclareModuleExports", node, opts);
	}

	function assertDeclareTypeAlias(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DeclareTypeAlias", node, opts);
	}

	function assertDeclareOpaqueType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DeclareOpaqueType", node, opts);
	}

	function assertDeclareVariable(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DeclareVariable", node, opts);
	}

	function assertDeclareExportDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DeclareExportDeclaration", node, opts);
	}

	function assertDeclareExportAllDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DeclareExportAllDeclaration", node, opts);
	}

	function assertDeclaredPredicate(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DeclaredPredicate", node, opts);
	}

	function assertExistsTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ExistsTypeAnnotation", node, opts);
	}

	function assertFunctionTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("FunctionTypeAnnotation", node, opts);
	}

	function assertFunctionTypeParam(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("FunctionTypeParam", node, opts);
	}

	function assertGenericTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("GenericTypeAnnotation", node, opts);
	}

	function assertInferredPredicate(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("InferredPredicate", node, opts);
	}

	function assertInterfaceExtends(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("InterfaceExtends", node, opts);
	}

	function assertInterfaceDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("InterfaceDeclaration", node, opts);
	}

	function assertIntersectionTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("IntersectionTypeAnnotation", node, opts);
	}

	function assertMixedTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("MixedTypeAnnotation", node, opts);
	}

	function assertEmptyTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("EmptyTypeAnnotation", node, opts);
	}

	function assertNullableTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("NullableTypeAnnotation", node, opts);
	}

	function assertNumberLiteralTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("NumberLiteralTypeAnnotation", node, opts);
	}

	function assertNumberTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("NumberTypeAnnotation", node, opts);
	}

	function assertObjectTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ObjectTypeAnnotation", node, opts);
	}

	function assertObjectTypeCallProperty(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ObjectTypeCallProperty", node, opts);
	}

	function assertObjectTypeIndexer(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ObjectTypeIndexer", node, opts);
	}

	function assertObjectTypeProperty(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ObjectTypeProperty", node, opts);
	}

	function assertObjectTypeSpreadProperty(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ObjectTypeSpreadProperty", node, opts);
	}

	function assertOpaqueType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("OpaqueType", node, opts);
	}

	function assertQualifiedTypeIdentifier(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("QualifiedTypeIdentifier", node, opts);
	}

	function assertStringLiteralTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("StringLiteralTypeAnnotation", node, opts);
	}

	function assertStringTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("StringTypeAnnotation", node, opts);
	}

	function assertThisTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ThisTypeAnnotation", node, opts);
	}

	function assertTupleTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TupleTypeAnnotation", node, opts);
	}

	function assertTypeofTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TypeofTypeAnnotation", node, opts);
	}

	function assertTypeAlias(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TypeAlias", node, opts);
	}

	function assertTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TypeAnnotation", node, opts);
	}

	function assertTypeCastExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TypeCastExpression", node, opts);
	}

	function assertTypeParameter(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TypeParameter", node, opts);
	}

	function assertTypeParameterDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TypeParameterDeclaration", node, opts);
	}

	function assertTypeParameterInstantiation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TypeParameterInstantiation", node, opts);
	}

	function assertUnionTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("UnionTypeAnnotation", node, opts);
	}

	function assertVariance(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Variance", node, opts);
	}

	function assertVoidTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("VoidTypeAnnotation", node, opts);
	}

	function assertJSXAttribute(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXAttribute", node, opts);
	}

	function assertJSXClosingElement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXClosingElement", node, opts);
	}

	function assertJSXElement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXElement", node, opts);
	}

	function assertJSXEmptyExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXEmptyExpression", node, opts);
	}

	function assertJSXExpressionContainer(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXExpressionContainer", node, opts);
	}

	function assertJSXSpreadChild(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXSpreadChild", node, opts);
	}

	function assertJSXIdentifier(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXIdentifier", node, opts);
	}

	function assertJSXMemberExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXMemberExpression", node, opts);
	}

	function assertJSXNamespacedName(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXNamespacedName", node, opts);
	}

	function assertJSXOpeningElement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXOpeningElement", node, opts);
	}

	function assertJSXSpreadAttribute(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXSpreadAttribute", node, opts);
	}

	function assertJSXText(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXText", node, opts);
	}

	function assertJSXFragment(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXFragment", node, opts);
	}

	function assertJSXOpeningFragment(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXOpeningFragment", node, opts);
	}

	function assertJSXClosingFragment(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSXClosingFragment", node, opts);
	}

	function assertNoop(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Noop", node, opts);
	}

	function assertParenthesizedExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ParenthesizedExpression", node, opts);
	}

	function assertAwaitExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("AwaitExpression", node, opts);
	}

	function assertBindExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("BindExpression", node, opts);
	}

	function assertClassProperty(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ClassProperty", node, opts);
	}

	function assertOptionalMemberExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("OptionalMemberExpression", node, opts);
	}

	function assertOptionalCallExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("OptionalCallExpression", node, opts);
	}

	function assertImport(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Import", node, opts);
	}

	function assertDecorator(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Decorator", node, opts);
	}

	function assertDoExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("DoExpression", node, opts);
	}

	function assertExportDefaultSpecifier(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ExportDefaultSpecifier", node, opts);
	}

	function assertExportNamespaceSpecifier(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ExportNamespaceSpecifier", node, opts);
	}

	function assertTSParameterProperty(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSParameterProperty", node, opts);
	}

	function assertTSDeclareFunction(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSDeclareFunction", node, opts);
	}

	function assertTSDeclareMethod(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSDeclareMethod", node, opts);
	}

	function assertTSQualifiedName(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSQualifiedName", node, opts);
	}

	function assertTSCallSignatureDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSCallSignatureDeclaration", node, opts);
	}

	function assertTSConstructSignatureDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSConstructSignatureDeclaration", node, opts);
	}

	function assertTSPropertySignature(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSPropertySignature", node, opts);
	}

	function assertTSMethodSignature(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSMethodSignature", node, opts);
	}

	function assertTSIndexSignature(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSIndexSignature", node, opts);
	}

	function assertTSAnyKeyword(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSAnyKeyword", node, opts);
	}

	function assertTSNumberKeyword(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSNumberKeyword", node, opts);
	}

	function assertTSObjectKeyword(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSObjectKeyword", node, opts);
	}

	function assertTSBooleanKeyword(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSBooleanKeyword", node, opts);
	}

	function assertTSStringKeyword(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSStringKeyword", node, opts);
	}

	function assertTSSymbolKeyword(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSSymbolKeyword", node, opts);
	}

	function assertTSVoidKeyword(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSVoidKeyword", node, opts);
	}

	function assertTSUndefinedKeyword(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSUndefinedKeyword", node, opts);
	}

	function assertTSNullKeyword(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSNullKeyword", node, opts);
	}

	function assertTSNeverKeyword(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSNeverKeyword", node, opts);
	}

	function assertTSThisType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSThisType", node, opts);
	}

	function assertTSFunctionType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSFunctionType", node, opts);
	}

	function assertTSConstructorType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSConstructorType", node, opts);
	}

	function assertTSTypeReference(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypeReference", node, opts);
	}

	function assertTSTypePredicate(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypePredicate", node, opts);
	}

	function assertTSTypeQuery(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypeQuery", node, opts);
	}

	function assertTSTypeLiteral(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypeLiteral", node, opts);
	}

	function assertTSArrayType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSArrayType", node, opts);
	}

	function assertTSTupleType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTupleType", node, opts);
	}

	function assertTSUnionType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSUnionType", node, opts);
	}

	function assertTSIntersectionType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSIntersectionType", node, opts);
	}

	function assertTSParenthesizedType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSParenthesizedType", node, opts);
	}

	function assertTSTypeOperator(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypeOperator", node, opts);
	}

	function assertTSIndexedAccessType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSIndexedAccessType", node, opts);
	}

	function assertTSMappedType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSMappedType", node, opts);
	}

	function assertTSLiteralType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSLiteralType", node, opts);
	}

	function assertTSExpressionWithTypeArguments(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSExpressionWithTypeArguments", node, opts);
	}

	function assertTSInterfaceDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSInterfaceDeclaration", node, opts);
	}

	function assertTSInterfaceBody(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSInterfaceBody", node, opts);
	}

	function assertTSTypeAliasDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypeAliasDeclaration", node, opts);
	}

	function assertTSAsExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSAsExpression", node, opts);
	}

	function assertTSTypeAssertion(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypeAssertion", node, opts);
	}

	function assertTSEnumDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSEnumDeclaration", node, opts);
	}

	function assertTSEnumMember(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSEnumMember", node, opts);
	}

	function assertTSModuleDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSModuleDeclaration", node, opts);
	}

	function assertTSModuleBlock(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSModuleBlock", node, opts);
	}

	function assertTSImportEqualsDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSImportEqualsDeclaration", node, opts);
	}

	function assertTSExternalModuleReference(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSExternalModuleReference", node, opts);
	}

	function assertTSNonNullExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSNonNullExpression", node, opts);
	}

	function assertTSExportAssignment(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSExportAssignment", node, opts);
	}

	function assertTSNamespaceExportDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSNamespaceExportDeclaration", node, opts);
	}

	function assertTSTypeAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypeAnnotation", node, opts);
	}

	function assertTSTypeParameterInstantiation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypeParameterInstantiation", node, opts);
	}

	function assertTSTypeParameterDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypeParameterDeclaration", node, opts);
	}

	function assertTSTypeParameter(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypeParameter", node, opts);
	}

	function assertExpression(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Expression", node, opts);
	}

	function assertBinary(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Binary", node, opts);
	}

	function assertScopable(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Scopable", node, opts);
	}

	function assertBlockParent(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("BlockParent", node, opts);
	}

	function assertBlock(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Block", node, opts);
	}

	function assertStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Statement", node, opts);
	}

	function assertTerminatorless(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Terminatorless", node, opts);
	}

	function assertCompletionStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("CompletionStatement", node, opts);
	}

	function assertConditional(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Conditional", node, opts);
	}

	function assertLoop(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Loop", node, opts);
	}

	function assertWhile(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("While", node, opts);
	}

	function assertExpressionWrapper(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ExpressionWrapper", node, opts);
	}

	function assertFor(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("For", node, opts);
	}

	function assertForXStatement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ForXStatement", node, opts);
	}

	function assertFunction(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Function", node, opts);
	}

	function assertFunctionParent(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("FunctionParent", node, opts);
	}

	function assertPureish(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Pureish", node, opts);
	}

	function assertDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Declaration", node, opts);
	}

	function assertPatternLike(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("PatternLike", node, opts);
	}

	function assertLVal(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("LVal", node, opts);
	}

	function assertTSEntityName(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSEntityName", node, opts);
	}

	function assertLiteral(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Literal", node, opts);
	}

	function assertImmutable(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Immutable", node, opts);
	}

	function assertUserWhitespacable(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("UserWhitespacable", node, opts);
	}

	function assertMethod(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Method", node, opts);
	}

	function assertObjectMember(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ObjectMember", node, opts);
	}

	function assertProperty(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Property", node, opts);
	}

	function assertUnaryLike(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("UnaryLike", node, opts);
	}

	function assertPattern(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Pattern", node, opts);
	}

	function assertClass(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Class", node, opts);
	}

	function assertModuleDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ModuleDeclaration", node, opts);
	}

	function assertExportDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ExportDeclaration", node, opts);
	}

	function assertModuleSpecifier(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("ModuleSpecifier", node, opts);
	}

	function assertFlow(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("Flow", node, opts);
	}

	function assertFlowType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("FlowType", node, opts);
	}

	function assertFlowBaseAnnotation(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("FlowBaseAnnotation", node, opts);
	}

	function assertFlowDeclaration(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("FlowDeclaration", node, opts);
	}

	function assertFlowPredicate(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("FlowPredicate", node, opts);
	}

	function assertJSX(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("JSX", node, opts);
	}

	function assertTSTypeElement(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSTypeElement", node, opts);
	}

	function assertTSType(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  assert("TSType", node, opts);
	}

	function assertNumberLiteral(node, opts) {
	  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
	  assert("NumberLiteral", node, opts);
	}

	function assertRegexLiteral(node, opts) {
	  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
	  assert("RegexLiteral", node, opts);
	}

	function assertRestProperty(node, opts) {
	  console.trace("The node type RestProperty has been renamed to RestElement");
	  assert("RestProperty", node, opts);
	}

	function assertSpreadProperty(node, opts) {
	  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
	  assert("SpreadProperty", node, opts);
	}

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = builder;

	var _clone = _interopRequireDefault(__webpack_require__(148));

	var _definitions = __webpack_require__(11);

	var _validate = _interopRequireDefault(__webpack_require__(59));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function builder(type) {
	  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }

	  var keys = _definitions.BUILDER_KEYS[type];
	  var countArgs = args.length;

	  if (countArgs > keys.length) {
	    throw new Error(type + ": Too many arguments passed. Received " + countArgs + " but can receive no more than " + keys.length);
	  }

	  var node = {
	    type: type
	  };
	  var i = 0;
	  keys.forEach(function (key) {
	    var field = _definitions.NODE_FIELDS[type][key];
	    var arg;
	    if (i < countArgs) arg = args[i];
	    if (arg === undefined) arg = (0, _clone.default)(field.default);
	    node[key] = arg;
	    i++;
	  });

	  for (var key in node) {
	    (0, _validate.default)(node, key, node[key]);
	  }

	  return node;
	}

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = createTypeAnnotationBasedOnTypeof;

	var _generated = __webpack_require__(9);

	function createTypeAnnotationBasedOnTypeof(type) {
	  if (type === "string") {
	    return (0, _generated.stringTypeAnnotation)();
	  } else if (type === "number") {
	    return (0, _generated.numberTypeAnnotation)();
	  } else if (type === "undefined") {
	    return (0, _generated.voidTypeAnnotation)();
	  } else if (type === "boolean") {
	    return (0, _generated.booleanTypeAnnotation)();
	  } else if (type === "function") {
	    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
	  } else if (type === "object") {
	    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
	  } else if (type === "symbol") {
	    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
	  } else {
	    throw new Error("Invalid typeof value");
	  }
	}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = createUnionTypeAnnotation;

	var _generated = __webpack_require__(9);

	var _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(50));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function createUnionTypeAnnotation(types) {
	  var flattened = (0, _removeTypeDuplicates.default)(types);

	  if (flattened.length === 1) {
	    return flattened[0];
	  } else {
	    return (0, _generated.unionTypeAnnotation)(flattened);
	  }
	}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = buildChildren;

	var _generated = __webpack_require__(5);

	var _cleanJSXElementLiteralChild = _interopRequireDefault(__webpack_require__(128));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function buildChildren(node) {
	  var elements = [];

	  for (var i = 0; i < node.children.length; i++) {
	    var child = node.children[i];

	    if ((0, _generated.isJSXText)(child)) {
	      (0, _cleanJSXElementLiteralChild.default)(child, elements);
	      continue;
	    }

	    if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;
	    if ((0, _generated.isJSXEmptyExpression)(child)) continue;
	    elements.push(child);
	  }

	  return elements;
	}

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = cloneDeep;

	var _cloneNode = _interopRequireDefault(__webpack_require__(16));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function cloneDeep(node) {
	  return (0, _cloneNode.default)(node);
	}

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = cloneWithoutLoc;

	var _clone = _interopRequireDefault(__webpack_require__(42));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function cloneWithoutLoc(node) {
	  var newNode = (0, _clone.default)(node);
	  newNode.loc = null;
	  return newNode;
	}

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = addComment;

	var _addComments = _interopRequireDefault(__webpack_require__(43));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function addComment(node, type, content, line) {
	  return (0, _addComments.default)(node, type, [{
	    type: line ? "CommentLine" : "CommentBlock",
	    value: content
	  }]);
	}

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = removeComments;

	var _constants = __webpack_require__(13);

	function removeComments(node) {
	  _constants.COMMENT_KEYS.forEach(function (key) {
	    node[key] = null;
	  });

	  return node;
	}

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.JSX_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;

	var _definitions = __webpack_require__(11);

	var EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
	exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
	var BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
	exports.BINARY_TYPES = BINARY_TYPES;
	var SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
	exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
	var BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
	exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
	var BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
	exports.BLOCK_TYPES = BLOCK_TYPES;
	var STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
	exports.STATEMENT_TYPES = STATEMENT_TYPES;
	var TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
	exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
	var COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
	exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
	var CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
	exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
	var LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
	exports.LOOP_TYPES = LOOP_TYPES;
	var WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
	exports.WHILE_TYPES = WHILE_TYPES;
	var EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
	exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
	var FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
	exports.FOR_TYPES = FOR_TYPES;
	var FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
	exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
	var FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
	exports.FUNCTION_TYPES = FUNCTION_TYPES;
	var FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
	exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
	var PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
	exports.PUREISH_TYPES = PUREISH_TYPES;
	var DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
	exports.DECLARATION_TYPES = DECLARATION_TYPES;
	var PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
	exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
	var LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
	exports.LVAL_TYPES = LVAL_TYPES;
	var TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
	exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
	var LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
	exports.LITERAL_TYPES = LITERAL_TYPES;
	var IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
	exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
	var USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
	exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
	var METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
	exports.METHOD_TYPES = METHOD_TYPES;
	var OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
	exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
	var PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
	exports.PROPERTY_TYPES = PROPERTY_TYPES;
	var UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
	exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
	var PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
	exports.PATTERN_TYPES = PATTERN_TYPES;
	var CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
	exports.CLASS_TYPES = CLASS_TYPES;
	var MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
	exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
	var EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
	exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
	var MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
	exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
	var FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
	exports.FLOW_TYPES = FLOW_TYPES;
	var FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
	exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
	var FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
	exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
	var FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
	exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
	var FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
	exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
	var JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
	exports.JSX_TYPES = JSX_TYPES;
	var TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
	exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
	var TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
	exports.TSTYPE_TYPES = TSTYPE_TYPES;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = ensureBlock;

	var _toBlock = _interopRequireDefault(__webpack_require__(48));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function ensureBlock(node, key) {
	  if (key === void 0) {
	    key = "body";
	  }

	  return node[key] = (0, _toBlock.default)(node[key], node);
	}

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = gatherSequenceExpressions;

	var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(19));

	var _generated = __webpack_require__(5);

	var _generated2 = __webpack_require__(9);

	var _cloneNode = _interopRequireDefault(__webpack_require__(16));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function gatherSequenceExpressions(nodes, scope, declars) {
	  var exprs = [];
	  var ensureLastUndefined = true;

	  for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref;

	    if (_isArray) {
	      if (_i >= _iterator.length) break;
	      _ref = _iterator[_i++];
	    } else {
	      _i = _iterator.next();
	      if (_i.done) break;
	      _ref = _i.value;
	    }

	    var _node = _ref;
	    ensureLastUndefined = false;

	    if ((0, _generated.isExpression)(_node)) {
	      exprs.push(_node);
	    } else if ((0, _generated.isExpressionStatement)(_node)) {
	      exprs.push(_node.expression);
	    } else if ((0, _generated.isVariableDeclaration)(_node)) {
	      if (_node.kind !== "var") return;
	      var _arr = _node.declarations;

	      for (var _i2 = 0; _i2 < _arr.length; _i2++) {
	        var declar = _arr[_i2];
	        var bindings = (0, _getBindingIdentifiers.default)(declar);

	        for (var key in bindings) {
	          declars.push({
	            kind: _node.kind,
	            id: (0, _cloneNode.default)(bindings[key])
	          });
	        }

	        if (declar.init) {
	          exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
	        }
	      }

	      ensureLastUndefined = true;
	    } else if ((0, _generated.isIfStatement)(_node)) {
	      var consequent = _node.consequent ? gatherSequenceExpressions([_node.consequent], scope, declars) : scope.buildUndefinedNode();
	      var alternate = _node.alternate ? gatherSequenceExpressions([_node.alternate], scope, declars) : scope.buildUndefinedNode();
	      if (!consequent || !alternate) return;
	      exprs.push((0, _generated2.conditionalExpression)(_node.test, consequent, alternate));
	    } else if ((0, _generated.isBlockStatement)(_node)) {
	      var body = gatherSequenceExpressions(_node.body, scope, declars);
	      if (!body) return;
	      exprs.push(body);
	    } else if ((0, _generated.isEmptyStatement)(_node)) {
	      ensureLastUndefined = true;
	    } else {
	      return;
	    }
	  }

	  if (ensureLastUndefined) {
	    exprs.push(scope.buildUndefinedNode());
	  }

	  if (exprs.length === 1) {
	    return exprs[0];
	  } else {
	    return (0, _generated2.sequenceExpression)(exprs);
	  }
	}

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = toBindingIdentifierName;

	var _toIdentifier = _interopRequireDefault(__webpack_require__(49));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toBindingIdentifierName(name) {
	  name = (0, _toIdentifier.default)(name);
	  if (name === "eval" || name === "arguments") name = "_" + name;
	  return name;
	}

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = toComputedKey;

	var _generated = __webpack_require__(5);

	var _generated2 = __webpack_require__(9);

	function toComputedKey(node, key) {
	  if (key === void 0) {
	    key = node.key || node.property;
	  }

	  if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);
	  return key;
	}

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = toExpression;

	var _generated = __webpack_require__(5);

	function toExpression(node) {
	  if ((0, _generated.isExpressionStatement)(node)) {
	    node = node.expression;
	  }

	  if ((0, _generated.isExpression)(node)) {
	    return node;
	  }

	  if ((0, _generated.isClass)(node)) {
	    node.type = "ClassExpression";
	  } else if ((0, _generated.isFunction)(node)) {
	    node.type = "FunctionExpression";
	  }

	  if (!(0, _generated.isExpression)(node)) {
	    throw new Error("cannot turn " + node.type + " to an expression");
	  }

	  return node;
	}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = toKeyAlias;

	var _generated = __webpack_require__(5);

	var _cloneNode = _interopRequireDefault(__webpack_require__(16));

	var _removePropertiesDeep = _interopRequireDefault(__webpack_require__(52));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toKeyAlias(node, key) {
	  if (key === void 0) {
	    key = node.key;
	  }

	  var alias;

	  if (node.kind === "method") {
	    return toKeyAlias.increment() + "";
	  } else if ((0, _generated.isIdentifier)(key)) {
	    alias = key.name;
	  } else if ((0, _generated.isStringLiteral)(key)) {
	    alias = JSON.stringify(key.value);
	  } else {
	    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
	  }

	  if (node.computed) {
	    alias = "[" + alias + "]";
	  }

	  if (node.static) {
	    alias = "static:" + alias;
	  }

	  return alias;
	}

	toKeyAlias.uid = 0;

	toKeyAlias.increment = function () {
	  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
	    return toKeyAlias.uid = 0;
	  } else {
	    return toKeyAlias.uid++;
	  }
	};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = toSequenceExpression;

	var _gatherSequenceExpressions = _interopRequireDefault(__webpack_require__(110));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toSequenceExpression(nodes, scope) {
	  if (!nodes || !nodes.length) return;
	  var declars = [];
	  var result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
	  if (!result) return;

	  for (var _i = 0; _i < declars.length; _i++) {
	    var declar = declars[_i];
	    scope.push(declar);
	  }

	  return result;
	}

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = toStatement;

	var _generated = __webpack_require__(5);

	var _generated2 = __webpack_require__(9);

	function toStatement(node, ignore) {
	  if ((0, _generated.isStatement)(node)) {
	    return node;
	  }

	  var mustHaveId = false;
	  var newType;

	  if ((0, _generated.isClass)(node)) {
	    mustHaveId = true;
	    newType = "ClassDeclaration";
	  } else if ((0, _generated.isFunction)(node)) {
	    mustHaveId = true;
	    newType = "FunctionDeclaration";
	  } else if ((0, _generated.isAssignmentExpression)(node)) {
	    return (0, _generated2.expressionStatement)(node);
	  }

	  if (mustHaveId && !node.id) {
	    newType = false;
	  }

	  if (!newType) {
	    if (ignore) {
	      return false;
	    } else {
	      throw new Error("cannot turn " + node.type + " to a statement");
	    }
	  }

	  node.type = newType;
	  return node;
	}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = valueToNode;

	var _isPlainObject = _interopRequireDefault(__webpack_require__(150));

	var _isRegExp = _interopRequireDefault(__webpack_require__(151));

	var _isValidIdentifier = _interopRequireDefault(__webpack_require__(17));

	var _generated = __webpack_require__(9);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function valueToNode(value) {
	  if (value === undefined) {
	    return (0, _generated.identifier)("undefined");
	  }

	  if (value === true || value === false) {
	    return (0, _generated.booleanLiteral)(value);
	  }

	  if (value === null) {
	    return (0, _generated.nullLiteral)();
	  }

	  if (typeof value === "string") {
	    return (0, _generated.stringLiteral)(value);
	  }

	  if (typeof value === "number") {
	    return (0, _generated.numericLiteral)(value);
	  }

	  if ((0, _isRegExp.default)(value)) {
	    var pattern = value.source;
	    var flags = value.toString().match(/\/([a-z]+|)$/)[1];
	    return (0, _generated.regExpLiteral)(pattern, flags);
	  }

	  if (Array.isArray(value)) {
	    return (0, _generated.arrayExpression)(value.map(valueToNode));
	  }

	  if ((0, _isPlainObject.default)(value)) {
	    var props = [];

	    for (var key in value) {
	      var nodeKey = void 0;

	      if ((0, _isValidIdentifier.default)(key)) {
	        nodeKey = (0, _generated.identifier)(key);
	      } else {
	        nodeKey = (0, _generated.stringLiteral)(key);
	      }

	      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
	    }

	    return (0, _generated.objectExpression)(props);
	  }

	  throw new Error("don't know how to turn this value into a node");
	}

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _utils = _interopRequireWildcard(__webpack_require__(12));

	var _es = __webpack_require__(25);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	(0, _utils.default)("AwaitExpression", {
	  builder: ["argument"],
	  visitor: ["argument"],
	  aliases: ["Expression", "Terminatorless"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("BindExpression", {
	  visitor: ["object", "callee"],
	  aliases: ["Expression"],
	  fields: {}
	});
	(0, _utils.default)("ClassProperty", {
	  visitor: ["key", "value", "typeAnnotation", "decorators"],
	  builder: ["key", "value", "typeAnnotation", "decorators", "computed"],
	  aliases: ["Property"],
	  fields: Object.assign({}, _es.classMethodOrPropertyCommon, {
	    value: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    typeAnnotation: {
	      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	      optional: true
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
	      optional: true
	    },
	    readonly: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    }
	  })
	});
	(0, _utils.default)("OptionalMemberExpression", {
	  builder: ["object", "property", "computed", "optional"],
	  visitor: ["object", "property"],
	  aliases: ["Expression"],
	  fields: {
	    object: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    property: {
	      validate: function () {
	        var normal = (0, _utils.assertNodeType)("Identifier");
	        var computed = (0, _utils.assertNodeType)("Expression");
	        return function (node, key, val) {
	          var validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };
	      }()
	    },
	    computed: {
	      default: false
	    },
	    optional: {
	      validate: (0, _utils.assertValueType)("boolean")
	    }
	  }
	});
	(0, _utils.default)("OptionalCallExpression", {
	  visitor: ["callee", "arguments", "typeParameters"],
	  builder: ["callee", "arguments", "optional"],
	  aliases: ["Expression"],
	  fields: {
	    callee: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    arguments: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName")))
	    },
	    optional: {
	      validate: (0, _utils.assertValueType)("boolean")
	    },
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("Import", {
	  aliases: ["Expression"]
	});
	(0, _utils.default)("Decorator", {
	  visitor: ["expression"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("DoExpression", {
	  visitor: ["body"],
	  aliases: ["Expression"],
	  fields: {
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  }
	});
	(0, _utils.default)("ExportDefaultSpecifier", {
	  visitor: ["exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    exported: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	(0, _utils.default)("ExportNamespaceSpecifier", {
	  visitor: ["exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    exported: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _utils = _interopRequireWildcard(__webpack_require__(12));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	(0, _utils.default)("AnyTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("ArrayTypeAnnotation", {
	  visitor: ["elementType"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    elementType: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("BooleanTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("BooleanLiteralTypeAnnotation", {
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	(0, _utils.default)("NullLiteralTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("ClassImplements", {
	  visitor: ["id", "typeParameters"],
	  aliases: ["Flow"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
	  }
	});
	(0, _utils.default)("DeclareClass", {
	  visitor: ["id", "typeParameters", "extends", "body"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation"),
	    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
	    mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
	    body: (0, _utils.validateType)("ObjectTypeAnnotation")
	  }
	});
	(0, _utils.default)("DeclareFunction", {
	  visitor: ["id"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
	  }
	});
	(0, _utils.default)("DeclareInterface", {
	  visitor: ["id", "typeParameters", "extends", "body"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    extends: (0, _utils.validateOptionalType)("InterfaceExtends"),
	    mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("Flow")),
	    body: (0, _utils.validateType)("ObjectTypeAnnotation")
	  }
	});
	(0, _utils.default)("DeclareModule", {
	  builder: ["id", "body", "kind"],
	  visitor: ["id", "body"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
	    body: (0, _utils.validateType)("BlockStatement"),
	    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
	  }
	});
	(0, _utils.default)("DeclareModuleExports", {
	  visitor: ["typeAnnotation"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
	  }
	});
	(0, _utils.default)("DeclareTypeAlias", {
	  visitor: ["id", "typeParameters", "right"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    right: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("DeclareOpaqueType", {
	  visitor: ["id", "typeParameters", "supertype"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    supertype: (0, _utils.validateOptionalType)("FlowType")
	  }
	});
	(0, _utils.default)("DeclareVariable", {
	  visitor: ["id"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier")
	  }
	});
	(0, _utils.default)("DeclareExportDeclaration", {
	  visitor: ["declaration", "specifiers", "source"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    declaration: (0, _utils.validateOptionalType)("Flow"),
	    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
	    source: (0, _utils.validateOptionalType)("StringLiteral"),
	    default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
	  }
	});
	(0, _utils.default)("DeclareExportAllDeclaration", {
	  visitor: ["source"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    source: (0, _utils.validateType)("StringLiteral"),
	    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(["type", "value"]))
	  }
	});
	(0, _utils.default)("DeclaredPredicate", {
	  visitor: ["value"],
	  aliases: ["Flow", "FlowPredicate"],
	  fields: {
	    value: (0, _utils.validateType)("Flow")
	  }
	});
	(0, _utils.default)("ExistsTypeAnnotation", {
	  aliases: ["Flow", "FlowType"]
	});
	(0, _utils.default)("FunctionTypeAnnotation", {
	  visitor: ["typeParameters", "params", "rest", "returnType"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
	    rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
	    returnType: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("FunctionTypeParam", {
	  visitor: ["name", "typeAnnotation"],
	  aliases: ["Flow"],
	  fields: {
	    name: (0, _utils.validateOptionalType)("Identifier"),
	    typeAnnotation: (0, _utils.validateType)("FlowType"),
	    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
	  }
	});
	(0, _utils.default)("GenericTypeAnnotation", {
	  visitor: ["id", "typeParameters"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
	  }
	});
	(0, _utils.default)("InferredPredicate", {
	  aliases: ["Flow", "FlowPredicate"]
	});
	(0, _utils.default)("InterfaceExtends", {
	  visitor: ["id", "typeParameters"],
	  aliases: ["Flow"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
	  }
	});
	(0, _utils.default)("InterfaceDeclaration", {
	  visitor: ["id", "typeParameters", "extends", "body"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    extends: (0, _utils.validate)((0, _utils.arrayOfType)("InterfaceExtends")),
	    mixins: (0, _utils.validate)((0, _utils.arrayOfType)("InterfaceExtends")),
	    body: (0, _utils.validateType)("ObjectTypeAnnotation")
	  }
	});
	(0, _utils.default)("IntersectionTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	(0, _utils.default)("MixedTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("EmptyTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("NullableTypeAnnotation", {
	  visitor: ["typeAnnotation"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("NumberLiteralTypeAnnotation", {
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
	  }
	});
	(0, _utils.default)("NumberTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("ObjectTypeAnnotation", {
	  visitor: ["properties", "indexers", "callProperties"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
	    indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
	    callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
	    exact: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	(0, _utils.default)("ObjectTypeCallProperty", {
	  visitor: ["value"],
	  aliases: ["Flow", "UserWhitespacable"],
	  fields: {
	    value: (0, _utils.validateType)("FlowType"),
	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	(0, _utils.default)("ObjectTypeIndexer", {
	  visitor: ["id", "key", "value", "variance"],
	  aliases: ["Flow", "UserWhitespacable"],
	  fields: {
	    id: (0, _utils.validateOptionalType)("Identifier"),
	    key: (0, _utils.validateType)("FlowType"),
	    value: (0, _utils.validateType)("FlowType"),
	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    variance: (0, _utils.validateOptionalType)("Variance")
	  }
	});
	(0, _utils.default)("ObjectTypeProperty", {
	  visitor: ["key", "value", "variance"],
	  aliases: ["Flow", "UserWhitespacable"],
	  fields: {
	    key: (0, _utils.validateType)("Identifier"),
	    value: (0, _utils.validateType)("FlowType"),
	    kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    variance: (0, _utils.validateOptionalType)("Variance")
	  }
	});
	(0, _utils.default)("ObjectTypeSpreadProperty", {
	  visitor: ["argument"],
	  aliases: ["Flow", "UserWhitespacable"],
	  fields: {
	    argument: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("OpaqueType", {
	  visitor: ["id", "typeParameters", "supertype", "impltype"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    supertype: (0, _utils.validateOptionalType)("FlowType"),
	    impltype: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("QualifiedTypeIdentifier", {
	  visitor: ["id", "qualification"],
	  aliases: ["Flow"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
	  }
	});
	(0, _utils.default)("StringLiteralTypeAnnotation", {
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
	  }
	});
	(0, _utils.default)("StringTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("ThisTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("TupleTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	(0, _utils.default)("TypeofTypeAnnotation", {
	  visitor: ["argument"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    argument: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("TypeAlias", {
	  visitor: ["id", "typeParameters", "right"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    right: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("TypeAnnotation", {
	  aliases: ["Flow"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("TypeCastExpression", {
	  visitor: ["expression", "typeAnnotation"],
	  aliases: ["Flow", "ExpressionWrapper", "Expression"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression"),
	    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
	  }
	});
	(0, _utils.default)("TypeParameter", {
	  aliases: ["Flow"],
	  visitor: ["bound", "default", "variance"],
	  fields: {
	    name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
	    bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
	    default: (0, _utils.validateOptionalType)("FlowType"),
	    variance: (0, _utils.validateOptionalType)("Variance")
	  }
	});
	(0, _utils.default)("TypeParameterDeclaration", {
	  aliases: ["Flow"],
	  visitor: ["params"],
	  fields: {
	    params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
	  }
	});
	(0, _utils.default)("TypeParameterInstantiation", {
	  aliases: ["Flow"],
	  visitor: ["params"],
	  fields: {
	    params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	(0, _utils.default)("UnionTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	(0, _utils.default)("Variance", {
	  aliases: ["Flow"],
	  builder: ["kind"],
	  fields: {
	    kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
	  }
	});
	(0, _utils.default)("VoidTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _utils = _interopRequireWildcard(__webpack_require__(12));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	(0, _utils.default)("JSXAttribute", {
	  visitor: ["name", "value"],
	  aliases: ["JSX", "Immutable"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
	    },
	    value: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
	    }
	  }
	});
	(0, _utils.default)("JSXClosingElement", {
	  visitor: ["name"],
	  aliases: ["JSX", "Immutable"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
	    }
	  }
	});
	(0, _utils.default)("JSXElement", {
	  builder: ["openingElement", "closingElement", "children", "selfClosing"],
	  visitor: ["openingElement", "children", "closingElement"],
	  aliases: ["JSX", "Immutable", "Expression"],
	  fields: {
	    openingElement: {
	      validate: (0, _utils.assertNodeType)("JSXOpeningElement")
	    },
	    closingElement: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("JSXClosingElement")
	    },
	    children: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
	    }
	  }
	});
	(0, _utils.default)("JSXEmptyExpression", {
	  aliases: ["JSX"]
	});
	(0, _utils.default)("JSXExpressionContainer", {
	  visitor: ["expression"],
	  aliases: ["JSX", "Immutable"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("JSXSpreadChild", {
	  visitor: ["expression"],
	  aliases: ["JSX", "Immutable"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("JSXIdentifier", {
	  builder: ["name"],
	  aliases: ["JSX"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});
	(0, _utils.default)("JSXMemberExpression", {
	  visitor: ["object", "property"],
	  aliases: ["JSX"],
	  fields: {
	    object: {
	      validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
	    },
	    property: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
	    }
	  }
	});
	(0, _utils.default)("JSXNamespacedName", {
	  visitor: ["namespace", "name"],
	  aliases: ["JSX"],
	  fields: {
	    namespace: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
	    },
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
	    }
	  }
	});
	(0, _utils.default)("JSXOpeningElement", {
	  builder: ["name", "attributes", "selfClosing"],
	  visitor: ["name", "attributes"],
	  aliases: ["JSX", "Immutable"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
	    },
	    selfClosing: {
	      default: false,
	      validate: (0, _utils.assertValueType)("boolean")
	    },
	    attributes: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
	    }
	  }
	});
	(0, _utils.default)("JSXSpreadAttribute", {
	  visitor: ["argument"],
	  aliases: ["JSX"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("JSXText", {
	  aliases: ["JSX", "Immutable"],
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});
	(0, _utils.default)("JSXFragment", {
	  builder: ["openingFragment", "closingFragment", "children"],
	  visitor: ["openingFragment", "children", "closingFragment"],
	  aliases: ["JSX", "Immutable", "Expression"],
	  fields: {
	    openingFragment: {
	      validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
	    },
	    closingFragment: {
	      validate: (0, _utils.assertNodeType)("JSXClosingFragment")
	    },
	    children: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
	    }
	  }
	});
	(0, _utils.default)("JSXOpeningFragment", {
	  aliases: ["JSX", "Immutable"]
	});
	(0, _utils.default)("JSXClosingFragment", {
	  aliases: ["JSX", "Immutable"]
	});

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _utils = _interopRequireWildcard(__webpack_require__(12));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	(0, _utils.default)("Noop", {
	  visitor: []
	});
	(0, _utils.default)("ParenthesizedExpression", {
	  visitor: ["expression"],
	  aliases: ["Expression", "ExpressionWrapper"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _utils = _interopRequireWildcard(__webpack_require__(12));

	var _core = __webpack_require__(24);

	var _es = __webpack_require__(25);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	var bool = (0, _utils.assertValueType)("boolean");
	var tSFunctionTypeAnnotationCommon = {
	  returnType: {
	    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  typeParameters: {
	    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
	    optional: true
	  }
	};
	(0, _utils.default)("TSParameterProperty", {
	  aliases: ["LVal"],
	  visitor: ["parameter"],
	  fields: {
	    accessibility: {
	      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
	      optional: true
	    },
	    readonly: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    parameter: {
	      validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
	    }
	  }
	});
	(0, _utils.default)("TSDeclareFunction", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "params", "returnType"],
	  fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
	});
	(0, _utils.default)("TSDeclareMethod", {
	  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
	  fields: Object.assign({}, _es.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
	});
	(0, _utils.default)("TSQualifiedName", {
	  aliases: ["TSEntityName"],
	  visitor: ["left", "right"],
	  fields: {
	    left: (0, _utils.validateType)("TSEntityName"),
	    right: (0, _utils.validateType)("Identifier")
	  }
	});
	var signatureDeclarationCommon = {
	  typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
	  parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
	  typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
	};
	var callConstructSignatureDeclaration = {
	  aliases: ["TSTypeElement"],
	  visitor: ["typeParameters", "parameters", "typeAnnotation"],
	  fields: signatureDeclarationCommon
	};
	(0, _utils.default)("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
	(0, _utils.default)("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
	var namedTypeElementCommon = {
	  key: (0, _utils.validateType)("Expression"),
	  computed: (0, _utils.validate)(bool),
	  optional: (0, _utils.validateOptional)(bool)
	};
	(0, _utils.default)("TSPropertySignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["key", "typeAnnotation", "initializer"],
	  fields: Object.assign({}, namedTypeElementCommon, {
	    readonly: (0, _utils.validateOptional)(bool),
	    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
	    initializer: (0, _utils.validateOptionalType)("Expression")
	  })
	});
	(0, _utils.default)("TSMethodSignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
	  fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon)
	});
	(0, _utils.default)("TSIndexSignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["parameters", "typeAnnotation"],
	  fields: {
	    readonly: (0, _utils.validateOptional)(bool),
	    parameters: (0, _utils.validateArrayOfType)("Identifier"),
	    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
	  }
	});
	var tsKeywordTypes = ["TSAnyKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSBooleanKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSVoidKeyword", "TSUndefinedKeyword", "TSNullKeyword", "TSNeverKeyword"];

	for (var _i = 0; _i < tsKeywordTypes.length; _i++) {
	  var type = tsKeywordTypes[_i];
	  (0, _utils.default)(type, {
	    aliases: ["TSType"],
	    visitor: [],
	    fields: {}
	  });
	}

	(0, _utils.default)("TSThisType", {
	  aliases: ["TSType"],
	  visitor: [],
	  fields: {}
	});
	var fnOrCtr = {
	  aliases: ["TSType"],
	  visitor: ["typeParameters", "typeAnnotation"],
	  fields: signatureDeclarationCommon
	};
	(0, _utils.default)("TSFunctionType", fnOrCtr);
	(0, _utils.default)("TSConstructorType", fnOrCtr);
	(0, _utils.default)("TSTypeReference", {
	  aliases: ["TSType"],
	  visitor: ["typeName", "typeParameters"],
	  fields: {
	    typeName: (0, _utils.validateType)("TSEntityName"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
	  }
	});
	(0, _utils.default)("TSTypePredicate", {
	  aliases: ["TSType"],
	  visitor: ["parameterName", "typeAnnotation"],
	  fields: {
	    parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
	    typeAnnotation: (0, _utils.validateType)("TSTypeAnnotation")
	  }
	});
	(0, _utils.default)("TSTypeQuery", {
	  aliases: ["TSType"],
	  visitor: ["exprName"],
	  fields: {
	    exprName: (0, _utils.validateType)("TSEntityName")
	  }
	});
	(0, _utils.default)("TSTypeLiteral", {
	  aliases: ["TSType"],
	  visitor: ["members"],
	  fields: {
	    members: (0, _utils.validateArrayOfType)("TSTypeElement")
	  }
	});
	(0, _utils.default)("TSArrayType", {
	  aliases: ["TSType"],
	  visitor: ["elementType"],
	  fields: {
	    elementType: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSTupleType", {
	  aliases: ["TSType"],
	  visitor: ["elementTypes"],
	  fields: {
	    elementTypes: (0, _utils.validateArrayOfType)("TSType")
	  }
	});
	var unionOrIntersection = {
	  aliases: ["TSType"],
	  visitor: ["types"],
	  fields: {
	    types: (0, _utils.validateArrayOfType)("TSType")
	  }
	};
	(0, _utils.default)("TSUnionType", unionOrIntersection);
	(0, _utils.default)("TSIntersectionType", unionOrIntersection);
	(0, _utils.default)("TSParenthesizedType", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSTypeOperator", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSIndexedAccessType", {
	  aliases: ["TSType"],
	  visitor: ["objectType", "indexType"],
	  fields: {
	    objectType: (0, _utils.validateType)("TSType"),
	    indexType: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSMappedType", {
	  aliases: ["TSType"],
	  visitor: ["typeParameter", "typeAnnotation"],
	  fields: {
	    readonly: (0, _utils.validateOptional)(bool),
	    typeParameter: (0, _utils.validateType)("TSTypeParameter"),
	    optional: (0, _utils.validateOptional)(bool),
	    typeAnnotation: (0, _utils.validateOptionalType)("TSType")
	  }
	});
	(0, _utils.default)("TSLiteralType", {
	  aliases: ["TSType"],
	  visitor: ["literal"],
	  fields: {
	    literal: (0, _utils.validateType)(["NumericLiteral", "StringLiteral", "BooleanLiteral"])
	  }
	});
	(0, _utils.default)("TSExpressionWithTypeArguments", {
	  aliases: ["TSType"],
	  visitor: ["expression", "typeParameters"],
	  fields: {
	    expression: (0, _utils.validateType)("TSEntityName"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
	  }
	});
	(0, _utils.default)("TSInterfaceDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "extends", "body"],
	  fields: {
	    declare: (0, _utils.validateOptional)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
	    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
	    body: (0, _utils.validateType)("TSInterfaceBody")
	  }
	});
	(0, _utils.default)("TSInterfaceBody", {
	  visitor: ["body"],
	  fields: {
	    body: (0, _utils.validateArrayOfType)("TSTypeElement")
	  }
	});
	(0, _utils.default)("TSTypeAliasDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "typeAnnotation"],
	  fields: {
	    declare: (0, _utils.validateOptional)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSAsExpression", {
	  aliases: ["Expression"],
	  visitor: ["expression", "typeAnnotation"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression"),
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSTypeAssertion", {
	  aliases: ["Expression"],
	  visitor: ["typeAnnotation", "expression"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("TSType"),
	    expression: (0, _utils.validateType)("Expression")
	  }
	});
	(0, _utils.default)("TSEnumDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "members"],
	  fields: {
	    declare: (0, _utils.validateOptional)(bool),
	    const: (0, _utils.validateOptional)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    members: (0, _utils.validateArrayOfType)("TSEnumMember"),
	    initializer: (0, _utils.validateOptionalType)("Expression")
	  }
	});
	(0, _utils.default)("TSEnumMember", {
	  visitor: ["id", "initializer"],
	  fields: {
	    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
	    initializer: (0, _utils.validateOptionalType)("Expression")
	  }
	});
	(0, _utils.default)("TSModuleDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "body"],
	  fields: {
	    declare: (0, _utils.validateOptional)(bool),
	    global: (0, _utils.validateOptional)(bool),
	    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
	    body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
	  }
	});
	(0, _utils.default)("TSModuleBlock", {
	  visitor: ["body"],
	  fields: {
	    body: (0, _utils.validateArrayOfType)("Statement")
	  }
	});
	(0, _utils.default)("TSImportEqualsDeclaration", {
	  aliases: ["Statement"],
	  visitor: ["id", "moduleReference"],
	  fields: {
	    isExport: (0, _utils.validate)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"])
	  }
	});
	(0, _utils.default)("TSExternalModuleReference", {
	  visitor: ["expression"],
	  fields: {
	    expression: (0, _utils.validateType)("StringLiteral")
	  }
	});
	(0, _utils.default)("TSNonNullExpression", {
	  aliases: ["Expression"],
	  visitor: ["expression"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression")
	  }
	});
	(0, _utils.default)("TSExportAssignment", {
	  aliases: ["Statement"],
	  visitor: ["expression"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression")
	  }
	});
	(0, _utils.default)("TSNamespaceExportDeclaration", {
	  aliases: ["Statement"],
	  visitor: ["id"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier")
	  }
	});
	(0, _utils.default)("TSTypeAnnotation", {
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: {
	      validate: (0, _utils.assertNodeType)("TSType")
	    }
	  }
	});
	(0, _utils.default)("TSTypeParameterInstantiation", {
	  visitor: ["params"],
	  fields: {
	    params: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
	    }
	  }
	});
	(0, _utils.default)("TSTypeParameterDeclaration", {
	  visitor: ["params"],
	  fields: {
	    params: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
	    }
	  }
	});
	(0, _utils.default)("TSTypeParameter", {
	  visitor: ["constraint", "default"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertValueType)("string")
	    },
	    constraint: {
	      validate: (0, _utils.assertNodeType)("TSType"),
	      optional: true
	    },
	    default: {
	      validate: (0, _utils.assertNodeType)("TSType"),
	      optional: true
	    }
	  }
	});

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = appendToMemberExpression;

	var _generated = __webpack_require__(9);

	function appendToMemberExpression(member, append, computed) {
	  if (computed === void 0) {
	    computed = false;
	  }

	  member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
	  member.property = append;
	  member.computed = !!computed;
	  return member;
	}

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = inherits;

	var _constants = __webpack_require__(13);

	var _inheritsComments = _interopRequireDefault(__webpack_require__(47));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inherits(child, parent) {
	  if (!child || !parent) return child;
	  var _arr = _constants.INHERIT_KEYS.optional;

	  for (var _i = 0; _i < _arr.length; _i++) {
	    var key = _arr[_i];

	    if (child[key] == null) {
	      child[key] = parent[key];
	    }
	  }

	  for (var _key in parent) {
	    if (_key[0] === "_" && _key !== "__clone") child[_key] = parent[_key];
	  }

	  var _arr2 = _constants.INHERIT_KEYS.force;

	  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	    var _key2 = _arr2[_i2];
	    child[_key2] = parent[_key2];
	  }

	  (0, _inheritsComments.default)(child, parent);
	  return child;
	}

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = prependToMemberExpression;

	var _generated = __webpack_require__(9);

	function prependToMemberExpression(member, prepend) {
	  member.object = (0, _generated.memberExpression)(prepend, member.object);
	  return member;
	}

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = getOuterBindingIdentifiers;

	var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(19));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function getOuterBindingIdentifiers(node, duplicates) {
	  return (0, _getBindingIdentifiers.default)(node, duplicates, true);
	}

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = traverse;

	var _definitions = __webpack_require__(11);

	function traverse(node, handlers, state) {
	  if (typeof handlers === "function") {
	    handlers = {
	      enter: handlers
	    };
	  }

	  var _ref = handlers,
	      enter = _ref.enter,
	      exit = _ref.exit;
	  traverseSimpleImpl(node, enter, exit, state, []);
	}

	function traverseSimpleImpl(node, enter, exit, state, ancestors) {
	  var keys = _definitions.VISITOR_KEYS[node.type];
	  if (!keys) return;
	  if (enter) enter(node, ancestors, state);

	  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref2;

	    if (_isArray) {
	      if (_i >= _iterator.length) break;
	      _ref2 = _iterator[_i++];
	    } else {
	      _i = _iterator.next();
	      if (_i.done) break;
	      _ref2 = _i.value;
	    }

	    var _key2 = _ref2;
	    var subNode = node[_key2];

	    if (Array.isArray(subNode)) {
	      for (var i = 0; i < subNode.length; i++) {
	        var child = subNode[i];
	        if (!child) continue;
	        ancestors.push({
	          node: node,
	          key: _key2,
	          index: i
	        });
	        traverseSimpleImpl(child, enter, exit, state, ancestors);
	        ancestors.pop();
	      }
	    } else if (subNode) {
	      ancestors.push({
	        node: node,
	        key: _key2
	      });
	      traverseSimpleImpl(subNode, enter, exit, state, ancestors);
	      ancestors.pop();
	    }
	  }

	  if (exit) exit(node, ancestors, state);
	}

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = cleanJSXElementLiteralChild;

	var _generated = __webpack_require__(9);

	function cleanJSXElementLiteralChild(child, args) {
	  var lines = child.value.split(/\r\n|\n|\r/);
	  var lastNonEmptyLine = 0;

	  for (var i = 0; i < lines.length; i++) {
	    if (lines[i].match(/[^ \t]/)) {
	      lastNonEmptyLine = i;
	    }
	  }

	  var str = "";

	  for (var _i = 0; _i < lines.length; _i++) {
	    var line = lines[_i];
	    var isFirstLine = _i === 0;
	    var isLastLine = _i === lines.length - 1;
	    var isLastNonEmptyLine = _i === lastNonEmptyLine;
	    var trimmedLine = line.replace(/\t/g, " ");

	    if (!isFirstLine) {
	      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
	    }

	    if (!isLastLine) {
	      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
	    }

	    if (trimmedLine) {
	      if (!isLastNonEmptyLine) {
	        trimmedLine += " ";
	      }

	      str += trimmedLine;
	    }
	  }

	  if (str) args.push((0, _generated.stringLiteral)(str));
	}

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isBinding;

	var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(19));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isBinding(node, parent) {
	  var keys = _getBindingIdentifiers.default.keys[parent.type];

	  if (keys) {
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      var val = parent[key];

	      if (Array.isArray(val)) {
	        if (val.indexOf(node) >= 0) return true;
	      } else {
	        if (val === node) return true;
	      }
	    }
	  }

	  return false;
	}

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isBlockScoped;

	var _generated = __webpack_require__(5);

	var _isLet = _interopRequireDefault(__webpack_require__(56));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isBlockScoped(node) {
	  return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
	}

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isImmutable;

	var _isType = _interopRequireDefault(__webpack_require__(27));

	var _generated = __webpack_require__(5);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isImmutable(node) {
	  if ((0, _isType.default)(node.type, "Immutable")) return true;

	  if ((0, _generated.isIdentifier)(node)) {
	    if (node.name === "undefined") {
	      return true;
	    } else {
	      return false;
	    }
	  }

	  return false;
	}

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isNodesEquivalent;

	var _definitions = __webpack_require__(11);

	function isNodesEquivalent(a, b) {
	  if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
	    return a === b;
	  }

	  if (a.type !== b.type) {
	    return false;
	  }

	  var fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);

	  for (var _i = 0; _i < fields.length; _i++) {
	    var field = fields[_i];

	    if (typeof a[field] !== typeof b[field]) {
	      return false;
	    }

	    if (Array.isArray(a[field])) {
	      if (!Array.isArray(b[field])) {
	        return false;
	      }

	      if (a[field].length !== b[field].length) {
	        return false;
	      }

	      for (var i = 0; i < a[field].length; i++) {
	        if (!isNodesEquivalent(a[field][i], b[field][i])) {
	          return false;
	        }
	      }

	      continue;
	    }

	    if (!isNodesEquivalent(a[field], b[field])) {
	      return false;
	    }
	  }

	  return true;
	}

/***/ }),
/* 133 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports.default = isReferenced;

	function isReferenced(node, parent) {
	  switch (parent.type) {
	    case "BindExpression":
	      return parent.object === node || parent.callee === node;

	    case "MemberExpression":
	    case "JSXMemberExpression":
	      if (parent.property === node && parent.computed) {
	        return true;
	      } else if (parent.object === node) {
	        return true;
	      } else {
	        return false;
	      }

	    case "MetaProperty":
	      return false;

	    case "ObjectProperty":
	      if (parent.key === node) {
	        return parent.computed;
	      }

	    case "VariableDeclarator":
	      return parent.id !== node;

	    case "ArrowFunctionExpression":
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	      var _arr = parent.params;

	      for (var _i = 0; _i < _arr.length; _i++) {
	        var param = _arr[_i];
	        if (param === node) return false;
	      }

	      return parent.id !== node;

	    case "ExportSpecifier":
	      if (parent.source) {
	        return false;
	      } else {
	        return parent.local === node;
	      }

	    case "ExportNamespaceSpecifier":
	    case "ExportDefaultSpecifier":
	      return false;

	    case "JSXAttribute":
	      return parent.name !== node;

	    case "ClassProperty":
	      if (parent.key === node) {
	        return parent.computed;
	      } else {
	        return parent.value === node;
	      }

	    case "ImportDefaultSpecifier":
	    case "ImportNamespaceSpecifier":
	    case "ImportSpecifier":
	      return false;

	    case "ClassDeclaration":
	    case "ClassExpression":
	      return parent.id !== node;

	    case "ClassMethod":
	    case "ObjectMethod":
	      return parent.key === node && parent.computed;

	    case "LabeledStatement":
	      return false;

	    case "CatchClause":
	      return parent.param !== node;

	    case "RestElement":
	      return false;

	    case "AssignmentExpression":
	      return parent.right === node;

	    case "AssignmentPattern":
	      return parent.right === node;

	    case "ObjectPattern":
	    case "ArrayPattern":
	      return false;
	  }

	  return true;
	}

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isScope;

	var _generated = __webpack_require__(5);

	function isScope(node, parent) {
	  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isFunction)(parent, {
	    body: node
	  })) {
	    return false;
	  }

	  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isCatchClause)(parent, {
	    body: node
	  })) {
	    return false;
	  }

	  return (0, _generated.isScopable)(node);
	}

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isSpecifierDefault;

	var _generated = __webpack_require__(5);

	function isSpecifierDefault(specifier) {
	  return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
	    name: "default"
	  });
	}

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isValidES3Identifier;

	var _isValidIdentifier = _interopRequireDefault(__webpack_require__(17));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);

	function isValidES3Identifier(name) {
	  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
	}

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = isVar;

	var _generated = __webpack_require__(5);

	var _constants = __webpack_require__(13);

	function isVar(node) {
	  return (0, _generated.isVariableDeclaration)(node, {
	    kind: "var"
	  }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
	}

/***/ }),
/* 138 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports.default = isCompatTag;

	function isCompatTag(tagName) {
	  return !!tagName && /^[a-z]/.test(tagName);
	}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.default = void 0;

	var _buildMatchMemberExpression = _interopRequireDefault(__webpack_require__(55));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
	var _default = isReactComponent;
	exports.default = _default;

/***/ }),
/* 140 */
/***/ (function(module, exports) {

	module.exports = require("babel-polyfill");

/***/ }),
/* 141 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/inherits");

/***/ }),
/* 142 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/possibleConstructorReturn");

/***/ }),
/* 143 */
/***/ (function(module, exports) {

	module.exports = require("babylon");

/***/ }),
/* 144 */
/***/ (function(module, exports) {

	module.exports = require("esutils");

/***/ }),
/* 145 */
/***/ (function(module, exports) {

	module.exports = require("fast-glob");

/***/ }),
/* 146 */
/***/ (function(module, exports) {

	module.exports = require("immutable");

/***/ }),
/* 147 */
/***/ (function(module, exports) {

	module.exports = require("jsesc");

/***/ }),
/* 148 */
/***/ (function(module, exports) {

	module.exports = require("lodash/clone");

/***/ }),
/* 149 */
/***/ (function(module, exports) {

	module.exports = require("lodash/isInteger");

/***/ }),
/* 150 */
/***/ (function(module, exports) {

	module.exports = require("lodash/isPlainObject");

/***/ }),
/* 151 */
/***/ (function(module, exports) {

	module.exports = require("lodash/isRegExp");

/***/ }),
/* 152 */
/***/ (function(module, exports) {

	module.exports = require("lodash/map");

/***/ }),
/* 153 */
/***/ (function(module, exports) {

	module.exports = require("lodash/repeat");

/***/ }),
/* 154 */
/***/ (function(module, exports) {

	module.exports = require("lodash/uniq");

/***/ }),
/* 155 */
/***/ (function(module, exports) {

	module.exports = require("source-map");

/***/ }),
/* 156 */
/***/ (function(module, exports) {

	module.exports = require("to-fast-properties");

/***/ }),
/* 157 */
/***/ (function(module, exports) {

	module.exports = require("trim-right");

/***/ }),
/* 158 */
/***/ (function(module, exports) {

	module.exports = require("yargs");

/***/ })
/******/ ]);