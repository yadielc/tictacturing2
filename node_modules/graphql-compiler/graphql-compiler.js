/**
 * Relay v1.6.0
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(38),
	    SourceControlMercurial = _require.SourceControlMercurial;

	module.exports = {
	  ASTConvert: __webpack_require__(26),
	  CodegenDirectory: __webpack_require__(14),
	  CodegenRunner: __webpack_require__(27),
	  CodegenWatcher: __webpack_require__(15),
	  CompilerContext: __webpack_require__(22),
	  ConsoleReporter: __webpack_require__(31),
	  DotGraphQLParser: __webpack_require__(28),
	  ASTCache: __webpack_require__(20),
	  IRTransformer: __webpack_require__(7),
	  IRVisitor: __webpack_require__(19),
	  MultiReporter: __webpack_require__(32),
	  Parser: __webpack_require__(33),
	  Printer: __webpack_require__(18),
	  Profiler: __webpack_require__(2),
	  SchemaUtils: __webpack_require__(8),
	  SourceControlMercurial: SourceControlMercurial,
	  Validator: __webpack_require__(24),
	  WatchmanClient: __webpack_require__(16),
	  filterContextForNode: __webpack_require__(41),
	  getIdentifierForArgumentValue: __webpack_require__(42),
	  getLiteralArgumentValues: __webpack_require__(43),
	  isEquivalentType: __webpack_require__(44),
	  nullthrows: __webpack_require__(9),

	  FilterDirectivesTransform: __webpack_require__(29),
	  FlattenTransform: __webpack_require__(30),
	  InlineFragmentsTransform: __webpack_require__(34),
	  SkipClientFieldTransform: __webpack_require__(35),
	  SkipRedundantNodesTransform: __webpack_require__(36),
	  SkipUnreachableNodeTransform: __webpack_require__(37),
	  StripUnusedVariablesTransform: __webpack_require__(39)
	};

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	module.exports = require("fbjs/lib/invariant");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _asyncToGenerator2 = __webpack_require__(10);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * The compiler profiler builds a "call graph" of high level operations as a
	 * means of tracking time spent over the course of running the compiler.
	 */

	var enabled = false;
	var traces = [{
	  ph: 'M',
	  pid: 0,
	  tid: 0,
	  name: 'process_name',
	  args: { name: 'relay-compiler' }
	}, {
	  ph: 'M',
	  pid: 0,
	  tid: 0,
	  name: 'thread_name',
	  args: { name: 'relay-compiler' }
	}];
	var stack = [];

	function enable() {
	  enabled = true;
	}

	function getTraces() {
	  return traces;
	}

	/**
	 * Run the provided function as part of a stack profile.
	 */
	function run(name, fn) {
	  return instrument(fn, name)();
	}

	/**
	 * Run the provided async function as part context in a stack profile.
	 * See instrumentAsyncContext() for limitations and usage notes.
	 */
	function asyncContext(name, fn) {
	  return instrumentAsyncContext(fn, name)();
	}

	/**
	 * Wait for the provided async operation as an async profile.
	 */
	function waitFor(name, fn) {
	  return instrumentWait(fn, name)();
	}

	/**
	 * Return a new instrumented sync function to be part of a stack profile.
	 *
	 * This instruments synchronous functions to be displayed in a stack
	 * visualization. To instrument async functions, see instrumentAsyncContext()
	 * and instrumentWait().
	 */
	function instrument(fn, name) {
	  if (!enabled) {
	    return fn;
	  }
	  var profileName = name || fn.displayName || fn.name;
	  var instrumented = function instrumented() {
	    var traceId = start(profileName);
	    try {
	      return fn.apply(this, arguments);
	    } finally {
	      end(traceId);
	    }
	  };
	  instrumented.displayName = profileName;
	  return instrumented;
	}

	/**
	 * Return a new instrumented async function which provides context for a stack.
	 *
	 * Because the resulting profiling information will be incorporated into a
	 * stack visualization, the instrumented function must represent a distinct
	 * region of time which does not overlap with any other async context.
	 *
	 * In other words, functions instrumented with instrumentAsyncContext must not
	 * run in parallel via Promise.all().
	 *
	 * To instrument functions which will run in parallel, use instrumentWait().
	 */
	function instrumentAsyncContext(fn, name) {
	  if (!enabled) {
	    return fn;
	  }
	  var profileName = name || fn.displayName || fn.name;
	  var instrumented = (() => {
	    var _ref = (0, _asyncToGenerator3.default)(function* () {
	      var traceId = start(profileName);
	      try {
	        return yield fn.apply(this, arguments);
	      } finally {
	        end(traceId);
	      }
	    });

	    function instrumented() {
	      return _ref.apply(this, arguments);
	    }

	    return instrumented;
	  })();
	  instrumented.displayName = profileName;
	  return instrumented;
	}

	/**
	 * Return a new instrumented function which performs an awaited async operation.
	 *
	 * The instrumented function is not included in the overall run time of the
	 * compiler, instead it captures the time waiting on some asynchronous external
	 * resource such as network or filesystem which are often run in parallel.
	 */
	function instrumentWait(fn, name) {
	  if (!enabled) {
	    return fn;
	  }
	  var profileName = name || fn.displayName || fn.name;
	  var instrumented = (() => {
	    var _ref2 = (0, _asyncToGenerator3.default)(function* () {
	      var traceId = startWait(profileName);
	      try {
	        return yield fn.apply(this, arguments);
	      } finally {
	        end(traceId);
	      }
	    });

	    function instrumented() {
	      return _ref2.apply(this, arguments);
	    }

	    return instrumented;
	  })();
	  instrumented.displayName = profileName;
	  return instrumented;
	}

	var T_ZERO = process.hrtime();

	// Return a Uint32 of microtime duration since program start.
	function microtime() {
	  var hrtime = process.hrtime(T_ZERO);
	  // eslint-disable-next-line no-bitwise
	  return 0 | hrtime[0] * 1e6 + Math.round(hrtime[1] / 1e3);
	}

	/**
	 * Start a stack profile with a particular name, returns an ID to pass to end().
	 *
	 * Other profiles may start before this one ends, which will be represented as
	 * nested operations, however all nested operations must end before this ends.
	 *
	 * In particular, be careful to end after errors.
	 */
	function start(name) {
	  var beginTrace = {
	    ph: 'B',
	    name: name,
	    pid: 0,
	    tid: 0,
	    ts: microtime()
	  };
	  traces.push(beginTrace);
	  stack.push(beginTrace);
	  return traces.length - 1;
	}

	var asyncID = 0;

	/**
	 * Start an async wait profile with a particular name, returns an ID to pass
	 * to end().
	 *
	 * Other profiles may start before this one ends, which will be represented as
	 * nested operations, however all nested operations must end before this ends.
	 *
	 * In particular, be careful to end after errors.
	 */
	function startWait(name) {
	  traces.push({
	    ph: 'b',
	    name: name,
	    cat: 'wait',
	    id: asyncID++,
	    pid: 0,
	    tid: 0,
	    ts: microtime()
	  });
	  return traces.length - 1;
	}

	function end(traceIdx) {
	  var trace = traces[traceIdx];

	  if (trace.ph === 'b') {
	    traces.push({
	      ph: 'e',
	      cat: trace.cat,
	      name: trace.name,
	      id: trace.id,
	      pid: trace.pid,
	      tid: trace.tid,
	      ts: microtime()
	    });
	    return;
	  }

	  __webpack_require__(1)(trace.ph === 'B', 'Begin trace phase');
	  __webpack_require__(1)(stack.pop() === trace, 'GraphQLCompilerProfiler: The profile trace %s ended before nested traces. ' + 'If it is async, try using Profile.waitFor or Profile.profileWait.', trace.name);

	  var prevTrace = traces[traces.length - 1];

	  if (trace === prevTrace) {
	    traces[traceIdx] = {
	      ph: 'X',
	      name: trace.name,
	      pid: trace.pid,
	      tid: trace.tid,
	      ts: trace.ts,
	      dur: microtime() - trace.ts
	    };
	    return;
	  }

	  traces.push({
	    ph: 'E',
	    name: trace.name,
	    pid: trace.pid,
	    tid: trace.tid,
	    ts: microtime()
	  });
	}

	module.exports = {
	  enable: enable,
	  getTraces: getTraces,
	  run: run,
	  asyncContext: asyncContext,
	  waitFor: waitFor,
	  instrument: instrument,
	  instrumentAsyncContext: instrumentAsyncContext,
	  instrumentWait: instrumentWait,
	  start: start,
	  startWait: startWait,
	  end: end
	};

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	module.exports = require("fs");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/classCallCheck");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	module.exports = require("graphql");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	module.exports = require("path");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(11));

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(4));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * @public
	 *
	 * Helper for writing compiler transforms that apply "map" and/or "filter"-style
	 * operations to compiler contexts. The `visitor` argument accepts a map of IR
	 * kinds to user-defined functions that can map nodes of that kind to new values
	 * (of the same kind).
	 *
	 * If a visitor function is defined for a kind, the visitor function is
	 * responsible for traversing its children (by calling `this.traverse(node)`)
	 * and returning either the input (to indicate no changes), a new node (to
	 * indicate changes), or null/undefined (to indicate the removal of that node
	 * from the output).
	 *
	 * If a visitor function is *not* defined for a kind, a default traversal is
	 * used to evaluate its children.
	 *
	 * The `stateInitializer` argument accepts an optional function to construct the
	 * state for each document (fragment or root) in the context. Any documents for
	 * which the initializer returns null/undefined is deleted from the context
	 * without being traversed.
	 *
	 * Example: Alias all scalar fields with the reverse of their name:
	 *
	 * ```
	 * transform(context, {
	 *   ScalarField: visitScalarField,
	 * });
	 *
	 * function visitScalarField(field: ScalarField, state: State): ?ScalarField {
	 *   // Traverse child nodes - for a scalar field these are the arguments &
	 *   // directives.
	 *   const nextField = this.traverse(field, state);
	 *   // Return a new node with a different alias.
	 *   return {
	 *     ...nextField,
	 *     alias: nextField.name.split('').reverse().join(''),
	 *   };
	 * }
	 * ```
	 */
	function transform(context, visitor, stateInitializer) {
	  var transformer = new Transformer(context, visitor);
	  return context.withMutations(function (nextContext) {
	    context.forEachDocument(function (prevNode) {
	      var nextNode = void 0;
	      if (stateInitializer === undefined) {
	        nextNode = transformer.visit(prevNode, undefined);
	      } else {
	        var _state = stateInitializer(prevNode);
	        if (_state != null) {
	          nextNode = transformer.visit(prevNode, _state);
	        }
	      }
	      if (!nextNode) {
	        nextContext = nextContext.remove(prevNode.name);
	      } else if (nextNode !== prevNode) {
	        nextContext = nextContext.replace(nextNode);
	      }
	    });
	    return nextContext;
	  });
	}

	/**
	 * @internal
	 */

	var Transformer = function () {
	  function Transformer(context, visitor) {
	    (0, _classCallCheck3['default'])(this, Transformer);

	    this._context = context;
	    this._states = [];
	    this._visitor = visitor;
	  }

	  /**
	   * @public
	   *
	   * Returns the original compiler context that is being transformed. This can
	   * be used to look up fragments by name, for example.
	   */


	  Transformer.prototype.getContext = function getContext() {
	    return this._context;
	  };

	  /**
	   * @public
	   *
	   * Transforms the node, calling a user-defined visitor function if defined for
	   * the node's kind. Uses the given state for this portion of the traversal.
	   *
	   * Note: This differs from `traverse` in that it calls a visitor function for
	   * the node itself.
	   */


	  Transformer.prototype.visit = function visit(node, state) {
	    this._states.push(state);
	    var nextNode = this._visit(node);
	    this._states.pop();
	    return nextNode;
	  };

	  /**
	   * @public
	   *
	   * Transforms the children of the given node, skipping the user-defined
	   * visitor function for the node itself. Uses the given state for this portion
	   * of the traversal.
	   *
	   * Note: This differs from `visit` in that it does not call a visitor function
	   * for the node itself.
	   */


	  Transformer.prototype.traverse = function traverse(node, state) {
	    this._states.push(state);
	    var nextNode = this._traverse(node);
	    this._states.pop();
	    return nextNode;
	  };

	  Transformer.prototype._visit = function _visit(node) {
	    var nodeVisitor = this._visitor[node.kind];
	    if (nodeVisitor) {
	      // If a handler for the kind is defined, it is responsible for calling
	      // `traverse` to transform children as necessary.
	      var _state2 = this._getState();
	      var nextNode = nodeVisitor.call(this, node, _state2);
	      return nextNode;
	    }
	    // Otherwise traverse is called automatically.
	    return this._traverse(node);
	  };

	  Transformer.prototype._traverse = function _traverse(prevNode) {
	    var nextNode = void 0;
	    switch (prevNode.kind) {
	      case 'Argument':
	        nextNode = this._traverseChildren(prevNode, null, ['value']);
	        break;
	      case 'Batch':
	        nextNode = this._traverseChildren(prevNode, ['requests'], ['fragment']);
	        break;
	      case 'Literal':
	      case 'LocalArgumentDefinition':
	      case 'RootArgumentDefinition':
	      case 'Variable':
	        nextNode = prevNode;
	        break;
	      case 'Directive':
	        nextNode = this._traverseChildren(prevNode, ['args']);
	        break;
	      case 'FragmentSpread':
	      case 'ScalarField':
	        nextNode = this._traverseChildren(prevNode, ['args', 'directives']);
	        break;
	      case 'LinkedField':
	        nextNode = this._traverseChildren(prevNode, ['args', 'directives', 'selections']);
	        if (!nextNode.selections.length) {
	          nextNode = null;
	        }
	        break;
	      case 'ListValue':
	        nextNode = this._traverseChildren(prevNode, ['items']);
	        break;
	      case 'ObjectFieldValue':
	        nextNode = this._traverseChildren(prevNode, null, ['value']);
	        break;
	      case 'ObjectValue':
	        nextNode = this._traverseChildren(prevNode, ['fields']);
	        break;
	      case 'Condition':
	        nextNode = this._traverseChildren(prevNode, ['directives', 'selections'], ['condition']);
	        if (!nextNode.selections.length) {
	          nextNode = null;
	        }
	        break;
	      case 'InlineFragment':
	        nextNode = this._traverseChildren(prevNode, ['directives', 'selections']);
	        if (!nextNode.selections.length) {
	          nextNode = null;
	        }
	        break;
	      case 'DeferrableFragmentSpread':
	        nextNode = this._traverseChildren(prevNode, ['args', 'fragmentArgs', 'directives']);
	        break;
	      case 'Fragment':
	      case 'Root':
	        nextNode = this._traverseChildren(prevNode, ['argumentDefinitions', 'directives', 'selections']);
	        break;
	      case 'Request':
	        nextNode = this._traverseChildren(prevNode, null, ['root']);
	        break;
	      default:
	        __webpack_require__(1)(false, 'GraphQLIRTransformer: Unknown kind `%s`.', prevNode.kind);
	    }
	    return nextNode;
	  };

	  Transformer.prototype._traverseChildren = function _traverseChildren(prevNode, pluralKeys, singularKeys) {
	    var _this = this;

	    var nextNode = void 0;
	    pluralKeys && pluralKeys.forEach(function (key) {
	      var prevItems = prevNode[key];
	      if (!prevItems) {
	        return;
	      }
	      __webpack_require__(1)(Array.isArray(prevItems), 'GraphQLIRTransformer: Expected data for `%s` to be an array, got `%s`.', key, prevItems);
	      var nextItems = _this._map(prevItems);
	      if (nextNode || nextItems !== prevItems) {
	        nextNode = nextNode || (0, _extends3['default'])({}, prevNode);
	        nextNode[key] = nextItems;
	      }
	    });
	    singularKeys && singularKeys.forEach(function (key) {
	      var prevItem = prevNode[key];
	      if (!prevItem) {
	        return;
	      }
	      var nextItem = _this._visit(prevItem);
	      if (nextNode || nextItem !== prevItem) {
	        nextNode = nextNode || (0, _extends3['default'])({}, prevNode);
	        nextNode[key] = nextItem;
	      }
	    });
	    return nextNode || prevNode;
	  };

	  Transformer.prototype._map = function _map(prevItems) {
	    var _this2 = this;

	    var nextItems = void 0;
	    prevItems.forEach(function (prevItem, index) {
	      var nextItem = _this2._visit(prevItem);
	      if (nextItems || nextItem !== prevItem) {
	        nextItems = nextItems || prevItems.slice(0, index);
	        if (nextItem) {
	          nextItems.push(nextItem);
	        }
	      }
	    });
	    return nextItems || prevItems;
	  };

	  Transformer.prototype._getState = function _getState() {
	    __webpack_require__(1)(this._states.length, 'GraphQLIRTransformer: Expected a current state to be set but found none. ' + 'This is usually the result of mismatched number of pushState()/popState() ' + 'calls.');
	    return this._states[this._states.length - 1];
	  };

	  return Transformer;
	}();

	module.exports = { transform: transform };

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(5),
	    assertAbstractType = _require.assertAbstractType,
	    getNamedType = _require.getNamedType,
	    getNullableType = _require.getNullableType,
	    isType = _require.isType,
	    print = _require.print,
	    typeFromAST = _require.typeFromAST,
	    GraphQLInterfaceType = _require.GraphQLInterfaceType,
	    GraphQLList = _require.GraphQLList,
	    GraphQLObjectType = _require.GraphQLObjectType,
	    GraphQLSchema = _require.GraphQLSchema,
	    GraphQLUnionType = _require.GraphQLUnionType;

	var ID = 'id';
	var ID_TYPE = 'ID';

	/**
	 * Determine if the given type may implement the named type:
	 * - it is the named type
	 * - it implements the named interface
	 * - it is an abstract type and *some* of its concrete types may
	 *   implement the named type
	 */
	function mayImplement(schema, type, typeName) {
	  var unmodifiedType = getRawType(type);
	  return unmodifiedType.toString() === typeName || implementsInterface(unmodifiedType, typeName) || isAbstractType(unmodifiedType) && hasConcreteTypeThatImplements(schema, unmodifiedType, typeName);
	}

	function canHaveSelections(type) {
	  return type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType;
	}

	/**
	 * Implements duck typing that checks whether a type has an id field of the ID
	 * type. This is approximating what we can hopefully do with the __id proposal
	 * a bit more cleanly.
	 *
	 * https://github.com/graphql/graphql-future/blob/master/01%20-%20__id.md
	 */
	function hasID(schema, type) {
	  var unmodifiedType = getRawType(type);
	  __webpack_require__(1)(unmodifiedType instanceof GraphQLObjectType || unmodifiedType instanceof GraphQLInterfaceType, 'GraphQLSchemaUtils.hasID(): Expected a concrete type or interface, ' + 'got type `%s`.', type);
	  var idType = schema.getType(ID_TYPE);
	  var idField = unmodifiedType.getFields()[ID];
	  return idField && getRawType(idField.type) === idType;
	}

	/**
	 * Determine if a type is abstract (not concrete).
	 *
	 * Note: This is used in place of the `graphql` version of the function in order
	 * to not break `instanceof` checks with Jest. This version also unwraps
	 * non-null/list wrapper types.
	 */
	function isAbstractType(type) {
	  var rawType = getRawType(type);
	  return rawType instanceof GraphQLInterfaceType || rawType instanceof GraphQLUnionType;
	}

	function isUnionType(type) {
	  return type instanceof GraphQLUnionType;
	}

	/**
	 * Get the unmodified type, with list/null wrappers removed.
	 */
	function getRawType(type) {
	  return __webpack_require__(9)(getNamedType(type));
	}

	/**
	 * Gets the non-list type, removing the list wrapper if present.
	 */
	function getSingularType(type) {
	  var unmodifiedType = type;
	  while (unmodifiedType instanceof GraphQLList) {
	    unmodifiedType = unmodifiedType.ofType;
	  }
	  return unmodifiedType;
	}

	/**
	 * @public
	 */
	function implementsInterface(type, interfaceName) {
	  return getInterfaces(type).some(function (interfaceType) {
	    return interfaceType.toString() === interfaceName;
	  });
	}

	/**
	 * @private
	 */
	function hasConcreteTypeThatImplements(schema, type, interfaceName) {
	  return isAbstractType(type) && getConcreteTypes(schema, type).some(function (concreteType) {
	    return implementsInterface(concreteType, interfaceName);
	  });
	}

	/**
	 * @private
	 */
	function getConcreteTypes(schema, type) {
	  return schema.getPossibleTypes(assertAbstractType(type));
	}

	/**
	 * @private
	 */
	function getInterfaces(type) {
	  if (type instanceof GraphQLObjectType) {
	    return type.getInterfaces();
	  }
	  return [];
	}

	/**
	 * @public
	 *
	 * Determine if an AST node contains a fragment/operation definition.
	 */
	function isExecutableDefinitionAST(ast) {
	  return ast.kind === 'FragmentDefinition' || ast.kind === 'OperationDefinition';
	}

	/**
	 * @public
	 *
	 * Determine if an AST node contains a schema definition.
	 */
	function isSchemaDefinitionAST(ast) {
	  return ast.kind === 'SchemaDefinition' || ast.kind === 'ScalarTypeDefinition' || ast.kind === 'ObjectTypeDefinition' || ast.kind === 'InterfaceTypeDefinition' || ast.kind === 'UnionTypeDefinition' || ast.kind === 'EnumTypeDefinition' || ast.kind === 'InputObjectTypeDefinition' || ast.kind === 'DirectiveDefinition' || ast.kind === 'ScalarTypeExtension' || ast.kind === 'ObjectTypeExtension' || ast.kind === 'InterfaceTypeExtension' || ast.kind === 'UnionTypeExtension' || ast.kind === 'EnumTypeExtension' || ast.kind === 'InputObjectTypeExtension';
	}

	function assertTypeWithFields(type) {
	  __webpack_require__(1)(type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType, 'GraphQLSchemaUtils: Expected type `%s` to be an object or interface type.', type);
	  return type;
	}

	/**
	 * Helper for calling `typeFromAST()` with a clear warning when the type does
	 * not exist. This enables the pattern `assertXXXType(getTypeFromAST(...))`,
	 * emitting distinct errors for unknown types vs types of the wrong category.
	 */
	function getTypeFromAST(schema, ast) {
	  var type = typeFromAST(schema, ast);
	  __webpack_require__(1)(isType(type), 'GraphQLSchemaUtils: Unknown type `%s`.', print(ast));
	  return type;
	}

	module.exports = {
	  assertTypeWithFields: assertTypeWithFields,
	  canHaveSelections: canHaveSelections,
	  getNullableType: getNullableType,
	  getRawType: getRawType,
	  getSingularType: getSingularType,
	  getTypeFromAST: getTypeFromAST,
	  hasID: hasID,
	  implementsInterface: implementsInterface,
	  isAbstractType: isAbstractType,
	  isUnionType: isUnionType,
	  isExecutableDefinitionAST: isExecutableDefinitionAST,
	  isSchemaDefinitionAST: isSchemaDefinitionAST,
	  mayImplement: mayImplement
	};

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */
	'use strict';

	var nullthrows = function nullthrows(x) {
	  var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Got unexpected null or undefined';

	  if (x != null) {
	    return x;
	  }
	  var error = new Error(message);
	  error.framesToPop = 1; // Skip nullthrows own stack frame.
	  throw error;
	};

	module.exports = nullthrows;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/toConsumableArray");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	module.exports = require("chalk");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _asyncToGenerator2 = __webpack_require__(10);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(4));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(12));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * CodegenDirectory is a helper class for scripts that generate code into one
	 * output directory. The purpose is to make it easy to only write files that
	 * have changed and delete files that are no longer generated.
	 * It gives statistics about added/removed/updated/unchanged in the end.
	 * The class also has an option to "validate" which means that no file
	 * operations are performed and only the statistics are created for what would
	 * have happened. If there's anything but "unchanged", someone probably forgot
	 * to run the codegen script.
	 *
	 * Example:
	 *
	 *   const dir = new CodegenDirectory('/some/path/generated');
	 *   // write files in case content changed (less watchman/mtime changes)
	 *   dir.writeFile('OneFile.js', contents);
	 *   dir.writeFile('OtherFile.js', contents);
	 *
	 *   // delete files that are not generated
	 *   dir.deleteExtraFiles();
	 *
	 *   // arrays of file names to print or whatever
	 *   dir.changes.created
	 *   dir.changes.updated
	 *   dir.changes.deleted
	 *   dir.changes.unchanged
	 */
	var CodegenDirectory = function () {
	  function CodegenDirectory(dir) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    (0, _classCallCheck3['default'])(this, CodegenDirectory);

	    this.onlyValidate = !!options.onlyValidate;
	    if (__webpack_require__(3).existsSync(dir)) {
	      __webpack_require__(1)(__webpack_require__(3).statSync(dir).isDirectory(), 'Expected `%s` to be a directory.', dir);
	    } else if (!this.onlyValidate) {
	      var dirs = [dir];
	      var parent = __webpack_require__(6).dirname(dir);
	      while (!__webpack_require__(3).existsSync(parent)) {
	        dirs.unshift(parent);
	        parent = __webpack_require__(6).dirname(parent);
	      }
	      dirs.forEach(function (d) {
	        return __webpack_require__(3).mkdirSync(d);
	      });
	    }
	    this._files = new Set();
	    this.changes = {
	      deleted: [],
	      updated: [],
	      created: [],
	      unchanged: []
	    };
	    this._dir = dir;
	  }

	  CodegenDirectory.combineChanges = function combineChanges(dirs) {
	    var changes = {
	      deleted: [],
	      updated: [],
	      created: [],
	      unchanged: []
	    };
	    dirs.forEach(function (dir) {
	      var _changes$deleted, _changes$updated, _changes$created, _changes$unchanged;

	      (_changes$deleted = changes.deleted).push.apply(_changes$deleted, (0, _toConsumableArray3['default'])(dir.changes.deleted));
	      (_changes$updated = changes.updated).push.apply(_changes$updated, (0, _toConsumableArray3['default'])(dir.changes.updated));
	      (_changes$created = changes.created).push.apply(_changes$created, (0, _toConsumableArray3['default'])(dir.changes.created));
	      (_changes$unchanged = changes.unchanged).push.apply(_changes$unchanged, (0, _toConsumableArray3['default'])(dir.changes.unchanged));
	    });
	    return changes;
	  };

	  CodegenDirectory.hasChanges = function hasChanges(changes) {
	    return changes.created.length > 0 || changes.updated.length > 0 || changes.deleted.length > 0;
	  };

	  CodegenDirectory.printChanges = function printChanges(changes, options) {
	    __webpack_require__(2).run('CodegenDirectory.printChanges', function () {
	      var output = [];
	      function printFiles(label, files) {
	        if (files.length > 0) {
	          output.push(label + ':');
	          files.forEach(function (file) {
	            output.push(' - ' + file);
	          });
	        }
	      }
	      if (options.onlyValidate) {
	        printFiles('Missing', changes.created);
	        printFiles('Out of date', changes.updated);
	        printFiles('Extra', changes.deleted);
	      } else {
	        printFiles('Created', changes.created);
	        printFiles('Updated', changes.updated);
	        printFiles('Deleted', changes.deleted);
	        output.push('Unchanged: ' + changes.unchanged.length + ' files');
	      }
	      // eslint-disable-next-line no-console
	      console.log(output.join('\n'));
	    });
	  };

	  CodegenDirectory.sourceControlAddRemove = (() => {
	    var _ref = (0, _asyncToGenerator3.default)(function* (sourceControl, dirs) {
	      var allAdded = [];
	      var allRemoved = [];
	      dirs.forEach(function (dir) {
	        dir.changes.created.forEach(function (name) {
	          allAdded.push(dir.getPath(name));
	        });
	        dir.changes.deleted.forEach(function (name) {
	          allRemoved.push(dir.getPath(name));
	        });
	      });
	      sourceControl.addRemove(allAdded, allRemoved);
	    });

	    function sourceControlAddRemove(_x2, _x3) {
	      return _ref.apply(this, arguments);
	    }

	    return sourceControlAddRemove;
	  })();

	  CodegenDirectory.prototype.printChanges = function printChanges() {
	    CodegenDirectory.printChanges(this.changes, {
	      onlyValidate: this.onlyValidate
	    });
	  };

	  CodegenDirectory.prototype.read = function read(filename) {
	    var filePath = __webpack_require__(6).join(this._dir, filename);
	    if (__webpack_require__(3).existsSync(filePath)) {
	      return __webpack_require__(3).readFileSync(filePath, 'utf8');
	    }
	    return null;
	  };

	  CodegenDirectory.prototype.markUnchanged = function markUnchanged(filename) {
	    this._addGenerated(filename);
	    this.changes.unchanged.push(filename);
	  };

	  /**
	   * Marks a files as updated or out of date without actually writing the file.
	   * This is probably only be useful when doing validation without intention to
	   * actually write to disk.
	   */


	  CodegenDirectory.prototype.markUpdated = function markUpdated(filename) {
	    this._addGenerated(filename);
	    this.changes.updated.push(filename);
	  };

	  CodegenDirectory.prototype.writeFile = function writeFile(filename, content) {
	    var _this = this;

	    __webpack_require__(2).run('CodegenDirectory.writeFile', function () {
	      _this._addGenerated(filename);
	      var filePath = __webpack_require__(6).join(_this._dir, filename);
	      if (__webpack_require__(3).existsSync(filePath)) {
	        var existingContent = __webpack_require__(3).readFileSync(filePath, 'utf8');
	        if (existingContent === content) {
	          _this.changes.unchanged.push(filename);
	        } else {
	          _this._writeFile(filePath, content);
	          _this.changes.updated.push(filename);
	        }
	      } else {
	        _this._writeFile(filePath, content);
	        _this.changes.created.push(filename);
	      }
	    });
	  };

	  CodegenDirectory.prototype._writeFile = function _writeFile(filePath, content) {
	    if (!this.onlyValidate) {
	      __webpack_require__(3).writeFileSync(filePath, content, 'utf8');
	    }
	  };

	  /**
	   * Deletes all non-generated files, except for invisible "dot" files (ie.
	   * files with names starting with ".").
	   */


	  CodegenDirectory.prototype.deleteExtraFiles = function deleteExtraFiles() {
	    var _this2 = this;

	    __webpack_require__(2).run('CodegenDirectory.deleteExtraFiles', function () {
	      __webpack_require__(3).readdirSync(_this2._dir).forEach(function (actualFile) {
	        if (!_this2._files.has(actualFile) && !/^\./.test(actualFile)) {
	          if (!_this2.onlyValidate) {
	            try {
	              __webpack_require__(3).unlinkSync(__webpack_require__(6).join(_this2._dir, actualFile));
	            } catch (e) {
	              throw new Error('CodegenDirectory: Failed to delete `' + actualFile + '` in `' + _this2._dir + '`.');
	            }
	          }
	          _this2.changes.deleted.push(actualFile);
	        }
	      });
	    });
	  };

	  CodegenDirectory.prototype.getPath = function getPath(filename) {
	    return __webpack_require__(6).join(this._dir, filename);
	  };

	  CodegenDirectory.prototype._addGenerated = function _addGenerated(filename) {
	    __webpack_require__(1)(!this._files.has(filename), 'CodegenDirectory: Tried to generate `%s` twice in `%s`.', filename, this._dir);
	    this._files.add(filename);
	  };

	  return CodegenDirectory;
	}();

	module.exports = CodegenDirectory;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */
	'use strict';

	var _asyncToGenerator2 = __webpack_require__(10);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	let queryFiles = (() => {
	  var _ref3 = (0, _asyncToGenerator3.default)(function* (baseDir, expression, filter) {
	    return yield __webpack_require__(2).waitFor('Watchman:query', (0, _asyncToGenerator3.default)(function* () {
	      var client = new (__webpack_require__(16))();

	      var _ref = yield Promise.all([client.watchProject(baseDir), getFields(client)]),
	          watchResp = _ref[0],
	          fields = _ref[1];

	      var resp = yield client.command('query', watchResp.root, {
	        expression: expression,
	        fields: fields,
	        relative_root: watchResp.relativePath
	      });
	      client.end();
	      return updateFiles(new Set(), baseDir, filter, resp.files);
	    }));
	  });

	  return function queryFiles(_x, _x2, _x3) {
	    return _ref3.apply(this, arguments);
	  };
	})();

	let getFields = (() => {
	  var _ref5 = (0, _asyncToGenerator3.default)(function* (client) {
	    var fields = ['name', 'exists'];
	    if (yield client.hasCapability('field-content.sha1hex')) {
	      fields.push('content.sha1hex');
	    }
	    return fields;
	  });

	  return function getFields(_x4) {
	    return _ref5.apply(this, arguments);
	  };
	})();

	// For use when not using Watchman.


	let queryFilepaths = (() => {
	  var _ref6 = (0, _asyncToGenerator3.default)(function* (baseDir, filepaths, filter) {
	    // Construct WatchmanChange objects as an intermediate step before
	    // calling updateFiles to produce file content.
	    var files = filepaths.map(function (filepath) {
	      return {
	        name: filepath,
	        exists: true,
	        'content.sha1hex': null
	      };
	    });
	    return updateFiles(new Set(), baseDir, filter, files);
	  });

	  return function queryFilepaths(_x5, _x6, _x7) {
	    return _ref6.apply(this, arguments);
	  };
	})();

	/**
	 * Provides a simplified API to the watchman API.
	 * Given some base directory and a list of subdirectories it calls the callback
	 * with watchman change events on file changes.
	 */


	let watch = (() => {
	  var _ref7 = (0, _asyncToGenerator3.default)(function* (baseDir, expression, callback) {
	    return yield __webpack_require__(2).waitFor('Watchman:subscribe', (0, _asyncToGenerator3.default)(function* () {
	      var client = new (__webpack_require__(16))();
	      var watchResp = yield client.watchProject(baseDir);

	      yield makeSubscription(client, watchResp.root, watchResp.relativePath, expression, callback);
	    }));
	  });

	  return function watch(_x8, _x9, _x10) {
	    return _ref7.apply(this, arguments);
	  };
	})();

	let makeSubscription = (() => {
	  var _ref9 = (0, _asyncToGenerator3.default)(function* (client, root, relativePath, expression, callback) {
	    client.on('subscription', function (resp) {
	      if (resp.subscription === SUBSCRIPTION_NAME) {
	        callback(resp);
	      }
	    });
	    var fields = yield getFields(client);
	    yield client.command('subscribe', root, SUBSCRIPTION_NAME, {
	      expression: expression,
	      fields: fields,
	      relative_root: relativePath
	    });
	  });

	  return function makeSubscription(_x11, _x12, _x13, _x14, _x15) {
	    return _ref9.apply(this, arguments);
	  };
	})();

	/**
	 * Further simplifies `watch` and calls the callback on every change with a
	 * full list of files that match the conditions.
	 */


	let watchFiles = (() => {
	  var _ref10 = (0, _asyncToGenerator3.default)(function* (baseDir, expression, filter, callback) {
	    var files = new Set();
	    yield watch(baseDir, expression, function (changes) {
	      if (!changes.files) {
	        // Watchmen fires a change without files when a watchman state changes,
	        // for example during an hg update.
	        return;
	      }
	      files = updateFiles(files, baseDir, filter, changes.files);
	      callback(files);
	    });
	  });

	  return function watchFiles(_x16, _x17, _x18, _x19) {
	    return _ref10.apply(this, arguments);
	  };
	})();

	/**
	 * Similar to watchFiles, but takes an async function. The `compile` function
	 * is awaited and not called in parallel. If multiple changes are triggered
	 * before a compile finishes, the latest version is called after the compile
	 * finished.
	 *
	 * TODO: Consider changing from a Promise to abortable, so we can abort mid
	 *       compilation.
	 */


	let watchCompile = (() => {
	  var _ref11 = (0, _asyncToGenerator3.default)(function* (baseDir, expression, filter, compile) {
	    var compiling = false;
	    var needsCompiling = false;
	    var latestFiles = null;

	    watchFiles(baseDir, expression, filter, (() => {
	      var _ref12 = (0, _asyncToGenerator3.default)(function* (files) {
	        needsCompiling = true;
	        latestFiles = files;
	        if (compiling) {
	          return;
	        }
	        compiling = true;
	        while (needsCompiling) {
	          needsCompiling = false;
	          yield compile(latestFiles);
	        }
	        compiling = false;
	      });

	      return function (_x24) {
	        return _ref12.apply(this, arguments);
	      };
	    })());
	  });

	  return function watchCompile(_x20, _x21, _x22, _x23) {
	    return _ref11.apply(this, arguments);
	  };
	})();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var SUBSCRIPTION_NAME = 'graphql-codegen';

	function updateFiles(files, baseDir, filter, fileChanges) {
	  var fileMap = new Map();
	  files.forEach(function (file) {
	    file.exists && fileMap.set(file.relPath, file);
	  });

	  fileChanges.forEach(function (_ref2) {
	    var name = _ref2.name,
	        exists = _ref2.exists,
	        hash = _ref2['content.sha1hex'];

	    var shouldRemove = !exists;
	    if (!shouldRemove) {
	      var _file = {
	        exists: true,
	        relPath: name,
	        hash: hash || hashFile(__webpack_require__(6).join(baseDir, name))
	      };
	      if (filter(_file)) {
	        fileMap.set(name, _file);
	      } else {
	        shouldRemove = true;
	      }
	    }
	    shouldRemove && fileMap.set(name, {
	      exists: false,
	      relPath: name
	    });
	  });
	  return new Set(fileMap.values());
	}

	function hashFile(filename) {
	  var content = __webpack_require__(3).readFileSync(filename);
	  return __webpack_require__(46).createHash('sha1').update(content).digest('hex');
	}

	module.exports = {
	  queryFiles: queryFiles,
	  queryFilepaths: queryFilepaths,
	  watch: watch,
	  watchFiles: watchFiles,
	  watchCompile: watchCompile
	};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */
	'use strict';

	var _asyncToGenerator2 = __webpack_require__(10);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(4));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var GraphQLWatchmanClient = function () {
	  GraphQLWatchmanClient.isAvailable = function isAvailable() {
	    return new Promise(function (resolve) {
	      var client = new GraphQLWatchmanClient();
	      client.on('error', function () {
	        resolve(false);
	        client.end();
	      });
	      client.hasCapability('relative_root').then(function (hasRelativeRoot) {
	        resolve(hasRelativeRoot);
	        client.end();
	      }, function () {
	        resolve(false);
	        client.end();
	      });
	    });
	  };

	  function GraphQLWatchmanClient() {
	    (0, _classCallCheck3['default'])(this, GraphQLWatchmanClient);

	    this._client = new (__webpack_require__(47).Client)();
	  }

	  GraphQLWatchmanClient.prototype.command = function command() {
	    var _this = this;

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return new Promise(function (resolve, reject) {
	      _this._client.command(args, function (error, response) {
	        if (error) {
	          reject(error);
	        } else {
	          resolve(response);
	        }
	      });
	    });
	  };

	  GraphQLWatchmanClient.prototype.hasCapability = (() => {
	    var _ref = (0, _asyncToGenerator3.default)(function* (capability) {
	      var resp = yield this.command('list-capabilities');
	      return resp.capabilities.includes(capability);
	    });

	    function hasCapability(_x) {
	      return _ref.apply(this, arguments);
	    }

	    return hasCapability;
	  })();

	  GraphQLWatchmanClient.prototype.watchProject = (() => {
	    var _ref2 = (0, _asyncToGenerator3.default)(function* (baseDir) {
	      var resp = yield this.command('watch-project', baseDir);
	      if ('warning' in resp) {
	        console.error('Warning:', resp.warning);
	      }
	      return {
	        root: resp.watch,
	        relativePath: resp.relative_path
	      };
	    });

	    function watchProject(_x2) {
	      return _ref2.apply(this, arguments);
	    }

	    return watchProject;
	  })();

	  GraphQLWatchmanClient.prototype.on = function on(event, callback) {
	    this._client.on(event, callback);
	  };

	  GraphQLWatchmanClient.prototype.end = function end() {
	    this._client.end();
	  };

	  return GraphQLWatchmanClient;
	}();

	module.exports = GraphQLWatchmanClient;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	module.exports = require("immutable");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(21),
	    DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;

	var _require2 = __webpack_require__(5),
	    GraphQLEnumType = _require2.GraphQLEnumType,
	    GraphQLInputObjectType = _require2.GraphQLInputObjectType,
	    GraphQLList = _require2.GraphQLList,
	    GraphQLNonNull = _require2.GraphQLNonNull;

	var INDENT = '  ';

	/**
	 * Converts a GraphQLIR node into a GraphQL string. Custom Relay
	 * extensions (directives) are not supported; to print fragments with
	 * variables or fragment spreads with arguments, transform the node
	 * prior to printing.
	 */
	function print(node) {
	  if (node.kind === 'Fragment') {
	    return 'fragment ' + node.name + ' on ' + String(node.type) + printFragmentArgumentDefinitions(node.argumentDefinitions) + printDirectives(node.directives) + printSelections(node, '') + '\n';
	  } else if (node.kind === 'Root') {
	    return node.operation + ' ' + node.name + printArgumentDefinitions(node.argumentDefinitions) + printDirectives(node.directives) + printSelections(node, '') + '\n';
	  } else {
	    __webpack_require__(1)(false, 'GraphQLIRPrinter: Unsupported IR node `%s`.', node.kind);
	  }
	}

	function printSelections(node, indent, parentCondition) {
	  var selections = node.selections;
	  if (selections == null) {
	    return '';
	  }
	  var printed = selections.map(function (selection) {
	    return printSelection(selection, indent, parentCondition);
	  });
	  return printed.length ? ' {\n' + (indent + INDENT) + printed.join('\n' + indent + INDENT) + '\n' + indent + '}' : '';
	}

	/**
	 * Prints a field without subselections.
	 */
	function printField(field) {
	  var parentCondition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

	  return (field.alias != null ? field.alias + ': ' + field.name : field.name) + printArguments(field.args) + parentCondition + printDirectives(field.directives) + printHandles(field);
	}

	function printSelection(selection, indent, parentCondition) {
	  parentCondition = parentCondition || '';
	  var str = void 0;
	  if (selection.kind === 'LinkedField') {
	    str = printField(selection, parentCondition);
	    str += printSelections(selection, indent + INDENT);
	  } else if (selection.kind === 'ScalarField') {
	    str = printField(selection, parentCondition);
	  } else if (selection.kind === 'InlineFragment') {
	    str = '... on ' + selection.typeCondition.toString();
	    str += parentCondition;
	    str += printDirectives(selection.directives);
	    str += printSelections(selection, indent + INDENT);
	  } else if (selection.kind === 'FragmentSpread') {
	    str = '...' + selection.name;
	    str += parentCondition;
	    str += printFragmentArguments(selection.args);
	    str += printDirectives(selection.directives);
	  } else if (selection.kind === 'DeferrableFragmentSpread') {
	    str = selection.alias + ': ' + selection.storageKey;
	  } else if (selection.kind === 'Condition') {
	    var value = printValue(selection.condition);
	    // For Flow
	    __webpack_require__(1)(value != null, 'GraphQLIRPrinter: Expected a variable for condition, got a literal `null`.');
	    var condStr = selection.passingValue ? ' @include' : ' @skip';
	    condStr += '(if: ' + value + ')';
	    condStr += parentCondition;
	    // For multi-selection conditions, pushes the condition down to each
	    var subSelections = selection.selections.map(function (sel) {
	      return printSelection(sel, indent, condStr);
	    });
	    str = subSelections.join('\n' + INDENT);
	  } else {
	    __webpack_require__(1)(false, 'GraphQLIRPrinter: Unknown selection kind `%s`.', selection.kind);
	  }
	  return str;
	}

	function printArgumentDefinitions(argumentDefinitions) {
	  var printed = argumentDefinitions.map(function (def) {
	    var str = '$' + def.name + ': ' + def.type.toString();
	    if (def.defaultValue != null) {
	      str += ' = ' + printLiteral(def.defaultValue, def.type);
	    }
	    return str;
	  });
	  return printed.length ? '(\n' + INDENT + printed.join('\n' + INDENT) + '\n)' : '';
	}

	function printFragmentArgumentDefinitions(argumentDefinitions) {
	  var printed = void 0;
	  argumentDefinitions.forEach(function (def) {
	    if (def.kind !== 'LocalArgumentDefinition') {
	      return;
	    }
	    printed = printed || [];
	    var str = def.name + ': {type: "' + def.type.toString() + '"';
	    if (def.defaultValue != null) {
	      str += ', defaultValue: ' + printLiteral(def.defaultValue, def.type);
	    }
	    str += '}';
	    printed.push(str);
	  });
	  return printed && printed.length ? ' @argumentDefinitions(\n' + INDENT + printed.join('\n' + INDENT) + '\n)' : '';
	}

	function printHandles(field) {
	  if (!field.handles) {
	    return '';
	  }
	  var printed = field.handles.map(function (handle) {
	    // For backward compatibility and also because this module is shared by ComponentScript.
	    var key = handle.key === DEFAULT_HANDLE_KEY ? '' : ', key: "' + handle.key + '"';
	    var filters = handle.filters == null ? '' : ', filters: ' + JSON.stringify(handle.filters.sort());
	    return '@__clientField(handle: "' + handle.name + '"' + key + filters + ')';
	  });
	  return printed.length ? ' ' + printed.join(' ') : '';
	}

	function printDirectives(directives) {
	  var printed = directives.map(function (directive) {
	    return '@' + directive.name + printArguments(directive.args);
	  });
	  return printed.length ? ' ' + printed.join(' ') : '';
	}

	function printFragmentArguments(args) {
	  var printedArgs = printArguments(args);
	  if (!printedArgs.length) {
	    return '';
	  }
	  return ' @arguments' + printedArgs;
	}

	function printArguments(args) {
	  var printed = [];
	  args.forEach(function (arg) {
	    var printedValue = printValue(arg.value, arg.type);
	    if (printedValue != null) {
	      printed.push(arg.name + ': ' + printedValue);
	    }
	  });
	  return printed.length ? '(' + printed.join(', ') + ')' : '';
	}

	function printValue(value, type) {
	  if (type instanceof GraphQLNonNull) {
	    type = type.ofType;
	  }
	  if (value.kind === 'Variable') {
	    return '$' + value.variableName;
	  } else if (value.kind === 'ObjectValue') {
	    __webpack_require__(1)(type instanceof GraphQLInputObjectType, 'GraphQLIRPrinter: Need an InputObject type to print objects.');

	    var typeFields = type.getFields();
	    var pairs = value.fields.map(function (field) {
	      var innerValue = printValue(field.value, typeFields[field.name].type);
	      return innerValue == null ? null : field.name + ': ' + innerValue;
	    }).filter(Boolean);

	    return '{' + pairs.join(', ') + '}';
	  } else if (value.kind === 'ListValue') {
	    __webpack_require__(1)(type instanceof GraphQLList, 'GraphQLIRPrinter: Need a type in order to print arrays.');
	    var innerType = type.ofType;
	    return '[' + value.items.map(function (i) {
	      return printValue(i, innerType);
	    }).join(', ') + ']';
	  } else if (value.value != null) {
	    return printLiteral(value.value, type);
	  } else {
	    return null;
	  }
	}

	function printLiteral(value, type) {
	  if (type instanceof GraphQLNonNull) {
	    type = type.ofType;
	  }
	  if (type instanceof GraphQLEnumType) {
	    __webpack_require__(1)(typeof value === 'string', 'GraphQLIRPrinter: Expected value of type %s to be a string, got `%s`.', type.name, value);
	    return value;
	  }
	  if (Array.isArray(value)) {
	    __webpack_require__(1)(type instanceof GraphQLList, 'GraphQLIRPrinter: Need a type in order to print arrays.');
	    var itemType = type.ofType;
	    return '[' + value.map(function (item) {
	      return printLiteral(item, itemType);
	    }).join(', ') + ']';
	  } else if (typeof value === 'object' && value) {
	    var fields = [];
	    __webpack_require__(1)(type instanceof GraphQLInputObjectType, 'GraphQLIRPrinter: Need an InputObject type to print objects.');
	    var typeFields = type.getFields();
	    for (var key in value) {
	      if (value.hasOwnProperty(key)) {
	        fields.push(key + ': ' + printLiteral(value[key], typeFields[key].type));
	      }
	    }
	    return '{' + fields.join(', ') + '}';
	  } else if (type instanceof GraphQLList && value != null) {
	    // Not an array, but still a list. Treat as list-of-one as per spec 3.1.7:
	    // http://facebook.github.io/graphql/October2016/#sec-Lists
	    return printLiteral(value, type.ofType);
	  } else {
	    return JSON.stringify(value);
	  }
	}

	module.exports = { print: print, printField: printField, printArguments: printArguments, printDirectives: printDirectives };

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */
	'use strict';

	var visit = __webpack_require__(5).visit;

	var NodeKeys = {
	  Argument: ['value'],
	  Batch: ['requests', 'fragment'],
	  Condition: ['condition', 'selections'],
	  Directive: ['args'],
	  Fragment: ['argumentDefinitions', 'directives', 'selections'],
	  FragmentSpread: ['args', 'directives'],
	  InlineFragment: ['directives', 'selections'],
	  LinkedField: ['args', 'directives', 'selections'],
	  Literal: [],
	  LocalArgumentDefinition: [],
	  Request: ['root'],
	  Root: ['argumentDefinitions', 'directives', 'selections'],
	  RootArgumentDefinition: [],
	  ScalarField: ['args', 'directives'],
	  Variable: [],
	  DeferrableFragmentSpread: ['args', 'directives', 'fragmentArgs']
	};

	function visitIR(root, visitor) {
	  return visit(root, visitor, NodeKeys);
	}

	module.exports = { visit: visitIR };

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(4));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(17),
	    ImmutableMap = _require.Map;

	var ASTCache = function () {
	  function ASTCache(config) {
	    (0, _classCallCheck3['default'])(this, ASTCache);

	    this._documents = new Map();
	    this._baseDir = config.baseDir;
	    this._parse = __webpack_require__(2).instrument(config.parse, 'ASTCache.parseFn');
	  }

	  // Short-term: we don't do subscriptions/delta updates, instead always use all definitions


	  ASTCache.prototype.documents = function documents() {
	    return ImmutableMap(this._documents);
	  };

	  // parse should return the set of changes


	  ASTCache.prototype.parseFiles = function parseFiles(files) {
	    var _this = this;

	    var documents = ImmutableMap();

	    files.forEach(function (file) {
	      if (!file.exists) {
	        _this._documents['delete'](file.relPath);
	        return;
	      }

	      var doc = function () {
	        try {
	          return _this._parse(_this._baseDir, file);
	        } catch (error) {
	          throw new Error('Parse error: ' + error + ' in "' + file.relPath + '"');
	        }
	      }();

	      if (!doc) {
	        _this._documents['delete'](file.relPath);
	        return;
	      }

	      documents = documents.set(file.relPath, doc);
	      _this._documents.set(file.relPath, doc);
	    });

	    return documents;
	  };

	  return ASTCache;
	}();

	module.exports = ASTCache;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	module.exports = {
	  DEFAULT_HANDLE_KEY: ''
	};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(4));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(23),
	    createUserError = _require.createUserError;

	var _require2 = __webpack_require__(17),
	    ImmutableOrderedMap = _require2.OrderedMap;

	/**
	 * An immutable representation of a corpus of documents being compiled together.
	 * For each document, the context stores the IR and any validation errors.
	 */
	var GraphQLCompilerContext = function () {
	  function GraphQLCompilerContext(serverSchema, clientSchema) {
	    (0, _classCallCheck3['default'])(this, GraphQLCompilerContext);

	    this._isMutable = false;
	    this._documents = new ImmutableOrderedMap();
	    this._withTransform = new WeakMap();
	    this.serverSchema = serverSchema;
	    // If a separate client schema doesn't exist, use the server schema.
	    this.clientSchema = clientSchema || serverSchema;
	  }

	  /**
	   * Returns the documents for the context in the order they were added.
	   */


	  GraphQLCompilerContext.prototype.documents = function documents() {
	    return this._documents.toArray();
	  };

	  GraphQLCompilerContext.prototype.forEachDocument = function forEachDocument(fn) {
	    this._documents.forEach(fn);
	  };

	  GraphQLCompilerContext.prototype.replace = function replace(node) {
	    return this._update(this._documents.update(node.name, function (existing) {
	      __webpack_require__(1)(existing, 'GraphQLCompilerContext: Expected to replace existing node %s, but' + 'one was not found in the context.', node.name);
	      return node;
	    }));
	  };

	  GraphQLCompilerContext.prototype.add = function add(node) {
	    return this._update(this._documents.update(node.name, function (existing) {
	      __webpack_require__(1)(!existing, 'GraphQLCompilerContext: Duplicate document named `%s`. GraphQL ' + 'fragments and roots must have unique names.', node.name);
	      return node;
	    }));
	  };

	  GraphQLCompilerContext.prototype.addAll = function addAll(nodes) {
	    return this.withMutations(function (mutable) {
	      return nodes.reduce(function (ctx, definition) {
	        return ctx.add(definition);
	      }, mutable);
	    });
	  };

	  /**
	   * Apply a list of compiler transforms and return a new compiler context.
	   */


	  GraphQLCompilerContext.prototype.applyTransforms = function applyTransforms(transforms, reporter) {
	    var _this = this;

	    return __webpack_require__(2).run('applyTransforms', function () {
	      return transforms.reduce(function (ctx, transform) {
	        return ctx.applyTransform(transform, reporter);
	      }, _this);
	    });
	  };

	  /**
	   * Applies a transform to this context, returning a new context.
	   *
	   * This is memoized such that applying the same sequence of transforms will
	   * not result in duplicated work.
	   */


	  GraphQLCompilerContext.prototype.applyTransform = function applyTransform(transform, reporter) {
	    var transformed = this._withTransform.get(transform);
	    if (!transformed) {
	      var start = process.hrtime();
	      transformed = __webpack_require__(2).instrument(transform)(this);
	      var delta = process.hrtime(start);
	      var deltaMs = Math.round((delta[0] * 1e9 + delta[1]) / 1e6);
	      reporter && reporter.reportTime(transform.name, deltaMs);
	      this._withTransform.set(transform, transformed);
	    }
	    return transformed;
	  };

	  GraphQLCompilerContext.prototype.get = function get(name) {
	    return this._documents.get(name);
	  };

	  GraphQLCompilerContext.prototype.getFragment = function getFragment(name) {
	    var node = this._get(name);
	    if (node.kind !== 'Fragment') {
	      var childModule = name.substring(0, name.lastIndexOf('_'));
	      throw createUserError('GraphQLCompilerContext: Cannot find fragment `%s`.' + ' Please make sure the fragment exists in `%s`.', name, childModule);
	    }
	    return node;
	  };

	  GraphQLCompilerContext.prototype.getRoot = function getRoot(name) {
	    var node = this._get(name);
	    __webpack_require__(1)(node.kind === 'Root', 'GraphQLCompilerContext: Expected `%s` to be a root, got `%s`.', name, node.kind);
	    return node;
	  };

	  GraphQLCompilerContext.prototype.remove = function remove(name) {
	    return this._update(this._documents['delete'](name));
	  };

	  GraphQLCompilerContext.prototype.withMutations = function withMutations(fn) {
	    var mutableCopy = this._update(this._documents.asMutable());
	    mutableCopy._isMutable = true;
	    var result = fn(mutableCopy);
	    result._isMutable = false;
	    result._documents = result._documents.asImmutable();
	    return this._documents === result._documents ? this : result;
	  };

	  GraphQLCompilerContext.prototype._get = function _get(name) {
	    var document = this._documents.get(name);
	    __webpack_require__(1)(document, 'GraphQLCompilerContext: Unknown document `%s`.', name);
	    return document;
	  };

	  GraphQLCompilerContext.prototype._update = function _update(documents) {
	    var context = this._isMutable ? this : new GraphQLCompilerContext(this.serverSchema, this.clientSchema);
	    context._documents = documents;
	    return context;
	  };

	  return GraphQLCompilerContext;
	}();

	module.exports = GraphQLCompilerContext;

/***/ }),
/* 23 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var createUserError = function createUserError(format) {
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }

	  var index = 0;
	  var formatted = format.replace(/%s/g, function (match) {
	    return args[index++];
	  });
	  return new Error(formatted);
	};

	module.exports = { createUserError: createUserError };

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(5),
	    formatError = _require.formatError,
	    FragmentsOnCompositeTypesRule = _require.FragmentsOnCompositeTypesRule,
	    KnownArgumentNamesRule = _require.KnownArgumentNamesRule,
	    KnownTypeNamesRule = _require.KnownTypeNamesRule,
	    LoneAnonymousOperationRule = _require.LoneAnonymousOperationRule,
	    NoUnusedVariablesRule = _require.NoUnusedVariablesRule,
	    PossibleFragmentSpreadsRule = _require.PossibleFragmentSpreadsRule,
	    ProvidedNonNullArgumentsRule = _require.ProvidedNonNullArgumentsRule,
	    ScalarLeafsRule = _require.ScalarLeafsRule,
	    UniqueArgumentNamesRule = _require.UniqueArgumentNamesRule,
	    UniqueFragmentNamesRule = _require.UniqueFragmentNamesRule,
	    UniqueInputFieldNamesRule = _require.UniqueInputFieldNamesRule,
	    UniqueOperationNamesRule = _require.UniqueOperationNamesRule,
	    UniqueVariableNamesRule = _require.UniqueVariableNamesRule,
	    validate = _require.validate,
	    ValuesOfCorrectTypeRule = _require.ValuesOfCorrectTypeRule,
	    VariablesAreInputTypesRule = _require.VariablesAreInputTypesRule,
	    VariablesDefaultValueAllowedRule = _require.VariablesDefaultValueAllowedRule,
	    VariablesInAllowedPositionRule = _require.VariablesInAllowedPositionRule;

	function validateOrThrow(document, schema, rules) {
	  var validationErrors = validate(schema, document, rules);
	  if (validationErrors && validationErrors.length > 0) {
	    var formattedErrors = validationErrors.map(formatError);
	    var errorMessages = validationErrors.map(function (e) {
	      return e.source ? e.source.name + ': ' + e.message : e.message;
	    });

	    var error = new Error(__webpack_require__(48).format('You supplied a GraphQL document with validation errors:\n%s', errorMessages.join('\n')));
	    error.validationErrors = formattedErrors;
	    throw error;
	  }
	}

	module.exports = {
	  GLOBAL_RULES: [KnownArgumentNamesRule,
	  // TODO #19327202 Relay Classic generates some fragments in runtime, so Relay
	  // Modern queries might reference fragments unknown in build time
	  // KnownFragmentNamesRule,
	  // TODO: #25618795 Because of @argumentDefinitions, this validation
	  // incorrectly flags a subset of fragments using @include/@skip as recursive.
	  // NoFragmentCyclesRule,
	  // TODO #19327144 Because of @argumentDefinitions, this validation
	  // incorrectly marks some fragment variables as undefined.
	  // NoUndefinedVariablesRule,
	  // TODO #19327202 Queries generated dynamically with Relay Classic might use
	  // unused fragments
	  // NoUnusedFragmentsRule,
	  NoUnusedVariablesRule,
	  // TODO #19327202 Relay Classic auto-resolves overlapping fields by
	  // generating aliases
	  //OverlappingFieldsCanBeMergedRule,
	  ProvidedNonNullArgumentsRule, UniqueArgumentNamesRule, UniqueFragmentNamesRule, UniqueInputFieldNamesRule, UniqueOperationNamesRule, UniqueVariableNamesRule],
	  LOCAL_RULES: [
	  // TODO #13818691: make this aware of @fixme_fat_interface
	  // FieldsOnCorrectTypeRule,
	  FragmentsOnCompositeTypesRule, KnownTypeNamesRule,
	  // TODO #17737009: Enable this after cleaning up existing issues
	  // KnownDirectivesRule,
	  LoneAnonymousOperationRule, PossibleFragmentSpreadsRule, ScalarLeafsRule, VariablesDefaultValueAllowedRule, ValuesOfCorrectTypeRule, VariablesAreInputTypesRule, VariablesInAllowedPositionRule],
	  validate: __webpack_require__(2).instrument(validateOrThrow, 'GraphQLValidator.validate')
	};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(18),
	    printArguments = _require.printArguments,
	    printDirectives = _require.printDirectives;

	/**
	 * Generates an identifier that is unique to a given selection: the alias for
	 * fields, the type for inline fragments, and a summary of the condition
	 * variable and passing value for conditions.
	 */
	function getIdentifierForSelection(node) {
	  if (node.kind === 'LinkedField' || node.kind === 'ScalarField') {
	    return node.directives.length === 0 ? node.alias || node.name : (node.alias || node.name) + printDirectives(node.directives);
	  } else if (node.kind === 'FragmentSpread' || node.kind === 'DeferrableFragmentSpread') {
	    return node.args.length === 0 ? '...' + node.name : '...' + node.name + printArguments(node.args);
	  } else if (node.kind === 'InlineFragment') {
	    return 'I:' + node.typeCondition.name;
	  } else if (node.kind === 'Condition') {
	    return 'C:' + (node.condition.kind === 'Variable' ? '$' + node.condition.variableName : String(node.condition.value)) + String(node.passingValue);
	  } else {
	    __webpack_require__(1)(false, 'getIdentifierForSelection: Unexpected kind `%s`.', node.kind);
	  }
	}

	module.exports = getIdentifierForSelection;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(12));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(8),
	    isExecutableDefinitionAST = _require.isExecutableDefinitionAST,
	    isSchemaDefinitionAST = _require.isSchemaDefinitionAST;

	var _require2 = __webpack_require__(5),
	    extendSchema = _require2.extendSchema,
	    parse = _require2.parse,
	    visit = _require2.visit;

	function convertASTDocuments(schema, documents, validationRules, transform) {
	  return __webpack_require__(2).run('ASTConvert.convertASTDocuments', function () {
	    var definitions = definitionsFromDocuments(documents);

	    var astDefinitions = [];
	    documents.forEach(function (doc) {
	      doc.definitions.forEach(function (definition) {
	        if (isExecutableDefinitionAST(definition)) {
	          astDefinitions.push(definition);
	        }
	      });
	    });

	    return convertASTDefinitions(schema, definitions, validationRules, transform);
	  });
	}

	function convertASTDocumentsWithBase(schema, baseDocuments, documents, validationRules, transform) {
	  return __webpack_require__(2).run('ASTConvert.convertASTDocumentsWithBase', function () {
	    var baseDefinitions = definitionsFromDocuments(baseDocuments);
	    var definitions = definitionsFromDocuments(documents);

	    var requiredDefinitions = new Map();
	    var baseMap = new Map();
	    baseDefinitions.forEach(function (definition) {
	      if (isExecutableDefinitionAST(definition)) {
	        var definitionName = definition.name && definition.name.value;
	        // If there's no name, no reason to put in the map
	        if (definitionName) {
	          if (baseMap.has(definitionName)) {
	            throw new Error('Duplicate definition of \'' + definitionName + '\'.');
	          }
	          baseMap.set(definitionName, definition);
	        }
	      }
	    });

	    var definitionsToVisit = [];
	    definitions.forEach(function (definition) {
	      if (isExecutableDefinitionAST(definition)) {
	        definitionsToVisit.push(definition);
	      }
	    });
	    while (definitionsToVisit.length > 0) {
	      var _definition = definitionsToVisit.pop();
	      var name = _definition.name && _definition.name.value;
	      if (!name) {
	        continue;
	      }
	      if (requiredDefinitions.has(name)) {
	        if (requiredDefinitions.get(name) !== _definition) {
	          throw new Error('Duplicate definition of \'' + name + '\'.');
	        }
	        continue;
	      }
	      requiredDefinitions.set(name, _definition);
	      visit(_definition, {
	        FragmentSpread: function FragmentSpread(spread) {
	          var baseDefinition = baseMap.get(spread.name.value);
	          if (baseDefinition) {
	            // We only need to add those definitions not already included
	            // in definitions
	            definitionsToVisit.push(baseDefinition);
	          }
	        }
	      });
	    }

	    var definitionsToConvert = [];
	    requiredDefinitions.forEach(function (definition) {
	      return definitionsToConvert.push(definition);
	    });
	    return convertASTDefinitions(schema, definitionsToConvert, validationRules, transform);
	  });
	}

	function convertASTDefinitions(schema, definitions, validationRules, transform) {
	  var operationDefinitions = [];
	  definitions.forEach(function (definition) {
	    if (isExecutableDefinitionAST(definition)) {
	      operationDefinitions.push(definition);
	    }
	  });

	  var validationAST = {
	    kind: 'Document',
	    // DocumentNode doesn't accept that a node of type
	    // FragmentDefinitionNode | OperationDefinitionNode is a DefinitionNode
	    definitions: operationDefinitions
	  };
	  // Will throw an error if there are validation issues
	  __webpack_require__(24).validate(validationAST, schema, validationRules);
	  return operationDefinitions.map(function (definition) {
	    return transform(schema, definition);
	  });
	}

	function definitionsFromDocuments(documents) {
	  var definitions = [];
	  documents.forEach(function (doc) {
	    doc.definitions.forEach(function (definition) {
	      return definitions.push(definition);
	    });
	  });
	  return definitions;
	}

	function transformASTSchema(schema, schemaExtensions) {
	  return __webpack_require__(2).run('ASTConvert.transformASTSchema', function () {
	    return schemaExtensions.length > 0 ? extendSchema(schema, parse(schemaExtensions.join('\n'))) : schema;
	  });
	}

	function extendASTSchema(baseSchema, documents) {
	  return __webpack_require__(2).run('ASTConvert.extendASTSchema', function () {
	    // Should be TypeSystemDefinitionNode
	    var schemaExtensions = [];
	    documents.forEach(function (doc) {
	      schemaExtensions.push.apply(schemaExtensions, (0, _toConsumableArray3['default'])(doc.definitions.filter(isSchemaDefinitionAST)));
	    });

	    if (schemaExtensions.length <= 0) {
	      return baseSchema;
	    }

	    // TODO T24511737 figure out if this is dangerous
	    return extendSchema(baseSchema, {
	      kind: 'Document',
	      definitions: schemaExtensions
	    }, { assumeValid: true });
	  });
	}

	module.exports = {
	  convertASTDocuments: convertASTDocuments,
	  convertASTDocumentsWithBase: convertASTDocumentsWithBase,
	  extendASTSchema: extendASTSchema,
	  transformASTSchema: transformASTSchema
	};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _asyncToGenerator2 = __webpack_require__(10);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(4));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(12));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(17),
	    ImmutableMap = _require.Map;

	var CodegenRunner = function () {
	  function CodegenRunner(options) {
	    var _this = this;

	    (0, _classCallCheck3['default'])(this, CodegenRunner);

	    this.parsers = {};
	    this.parserConfigs = options.parserConfigs;
	    this.writerConfigs = options.writerConfigs;
	    this.onlyValidate = options.onlyValidate;
	    this._reporter = options.reporter;
	    this._sourceControl = options.sourceControl;

	    this.parserWriters = {};
	    for (var _parser in options.parserConfigs) {
	      this.parserWriters[_parser] = new Set();
	    }

	    var _loop = function _loop(_writer) {
	      var config = options.writerConfigs[_writer];
	      config.baseParsers && config.baseParsers.forEach(function (parser) {
	        return _this.parserWriters[parser].add(_writer);
	      });
	      _this.parserWriters[config.parser].add(_writer);
	    };

	    for (var _writer in options.writerConfigs) {
	      _loop(_writer);
	    }
	  }
	  // parser => writers that are affected by it


	  CodegenRunner.prototype.compileAll = (() => {
	    var _ref = (0, _asyncToGenerator3.default)(function* () {
	      // reset the parsers
	      this.parsers = {};
	      for (var parserName in this.parserConfigs) {
	        try {
	          yield this.parseEverything(parserName);
	        } catch (e) {
	          this._reporter.reportError('CodegenRunner.compileAll', e);
	          return 'ERROR';
	        }
	      }

	      var hasChanges = false;
	      for (var writerName in this.writerConfigs) {
	        var result = yield this.write(writerName);
	        if (result === 'ERROR') {
	          return 'ERROR';
	        }
	        if (result === 'HAS_CHANGES') {
	          hasChanges = true;
	        }
	      }
	      return hasChanges ? 'HAS_CHANGES' : 'NO_CHANGES';
	    });

	    function compileAll() {
	      return _ref.apply(this, arguments);
	    }

	    return compileAll;
	  })();

	  CodegenRunner.prototype.compile = (() => {
	    var _ref2 = (0, _asyncToGenerator3.default)(function* (writerName) {
	      var _this2 = this;

	      var writerConfig = this.writerConfigs[writerName];

	      var parsers = [writerConfig.parser];
	      if (writerConfig.baseParsers) {
	        writerConfig.baseParsers.forEach(function (parser) {
	          return parsers.push(parser);
	        });
	      }
	      // Don't bother resetting the parsers
	      yield __webpack_require__(2).asyncContext('CodegenRunner:parseEverything', function () {
	        return Promise.all(parsers.map(function (parser) {
	          return _this2.parseEverything(parser);
	        }));
	      });

	      return yield this.write(writerName);
	    });

	    function compile(_x) {
	      return _ref2.apply(this, arguments);
	    }

	    return compile;
	  })();

	  CodegenRunner.prototype.getDirtyWriters = function getDirtyWriters(filePaths) {
	    var _this3 = this;

	    return __webpack_require__(2).asyncContext('CodegenRunner:getDirtyWriters', (0, _asyncToGenerator3.default)(function* () {
	      var dirtyWriters = new Set();

	      // Check if any files are in the output
	      for (var configName in _this3.writerConfigs) {
	        var config = _this3.writerConfigs[configName];
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;

	        try {
	          for (var _iterator = filePaths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var _filePath = _step.value;

	            if (config.isGeneratedFile(_filePath)) {
	              dirtyWriters.add(configName);
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator['return']) {
	              _iterator['return']();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      }

	      // Check for files in the input
	      yield Promise.all(Object.keys(_this3.parserConfigs).map(function (parserConfigName) {
	        return __webpack_require__(2).waitFor('Watchman:query', (0, _asyncToGenerator3.default)(function* () {
	          var client = new (__webpack_require__(16))();
	          var config = _this3.parserConfigs[parserConfigName];
	          var dirs = yield client.watchProject(config.baseDir);

	          var relativeFilePaths = filePaths.map(function (filePath) {
	            return __webpack_require__(6).relative(config.baseDir, filePath);
	          });

	          var query = {
	            expression: ['allof', config.watchmanExpression, ['name', relativeFilePaths, 'wholename']],
	            fields: ['exists'],
	            relative_root: dirs.relativePath
	          };

	          var result = yield client.command('query', dirs.root, query);
	          client.end();

	          if (result.files.length > 0) {
	            _this3.parserWriters[parserConfigName].forEach(function (writerName) {
	              return dirtyWriters.add(writerName);
	            });
	          }
	        }));
	      }));

	      return dirtyWriters;
	    }));
	  };

	  CodegenRunner.prototype.parseEverything = (() => {
	    var _ref5 = (0, _asyncToGenerator3.default)(function* (parserName) {
	      if (this.parsers[parserName]) {
	        // no need to parse
	        return;
	      }

	      var parserConfig = this.parserConfigs[parserName];
	      this.parsers[parserName] = parserConfig.getParser(parserConfig.baseDir);
	      var filter = parserConfig.getFileFilter ? parserConfig.getFileFilter(parserConfig.baseDir) : anyFileFilter;

	      if (parserConfig.filepaths && parserConfig.watchmanExpression) {
	        throw new Error('Provide either `watchmanExpression` or `filepaths` but not both.');
	      }

	      var files = void 0;
	      if (parserConfig.watchmanExpression) {
	        files = yield __webpack_require__(15).queryFiles(parserConfig.baseDir, parserConfig.watchmanExpression, filter);
	      } else if (parserConfig.filepaths) {
	        files = yield __webpack_require__(15).queryFilepaths(parserConfig.baseDir, parserConfig.filepaths, filter);
	      } else {
	        throw new Error('Either `watchmanExpression` or `filepaths` is required to query files');
	      }
	      this.parseFileChanges(parserName, files);
	    });

	    function parseEverything(_x2) {
	      return _ref5.apply(this, arguments);
	    }

	    return parseEverything;
	  })();

	  CodegenRunner.prototype.parseFileChanges = function parseFileChanges(parserName, files) {
	    var _this4 = this;

	    return __webpack_require__(2).run('CodegenRunner.parseFileChanges', function () {
	      var parser = _this4.parsers[parserName];
	      // this maybe should be await parser.parseFiles(files);
	      parser.parseFiles(files);
	    });
	  };

	  // We cannot do incremental writes right now.
	  // When we can, this could be writeChanges(writerName, parserName, parsedDefinitions)


	  CodegenRunner.prototype.write = function write(writerName) {
	    var _this5 = this;

	    return __webpack_require__(2).asyncContext('CodegenRunner.write', (0, _asyncToGenerator3.default)(function* () {
	      try {
	        _this5._reporter.reportMessage('\nWriting ' + writerName);
	        var _writerConfigs$writer = _this5.writerConfigs[writerName],
	            _getWriter = _writerConfigs$writer.getWriter,
	            _parser2 = _writerConfigs$writer.parser,
	            _baseParsers = _writerConfigs$writer.baseParsers,
	            _isGeneratedFile = _writerConfigs$writer.isGeneratedFile;


	        var _baseDocuments = ImmutableMap();
	        if (_baseParsers) {
	          _baseParsers.forEach(function (baseParserName) {
	            _baseDocuments = _baseDocuments.merge(_this5.parsers[baseParserName].documents());
	          });
	        }

	        // always create a new writer: we have to write everything anyways
	        var _documents = _this5.parsers[_parser2].documents();
	        var _schema = __webpack_require__(2).run('getSchema', function () {
	          return _this5.parserConfigs[_parser2].getSchema();
	        });
	        var _writer2 = _getWriter({
	          onlyValidate: _this5.onlyValidate,
	          schema: _schema,
	          documents: _documents,
	          baseDocuments: _baseDocuments,
	          sourceControl: _this5._sourceControl,
	          reporter: _this5._reporter
	        });

	        var outputDirectories = yield _writer2.writeAll();

	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	          for (var _iterator2 = outputDirectories.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var dir = _step2.value;

	            var all = [].concat((0, _toConsumableArray3['default'])(dir.changes.created), (0, _toConsumableArray3['default'])(dir.changes.updated), (0, _toConsumableArray3['default'])(dir.changes.deleted), (0, _toConsumableArray3['default'])(dir.changes.unchanged));
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;

	            try {
	              for (var _iterator3 = all[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                var filename = _step3.value;

	                var _filePath2 = dir.getPath(filename);
	                __webpack_require__(1)(_isGeneratedFile(_filePath2), 'CodegenRunner: %s returned false for isGeneratedFile, ' + 'but was in generated directory', _filePath2);
	              }
	            } catch (err) {
	              _didIteratorError3 = true;
	              _iteratorError3 = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
	                  _iterator3['return']();
	                }
	              } finally {
	                if (_didIteratorError3) {
	                  throw _iteratorError3;
	                }
	              }
	            }
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
	              _iterator2['return']();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }

	        var combinedChanges = __webpack_require__(14).combineChanges(Array.from(outputDirectories.values()));
	        __webpack_require__(14).printChanges(combinedChanges, {
	          onlyValidate: _this5.onlyValidate
	        });
	        return __webpack_require__(14).hasChanges(combinedChanges) ? 'HAS_CHANGES' : 'NO_CHANGES';
	      } catch (e) {
	        _this5._reporter.reportError('CodegenRunner.write', e);
	        return 'ERROR';
	      }
	    }));
	  };

	  CodegenRunner.prototype.watchAll = (() => {
	    var _ref7 = (0, _asyncToGenerator3.default)(function* () {
	      // get everything set up for watching
	      yield this.compileAll();

	      for (var parserName in this.parserConfigs) {
	        yield this.watch(parserName);
	      }
	    });

	    function watchAll() {
	      return _ref7.apply(this, arguments);
	    }

	    return watchAll;
	  })();

	  CodegenRunner.prototype.watch = (() => {
	    var _ref8 = (0, _asyncToGenerator3.default)(function* (parserName) {
	      var _this6 = this;

	      var parserConfig = this.parserConfigs[parserName];

	      if (!parserConfig.watchmanExpression) {
	        throw new Error('`watchmanExpression` is required to watch files');
	      }

	      // watchCompile starts with a full set of files as the changes
	      // But as we need to set everything up due to potential parser dependencies,
	      // we should prevent the first watch callback from doing anything.
	      var firstChange = true;

	      yield __webpack_require__(15).watchCompile(parserConfig.baseDir, parserConfig.watchmanExpression, parserConfig.getFileFilter ? parserConfig.getFileFilter(parserConfig.baseDir) : anyFileFilter, (() => {
	        var _ref9 = (0, _asyncToGenerator3.default)(function* (files) {
	          __webpack_require__(1)(_this6.parsers[parserName], 'Trying to watch an uncompiled parser config: %s', parserName);
	          if (firstChange) {
	            firstChange = false;
	            return;
	          }
	          var dependentWriters = [];
	          _this6.parserWriters[parserName].forEach(function (writer) {
	            return dependentWriters.push(writer);
	          });

	          try {
	            if (!_this6.parsers[parserName]) {
	              // have to load the parser and make sure all of its dependents are set
	              yield _this6.parseEverything(parserName);
	            } else {
	              _this6.parseFileChanges(parserName, files);
	            }
	            yield Promise.all(dependentWriters.map(function (writer) {
	              return _this6.write(writer);
	            }));
	          } catch (error) {
	            _this6._reporter.reportError('CodegenRunner.watch', error);
	          }
	          _this6._reporter.reportMessage('Watching for changes to ' + parserName + '...');
	        });

	        return function (_x4) {
	          return _ref9.apply(this, arguments);
	        };
	      })());
	      this._reporter.reportMessage('Watching for changes to ' + parserName + '...');
	    });

	    function watch(_x3) {
	      return _ref8.apply(this, arguments);
	    }

	    return watch;
	  })();

	  return CodegenRunner;
	}();

	function anyFileFilter(file) {
	  return true;
	}

	module.exports = CodegenRunner;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(5),
	    parse = _require.parse,
	    Source = _require.Source;

	function parseFile(baseDir, file) {
	  var text = __webpack_require__(3).readFileSync(__webpack_require__(6).join(baseDir, file.relPath), 'utf8');
	  return parse(new Source(text, file.relPath), {
	    experimentalFragmentVariables: true
	  });
	}

	exports.getParser = function getParser(baseDir) {
	  return new (__webpack_require__(20))({ baseDir: baseDir, parse: parseFile });
	};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	/**
	 * A transform that removes any directives that were not present in the
	 * server schema.
	 */
	function filterDirectivesTransform(context) {
	  return __webpack_require__(7).transform(context, {
	    Directive: visitDirective
	  });
	}

	/**
	 * @internal
	 *
	 * Skip directives not defined in the original schema.
	 */
	function visitDirective(directive) {
	  if (this.getContext().serverSchema.getDirectives().some(function (schemaDirective) {
	    return schemaDirective.name === directive.name;
	  })) {
	    return directive;
	  }
	  return null;
	}

	module.exports = {
	  transform: filterDirectivesTransform
	};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @format
	 * 
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(11));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(23),
	    createUserError = _require.createUserError;

	var _require2 = __webpack_require__(18),
	    printField = _require2.printField;

	var getRawType = __webpack_require__(8).getRawType,
	    isAbstractType = __webpack_require__(8).isAbstractType;

	/**
	 * Transform that flattens inline fragments, fragment spreads, and conditionals.
	 *
	 * Inline fragments are inlined (replaced with their selections) when:
	 * - The fragment type matches the type of its parent.
	 * - The fragment has an abstract type and the `flattenAbstractTypes` option has
	 *   been set.
	 * - The 'flattenInlineFragments' option has been set.
	 */
	function flattenTransformImpl(context, options) {
	  var state = {
	    flattenAbstractTypes: !!(options && options.flattenAbstractTypes),
	    flattenInlineFragments: !!(options && options.flattenInlineFragments),
	    parentType: null
	  };

	  return __webpack_require__(7).transform(context, {
	    Root: flattenSelections,
	    Fragment: flattenSelections,
	    Condition: flattenSelections,
	    InlineFragment: flattenSelections,
	    LinkedField: flattenSelections
	  }, function () {
	    return state;
	  });
	}

	/**
	 * @internal
	 */
	function flattenSelections(node, state) {
	  // Determine the current type.
	  var parentType = state.parentType;
	  var type = node.kind === 'Condition' ? parentType : node.kind === 'InlineFragment' ? node.typeCondition : node.type;
	  __webpack_require__(1)(type, 'FlattenTransform: Expected parent type.');

	  // Flatten the selections in this node, creating a new node with flattened
	  // selections if possible, then deeply traverse the flattened node, while
	  // keeping track of the parent type.
	  var nextSelections = new Map();
	  var hasFlattened = flattenSelectionsInto(nextSelections, node, state, type);
	  var flattenedNode = hasFlattened ? (0, _extends3['default'])({}, node, { selections: Array.from(nextSelections.values()) }) : node;
	  state.parentType = type;
	  var deeplyFlattenedNode = this.traverse(flattenedNode, state);
	  state.parentType = parentType;
	  return deeplyFlattenedNode;
	}

	/**
	 * @internal
	 */
	function flattenSelectionsInto(flattenedSelections, node, state, type) {
	  var hasFlattened = false;
	  node.selections.forEach(function (selection) {
	    if (selection.kind === 'InlineFragment' && shouldFlattenInlineFragment(selection, state, type)) {
	      hasFlattened = true;
	      flattenSelectionsInto(flattenedSelections, selection, state, type);
	      return;
	    }
	    var nodeIdentifier = __webpack_require__(25)(selection);
	    var flattenedSelection = flattenedSelections.get(nodeIdentifier);
	    // If this selection hasn't been seen before, keep track of it.
	    if (!flattenedSelection) {
	      flattenedSelections.set(nodeIdentifier, selection);
	      return;
	    }
	    // Otherwise a similar selection exists which should be merged.
	    hasFlattened = true;
	    if (flattenedSelection.kind === 'InlineFragment') {
	      __webpack_require__(1)(selection.kind === 'InlineFragment', 'FlattenTransform: Expected a ScalarField, got a %s', selection.kind);
	      flattenedSelections.set(nodeIdentifier, (0, _extends3['default'])({}, flattenedSelection, {
	        selections: mergeSelections(flattenedSelection, selection, state, selection.typeCondition)
	      }));
	    } else if (flattenedSelection.kind === 'Condition') {
	      __webpack_require__(1)(selection.kind === 'Condition', 'FlattenTransform: Expected a Condition, got a %s', selection.kind);
	      flattenedSelections.set(nodeIdentifier, (0, _extends3['default'])({}, flattenedSelection, {
	        selections: mergeSelections(flattenedSelection, selection, state, type)
	      }));
	    } else if (flattenedSelection.kind === 'FragmentSpread' || flattenedSelection.kind === 'DeferrableFragmentSpread') {
	      // Ignore duplicate fragment spreads.
	    } else if (flattenedSelection.kind === 'LinkedField') {
	      __webpack_require__(1)(selection.kind === 'LinkedField', 'FlattenTransform: Expected a LinkedField, got a %s', selection.kind);
	      // Note: arguments are intentionally reversed to avoid rebuilds
	      assertUniqueArgsForAlias(selection, flattenedSelection);
	      flattenedSelections.set(nodeIdentifier, (0, _extends3['default'])({
	        kind: 'LinkedField'
	      }, flattenedSelection, {
	        handles: mergeHandles(flattenedSelection, selection),
	        selections: mergeSelections(flattenedSelection, selection, state, selection.type)
	      }));
	    } else if (flattenedSelection.kind === 'ScalarField') {
	      __webpack_require__(1)(selection.kind === 'ScalarField', 'FlattenTransform: Expected a ScalarField, got a %s', selection.kind);
	      // Note: arguments are intentionally reversed to avoid rebuilds
	      assertUniqueArgsForAlias(selection, flattenedSelection);
	      flattenedSelections.set(nodeIdentifier, (0, _extends3['default'])({
	        kind: 'ScalarField'
	      }, flattenedSelection, {
	        // Note: arguments are intentionally reversed to avoid rebuilds
	        handles: mergeHandles(selection, flattenedSelection)
	      }));
	    } else {
	      __webpack_require__(1)(false, 'FlattenTransform: Unknown kind `%s`.', flattenedSelection.kind);
	    }
	  });
	  return hasFlattened;
	}

	/**
	 * @internal
	 */
	function mergeSelections(nodeA, nodeB, state, type) {
	  var flattenedSelections = new Map();
	  flattenSelectionsInto(flattenedSelections, nodeA, state, type);
	  flattenSelectionsInto(flattenedSelections, nodeB, state, type);
	  return Array.from(flattenedSelections.values());
	}

	/**
	 * @internal
	 * TODO(T19327202) This is redundant with OverlappingFieldsCanBeMergedRule once
	 * it can be enabled.
	 */
	function assertUniqueArgsForAlias(field, otherField) {
	  if (!areEqualFields(field, otherField)) {
	    throw createUserError('Expected all fields on the same parent with the name or alias `%s` ' + 'to have the same name and arguments. Got `%s` and `%s`.', field.alias || field.name, printField(field), printField(otherField));
	  }
	}

	/**
	 * @internal
	 */
	function shouldFlattenInlineFragment(fragment, state, type) {
	  return state.flattenInlineFragments || fragment.typeCondition.name === getRawType(type).name || state.flattenAbstractTypes && isAbstractType(fragment.typeCondition);
	}

	/**
	 * @internal
	 *
	 * Verify that two fields are equal in all properties other than their
	 * selections.
	 */
	function areEqualFields(thisField, thatField) {
	  return thisField.kind === thatField.kind && thisField.name === thatField.name && thisField.alias === thatField.alias && __webpack_require__(40)(thisField.args, thatField.args);
	}

	/**
	 * @internal
	 */
	function mergeHandles(nodeA, nodeB) {
	  if (!nodeA.handles) {
	    return nodeB.handles;
	  }
	  if (!nodeB.handles) {
	    return nodeA.handles;
	  }
	  var uniqueItems = new Map();
	  nodeA.handles.concat(nodeB.handles).forEach(function (item) {
	    return uniqueItems.set(item.name + item.key, item);
	  });
	  return Array.from(uniqueItems.values());
	}

	function transformWithOptions(options) {
	  return function flattenTransform(context) {
	    return flattenTransformImpl(context, options);
	  };
	}

	module.exports = {
	  transformWithOptions: transformWithOptions
	};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(4));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var GraphQLConsoleReporter = function () {
	  function GraphQLConsoleReporter(options) {
	    (0, _classCallCheck3['default'])(this, GraphQLConsoleReporter);

	    this._verbose = options.verbose;
	    this._quiet = options.quiet;
	  }

	  GraphQLConsoleReporter.prototype.reportMessage = function reportMessage(message) {
	    if (!this._quiet) {
	      process.stdout.write(message + '\n');
	    }
	  };

	  GraphQLConsoleReporter.prototype.reportTime = function reportTime(name, ms) {
	    /* $FlowFixMe(>=0.68.0 site=react_native_fb,react_native_oss) This comment
	     * suppresses an error found when Flow v0.68 was deployed. To see the error
	     * delete this comment and run Flow. */
	    if (this._verbose && !this.quiet) {
	      var time = ms === 0 ? __webpack_require__(13).gray(' <1ms') : ms < 1000 ? __webpack_require__(13).blue(leftPad(5, ms + 'ms')) : __webpack_require__(13).red(Math.floor(ms / 10) / 100 + 's');
	      process.stdout.write('  ' + time + ' ' + __webpack_require__(13).gray(name) + '\n');
	    }
	  };

	  GraphQLConsoleReporter.prototype.reportError = function reportError(caughtLocation, error) {
	    if (!this._quiet) {
	      process.stdout.write(__webpack_require__(13).red('ERROR:\n' + error.message + '\n'));
	      if (this._verbose) {
	        var frames = error.stack.match(/^ {4}at .*$/gm);
	        if (frames) {
	          process.stdout.write(__webpack_require__(13).gray('From: ' + caughtLocation + '\n' + frames.join('\n') + '\n'));
	        }
	      }
	    }
	  };

	  return GraphQLConsoleReporter;
	}();

	function leftPad(len, str) {
	  return new Array(len - str.length + 1).join(' ') + str;
	}

	module.exports = GraphQLConsoleReporter;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(4));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var GraphQLMultiReporter = function () {
	  function GraphQLMultiReporter() {
	    (0, _classCallCheck3['default'])(this, GraphQLMultiReporter);

	    for (var _len = arguments.length, reporters = Array(_len), _key = 0; _key < _len; _key++) {
	      reporters[_key] = arguments[_key];
	    }

	    this._reporters = reporters;
	  }

	  GraphQLMultiReporter.prototype.reportMessage = function reportMessage(message) {
	    this._reporters.forEach(function (reporter) {
	      reporter.reportMessage(message);
	    });
	  };

	  GraphQLMultiReporter.prototype.reportTime = function reportTime(name, ms) {
	    this._reporters.forEach(function (reporter) {
	      reporter.reportTime(name, ms);
	    });
	  };

	  GraphQLMultiReporter.prototype.reportError = function reportError(caughtLocation, error) {
	    this._reporters.forEach(function (reporter) {
	      reporter.reportError(caughtLocation, error);
	    });
	  };

	  return GraphQLMultiReporter;
	}();

	module.exports = GraphQLMultiReporter;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(11));

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(4));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _require = __webpack_require__(21),
	    DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;

	var _require2 = __webpack_require__(8),
	    getNullableType = _require2.getNullableType,
	    getRawType = _require2.getRawType,
	    getTypeFromAST = _require2.getTypeFromAST,
	    isExecutableDefinitionAST = _require2.isExecutableDefinitionAST;

	var _require3 = __webpack_require__(5),
	    assertCompositeType = _require3.assertCompositeType,
	    assertInputType = _require3.assertInputType,
	    assertOutputType = _require3.assertOutputType,
	    extendSchema = _require3.extendSchema,
	    getNamedType = _require3.getNamedType,
	    GraphQLEnumType = _require3.GraphQLEnumType,
	    GraphQLInputObjectType = _require3.GraphQLInputObjectType,
	    GraphQLInterfaceType = _require3.GraphQLInterfaceType,
	    GraphQLList = _require3.GraphQLList,
	    GraphQLObjectType = _require3.GraphQLObjectType,
	    GraphQLScalarType = _require3.GraphQLScalarType,
	    GraphQLUnionType = _require3.GraphQLUnionType,
	    isLeafType = _require3.isLeafType,
	    isTypeSubTypeOf = _require3.isTypeSubTypeOf,
	    _parse = _require3.parse,
	    parseType = _require3.parseType,
	    SchemaMetaFieldDef = _require3.SchemaMetaFieldDef,
	    Source = _require3.Source,
	    TypeMetaFieldDef = _require3.TypeMetaFieldDef,
	    TypeNameMetaFieldDef = _require3.TypeNameMetaFieldDef;

	var ARGUMENT_DEFINITIONS = 'argumentDefinitions';
	var ARGUMENTS = 'arguments';

	/**
	 * @internal
	 *
	 * This directive is not intended for use by developers directly. To set a field
	 * handle in product code use a compiler plugin.
	 */
	var CLIENT_FIELD = '__clientField';
	var CLIENT_FIELD_HANDLE = 'handle';
	var CLIENT_FIELD_KEY = 'key';
	var CLIENT_FIELD_FILTERS = 'filters';

	var INCLUDE = 'include';
	var SKIP = 'skip';
	var IF = 'if';

	var GraphQLParser = function () {
	  GraphQLParser.parse = function parse(schema, text, filename) {
	    var _this = this;

	    var ast = _parse(new Source(text, filename));
	    var nodes = [];
	    // TODO T24511737 figure out if this is dangerous
	    schema = extendSchema(schema, ast, { assumeValid: true });
	    ast.definitions.forEach(function (definition) {
	      if (isExecutableDefinitionAST(definition)) {
	        nodes.push(_this.transform(schema, definition));
	      }
	    }, this);
	    return nodes;
	  };

	  /**
	   * Transforms a raw GraphQL AST into a simpler representation with type
	   * information.
	   */


	  GraphQLParser.transform = function transform(schema, definition) {
	    var _this2 = this;

	    return __webpack_require__(2).run('GraphQLParser.transform', function () {
	      var parser = new _this2(schema, definition);
	      return parser.transform();
	    });
	  };

	  function GraphQLParser(schema, definition) {
	    (0, _classCallCheck3['default'])(this, GraphQLParser);

	    this._definition = definition;
	    this._referencedVariableTypesByName = {};
	    this._schema = schema;
	  }

	  /**
	   * Find the definition of a field of the specified type.
	   */


	  GraphQLParser.prototype.getFieldDefinition = function getFieldDefinition(parentType, fieldName, fieldAST) {
	    var type = getRawType(parentType);
	    var isQueryType = type === this._schema.getQueryType();
	    var hasTypeName = type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;

	    var schemaFieldDef = void 0;
	    if (isQueryType && fieldName === SchemaMetaFieldDef.name) {
	      schemaFieldDef = SchemaMetaFieldDef;
	    } else if (isQueryType && fieldName === TypeMetaFieldDef.name) {
	      schemaFieldDef = TypeMetaFieldDef;
	    } else if (hasTypeName && fieldName === TypeNameMetaFieldDef.name) {
	      schemaFieldDef = TypeNameMetaFieldDef;
	    } else if (type instanceof GraphQLInterfaceType || type instanceof GraphQLObjectType) {
	      schemaFieldDef = type.getFields()[fieldName];
	    }
	    return schemaFieldDef;
	  };

	  GraphQLParser.prototype._getErrorContext = function _getErrorContext() {
	    var message = 'document `' + getName(this._definition) + '`';
	    if (this._definition.loc && this._definition.loc.source) {
	      message += ' file: `' + this._definition.loc.source.name + '`';
	    }
	    return message;
	  };

	  GraphQLParser.prototype._recordAndVerifyVariableReference = function _recordAndVerifyVariableReference(name, usedAsType) {
	    var previousType = this._referencedVariableTypesByName[name];

	    if (!previousType) {
	      // No previous usage, current type is strongest
	      this._referencedVariableTypesByName[name] = usedAsType;
	    } else if (usedAsType) {
	      __webpack_require__(1)(isTypeSubTypeOf(this._schema, usedAsType, previousType) || isTypeSubTypeOf(this._schema, previousType, usedAsType), 'GraphQLParser: Variable `$%s` was used in locations expecting ' + 'the conflicting types `%s` and `%s`. Source: %s.', name, previousType, usedAsType, this._getErrorContext());

	      // If the new used type has stronger requirements, use that type as reference,
	      // otherwise keep referencing the previous type
	      this._referencedVariableTypesByName[name] = isTypeSubTypeOf(this._schema, usedAsType, previousType) ? usedAsType : previousType;
	    }
	  };

	  GraphQLParser.prototype.transform = function transform() {
	    switch (this._definition.kind) {
	      case 'OperationDefinition':
	        return this._transformOperation(this._definition);
	      case 'FragmentDefinition':
	        return this._transformFragment(this._definition);
	      default:
	        __webpack_require__(1)(false, 'GraphQLParser: Unknown AST kind `%s`. Source: %s.', this._definition.kind, this._getErrorContext());
	    }
	  };

	  GraphQLParser.prototype._transformFragment = function _transformFragment(fragment) {
	    var _this3 = this;

	    var argumentDefinitions = this._buildArgumentDefinitions(fragment);
	    var directives = this._transformDirectives((fragment.directives || []).filter(function (directive) {
	      return getName(directive) !== ARGUMENT_DEFINITIONS;
	    }));
	    var type = assertCompositeType(getTypeFromAST(this._schema, fragment.typeCondition));
	    var selections = this._transformSelections(fragment.selectionSet, type);

	    var _loop = function _loop(_name) {
	      if (_this3._referencedVariableTypesByName.hasOwnProperty(_name)) {
	        var variableType = _this3._referencedVariableTypesByName[_name];
	        var localArgument = argumentDefinitions.find(function (argDef) {
	          return argDef.name === _name;
	        });
	        if (localArgument) {
	          __webpack_require__(1)(variableType == null || isTypeSubTypeOf(_this3._schema, localArgument.type, variableType), 'GraphQLParser: Variable `$%s` was defined as type `%s`, but used ' + 'in a location that expects type `%s`. Source: %s.', _name, localArgument.type, variableType, _this3._getErrorContext());
	        } else {
	          argumentDefinitions.push({
	            kind: 'RootArgumentDefinition',
	            metadata: null,
	            name: _name,
	            // $FlowFixMe - could be null
	            type: variableType
	          });
	        }
	      }
	    };

	    for (var _name in this._referencedVariableTypesByName) {
	      _loop(_name);
	    }
	    return {
	      kind: 'Fragment',
	      directives: directives,
	      metadata: null,
	      name: getName(fragment),
	      selections: selections,
	      type: type,
	      argumentDefinitions: argumentDefinitions
	    };
	  };

	  /**
	   * Polyfills suport for fragment variable definitions via the
	   * @argumentDefinitions directive. Returns the equivalent AST
	   * to the `argumentDefinitions` property on queries/mutations/etc.
	   */


	  GraphQLParser.prototype._buildArgumentDefinitions = function _buildArgumentDefinitions(fragment) {
	    var _this4 = this;

	    var variableDirectives = (fragment.directives || []).filter(function (directive) {
	      return getName(directive) === ARGUMENT_DEFINITIONS;
	    });
	    if (!variableDirectives.length) {
	      return [];
	    }
	    __webpack_require__(1)(variableDirectives.length === 1, 'GraphQLParser: Directive %s may be defined at most once on fragment ' + '`%s`. Source: %s.', ARGUMENT_DEFINITIONS, getName(fragment), this._getErrorContext());
	    var variableDirective = variableDirectives[0];
	    // $FlowIssue: refining directly on `variableDirective.arguments` doesn't
	    // work, below accesses all report arguments could still be null/undefined.
	    var args = variableDirective.arguments;
	    if (variableDirective == null || !Array.isArray(args)) {
	      return [];
	    }
	    __webpack_require__(1)(args.length, 'GraphQLParser: Directive %s requires arguments: remove the directive ' + 'to skip defining local variables for this fragment `%s`. Source: %s.', ARGUMENT_DEFINITIONS, getName(fragment), this._getErrorContext());
	    return args.map(function (arg) {
	      var argName = getName(arg);
	      var argValue = _this4._transformValue(arg.value);
	      __webpack_require__(1)(argValue.kind === 'Literal', 'GraphQLParser: Expected definition for variable `%s` to be an ' + 'object with the following shape: `{type: string, defaultValue?: ' + 'mixed}`, got `%s`. Source: %s.', argValue, _this4._getErrorContext());
	      var value = argValue.value;
	      __webpack_require__(1)(!Array.isArray(value) && typeof value === 'object' && value !== null && typeof value.type === 'string', 'GraphQLParser: Expected definition for variable `%s` to be an ' + 'object with the following shape: `{type: string, defaultValue?: ' + 'mixed, nonNull?: boolean, list?: boolean}`, got `%s`. Source: %s.', argName, argValue, _this4._getErrorContext());

	      var valueType = value.type;

	      var unknownKeys = Object.keys(value).filter(function (key) {
	        return key !== 'type' && key !== 'defaultValue' && key !== 'nonNull' && key !== 'list';
	      });
	      __webpack_require__(1)(unknownKeys.length === 0, 'GraphQLParser: Expected definition for variable `%s` to be an ' + 'object with the following shape: `{type: string, defaultValue?: ' + 'mixed, nonNull?: boolean, list?: boolean}`, got unknown key(s) ' + '`%s`. Source: %s.', argName, unknownKeys.join('`, `'), _this4._getErrorContext());

	      var typeAST = parseType(valueType);
	      var type = assertInputType(getTypeFromAST(_this4._schema, typeAST));
	      return {
	        kind: 'LocalArgumentDefinition',
	        defaultValue: value.defaultValue != null ? value.defaultValue : null,
	        metadata: null,
	        name: argName,
	        type: type
	      };
	    });
	  };

	  GraphQLParser.prototype._transformOperation = function _transformOperation(definition) {
	    var name = getName(definition);
	    var argumentDefinitions = this._transformArgumentDefinitions(definition.variableDefinitions || []);
	    var directives = this._transformDirectives(definition.directives || []);
	    var type = void 0;
	    var operation = void 0;
	    switch (definition.operation) {
	      case 'query':
	        operation = 'query';
	        type = assertCompositeType(this._schema.getQueryType());
	        break;
	      case 'mutation':
	        operation = 'mutation';
	        type = assertCompositeType(this._schema.getMutationType());
	        break;
	      case 'subscription':
	        operation = 'subscription';
	        type = assertCompositeType(this._schema.getSubscriptionType());
	        break;
	      default:
	        __webpack_require__(1)(false, 'GraphQLParser: Unknown AST kind `%s`. Source: %s.', definition.operation, this._getErrorContext());
	    }
	    __webpack_require__(1)(definition.selectionSet, 'GraphQLParser: Expected %s `%s` to have selections. Source: %s.', operation, name, this._getErrorContext());
	    var selections = this._transformSelections(definition.selectionSet, type);
	    return {
	      kind: 'Root',
	      operation: operation,
	      metadata: null,
	      name: name,
	      dependentRequests: [],
	      argumentDefinitions: argumentDefinitions,
	      directives: directives,
	      selections: selections,
	      type: type
	    };
	  };

	  GraphQLParser.prototype._transformArgumentDefinitions = function _transformArgumentDefinitions(argumentDefinitions) {
	    var _this5 = this;

	    return argumentDefinitions.map(function (def) {
	      var name = getName(def.variable);
	      var type = assertInputType(getTypeFromAST(_this5._schema, def.type));
	      var defaultLiteral = def.defaultValue ? _this5._transformValue(def.defaultValue) : null;
	      if (_this5._referencedVariableTypesByName.hasOwnProperty(name)) {
	        var variableType = _this5._referencedVariableTypesByName[name];
	        __webpack_require__(1)(variableType == null || isTypeSubTypeOf(_this5._schema, type, variableType), 'GraphQLParser: Variable `$%s` was defined as type `%s`, but used ' + 'in a location that expects type `%s`. Source: %s.', name, type, variableType, _this5._getErrorContext());
	      }
	      __webpack_require__(1)(defaultLiteral === null || defaultLiteral.kind === 'Literal', 'GraphQLParser: Expected null or Literal default value, got: `%s`. ' + 'Source: %s.', defaultLiteral && defaultLiteral.kind, _this5._getErrorContext());
	      return {
	        kind: 'LocalArgumentDefinition',
	        metadata: null,
	        name: name,
	        defaultValue: defaultLiteral ? defaultLiteral.value : null,
	        type: type
	      };
	    });
	  };

	  GraphQLParser.prototype._transformSelections = function _transformSelections(selectionSet, parentType) {
	    var _this6 = this;

	    return selectionSet.selections.map(function (selection) {
	      var node = void 0;
	      if (selection.kind === 'Field') {
	        node = _this6._transformField(selection, parentType);
	      } else if (selection.kind === 'FragmentSpread') {
	        node = _this6._transformFragmentSpread(selection, parentType);
	      } else if (selection.kind === 'InlineFragment') {
	        node = _this6._transformInlineFragment(selection, parentType);
	      } else {
	        __webpack_require__(1)(false, 'GraphQLParser: Unexpected AST kind `%s`. Source: %s.', selection.kind, _this6._getErrorContext());
	      }

	      var _splitConditions2 = _this6._splitConditions(node.directives),
	          conditions = _splitConditions2[0],
	          directives = _splitConditions2[1];

	      var conditionalNodes = applyConditions(conditions,
	      // $FlowFixMe(>=0.28.0)
	      [(0, _extends3['default'])({}, node, { directives: directives })]);
	      __webpack_require__(1)(conditionalNodes.length === 1, 'GraphQLParser: Expected exactly one conditional node, got `%s`. ' + 'Source: %s.', conditionalNodes.length, _this6._getErrorContext());
	      return conditionalNodes[0];
	    });
	  };

	  GraphQLParser.prototype._transformInlineFragment = function _transformInlineFragment(fragment, parentType) {
	    var typeCondition = assertCompositeType(fragment.typeCondition ? getTypeFromAST(this._schema, fragment.typeCondition) : parentType);
	    var directives = this._transformDirectives(fragment.directives || []);
	    var selections = this._transformSelections(fragment.selectionSet, typeCondition);
	    return {
	      kind: 'InlineFragment',
	      directives: directives,
	      metadata: null,
	      selections: selections,
	      typeCondition: typeCondition
	    };
	  };

	  GraphQLParser.prototype._transformFragmentSpread = function _transformFragmentSpread(fragment, parentType) {
	    var _this7 = this;

	    var fragmentName = getName(fragment);

	    var _partitionArray = partitionArray(fragment.directives || [], function (directive) {
	      return getName(directive) !== ARGUMENTS;
	    }),
	        otherDirectives = _partitionArray[0],
	        argumentDirectives = _partitionArray[1];

	    __webpack_require__(1)(argumentDirectives.length <= 1, 'GraphQLParser: Directive %s may be used at most once in fragment ' + 'spread `...%s`. Source: %s.', ARGUMENTS, fragmentName, this._getErrorContext());
	    var args = void 0;
	    if (argumentDirectives.length) {
	      args = (argumentDirectives[0].arguments || []).map(function (arg) {
	        var argValue = arg.value;
	        __webpack_require__(1)(argValue.kind === 'Variable', 'GraphQLParser: All @arguments() args must be variables, got %s. ' + 'Source: %s.', argValue.kind, _this7._getErrorContext());

	        return {
	          kind: 'Argument',
	          metadata: null,
	          name: getName(arg),
	          value: _this7._transformVariable(argValue),
	          type: null // TODO: can't get type until referenced fragment is defined
	        };
	      });
	    }
	    var directives = this._transformDirectives(otherDirectives);
	    return {
	      kind: 'FragmentSpread',
	      args: args || [],
	      metadata: null,
	      name: fragmentName,
	      directives: directives
	    };
	  };

	  GraphQLParser.prototype._transformField = function _transformField(field, parentType) {
	    var name = getName(field);
	    var fieldDef = this.getFieldDefinition(parentType, name, field);

	    __webpack_require__(1)(fieldDef, 'GraphQLParser: Unknown field `%s` on type `%s`. Source: %s.', name, parentType, this._getErrorContext());
	    var alias = field.alias ? field.alias.value : null;
	    var args = this._transformArguments(field.arguments || [], fieldDef.args);

	    var _partitionArray2 = partitionArray(field.directives || [], function (directive) {
	      return getName(directive) !== CLIENT_FIELD;
	    }),
	        otherDirectives = _partitionArray2[0],
	        clientFieldDirectives = _partitionArray2[1];

	    var directives = this._transformDirectives(otherDirectives);
	    var type = assertOutputType(fieldDef.type);
	    var handles = this._transformHandle(name, args, clientFieldDirectives);
	    if (isLeafType(getNamedType(type))) {
	      __webpack_require__(1)(!field.selectionSet || !field.selectionSet.selections || !field.selectionSet.selections.length, 'GraphQLParser: Expected no selections for scalar field `%s` on type ' + '`%s`. Source: %s.', name, this._getErrorContext());
	      return {
	        kind: 'ScalarField',
	        alias: alias,
	        args: args,
	        directives: directives,
	        handles: handles,
	        metadata: null,
	        name: name,
	        type: assertScalarFieldType(type)
	      };
	    } else {
	      var selections = field.selectionSet ? this._transformSelections(field.selectionSet, type) : null;
	      __webpack_require__(1)(selections && selections.length, 'GraphQLParser: Expected at least one selection for non-scalar field ' + '`%s` on type `%s`. Source: %s.', name, type, this._getErrorContext());
	      return {
	        kind: 'LinkedField',
	        alias: alias,
	        args: args,
	        directives: directives,
	        handles: handles,
	        metadata: null,
	        name: name,
	        selections: selections,
	        type: type
	      };
	    }
	  };

	  GraphQLParser.prototype._transformHandle = function _transformHandle(fieldName, fieldArgs, clientFieldDirectives) {
	    var _this8 = this;

	    var handles = void 0;
	    clientFieldDirectives.forEach(function (clientFieldDirective) {
	      var handleArgument = (clientFieldDirective.arguments || []).find(function (arg) {
	        return getName(arg) === CLIENT_FIELD_HANDLE;
	      });
	      if (handleArgument) {
	        var _name2 = null;
	        var key = DEFAULT_HANDLE_KEY;
	        var filters = null;
	        var maybeHandle = _this8._transformValue(handleArgument.value);
	        __webpack_require__(1)(maybeHandle.kind === 'Literal' && typeof maybeHandle.value === 'string', 'GraphQLParser: Expected the %s argument to @%s to be a literal ' + 'string, got `%s` on field `%s`. Source: %s.', CLIENT_FIELD_HANDLE, CLIENT_FIELD, maybeHandle, fieldName, _this8._getErrorContext());
	        _name2 = maybeHandle.value;

	        var keyArgument = (clientFieldDirective.arguments || []).find(function (arg) {
	          return getName(arg) === CLIENT_FIELD_KEY;
	        });
	        if (keyArgument) {
	          var maybeKey = _this8._transformValue(keyArgument.value);
	          __webpack_require__(1)(maybeKey.kind === 'Literal' && typeof maybeKey.value === 'string', 'GraphQLParser: Expected %s argument to @%s to be a literal ' + 'string, got `%s` on field `%s`. Source: %s.', CLIENT_FIELD_KEY, CLIENT_FIELD, maybeKey, fieldName, _this8._getErrorContext());
	          key = maybeKey.value;
	        }
	        var filtersArgument = (clientFieldDirective.arguments || []).find(function (arg) {
	          return getName(arg) === CLIENT_FIELD_FILTERS;
	        });
	        if (filtersArgument) {
	          var maybeFilters = _this8._transformValue(filtersArgument.value);
	          __webpack_require__(1)(maybeFilters.kind === 'Literal' && Array.isArray(maybeFilters.value) && maybeFilters.value.every(function (filter) {
	            return fieldArgs.some(function (fieldArg) {
	              return fieldArg.name === filter;
	            });
	          }), 'GraphQLParser: Expected %s argument to @%s to be an array of ' + 'argument names on field `%s`, but get %s. Source: %s.', CLIENT_FIELD_FILTERS, CLIENT_FIELD, fieldName, maybeFilters, _this8._getErrorContext());
	          // $FlowFixMe
	          filters = maybeFilters.value;
	        }
	        handles = handles || [];
	        handles.push({ name: _name2, key: key, filters: filters });
	      }
	    });
	    return handles;
	  };

	  GraphQLParser.prototype._transformDirectives = function _transformDirectives(directives) {
	    var _this9 = this;

	    return directives.map(function (directive) {
	      var name = getName(directive);
	      var directiveDef = _this9._schema.getDirective(name);
	      __webpack_require__(1)(directiveDef, 'GraphQLParser: Unknown directive `@%s`. Source: %s.', name, _this9._getErrorContext());
	      var args = _this9._transformArguments(directive.arguments || [], directiveDef.args);
	      return {
	        kind: 'Directive',
	        metadata: null,
	        name: name,
	        args: args
	      };
	    });
	  };

	  GraphQLParser.prototype._transformArguments = function _transformArguments(args, argumentDefinitions) {
	    var _this10 = this;

	    return args.map(function (arg) {
	      var argName = getName(arg);
	      var argDef = argumentDefinitions.find(function (def) {
	        return def.name === argName;
	      });
	      __webpack_require__(1)(argDef, 'GraphQLParser: Unknown argument `%s`. Source: %s.', argName, _this10._getErrorContext());
	      var value = _this10._transformValue(arg.value, argDef.type);
	      return {
	        kind: 'Argument',
	        metadata: null,
	        name: argName,
	        value: value,
	        type: argDef.type
	      };
	    });
	  };

	  GraphQLParser.prototype._splitConditions = function _splitConditions(mixedDirectives) {
	    var _this11 = this;

	    var conditions = [];
	    var directives = [];
	    mixedDirectives.forEach(function (directive) {
	      if (directive.name === INCLUDE || directive.name === SKIP) {
	        var passingValue = directive.name === INCLUDE;
	        var arg = directive.args[0];
	        __webpack_require__(1)(arg && arg.name === IF, 'GraphQLParser: Expected an `if` argument to @%s. Source: %s.', directive.name, _this11._getErrorContext());
	        __webpack_require__(1)(arg.value.kind === 'Variable' || arg.value.kind === 'Literal', 'GraphQLParser: Expected the `if` argument to @%s to be a variable. ' + 'Source: %s.', directive.name, _this11._getErrorContext());
	        conditions.push({
	          kind: 'Condition',
	          condition: arg.value,
	          metadata: null,
	          passingValue: passingValue,
	          selections: []
	        });
	      } else {
	        directives.push(directive);
	      }
	    });
	    var sortedConditions = [].concat(conditions).sort(function (a, b) {
	      if (a.condition.kind === 'Variable' && b.condition.kind === 'Variable') {
	        return a.condition.variableName < b.condition.variableName ? -1 : a.condition.variableName > b.condition.variableName ? 1 : 0;
	      } else {
	        // sort literals earlier, variables later
	        return a.condition.kind === 'Variable' ? 1 : b.condition.kind === 'Variable' ? -1 : 0;
	      }
	    });
	    return [sortedConditions, directives];
	  };

	  GraphQLParser.prototype._transformVariable = function _transformVariable(ast, type) {
	    var variableName = getName(ast);
	    this._recordAndVerifyVariableReference(variableName, type);
	    return {
	      kind: 'Variable',
	      metadata: null,
	      variableName: variableName,
	      type: type
	    };
	  };

	  /**
	   * Transforms AST values into IR values, extracting the literal JS values of any
	   * subtree of the AST that does not contain a variable.
	   */


	  GraphQLParser.prototype._transformValue = function _transformValue(ast, type) {
	    var _this12 = this;

	    switch (ast.kind) {
	      case 'IntValue':
	        return {
	          kind: 'Literal',
	          metadata: null,
	          value: parseInt(ast.value, 10)
	        };
	      case 'FloatValue':
	        return {
	          kind: 'Literal',
	          metadata: null,
	          value: parseFloat(ast.value)
	        };
	      case 'StringValue':
	        return {
	          kind: 'Literal',
	          metadata: null,
	          value: ast.value
	        };
	      case 'BooleanValue':
	        // Note: duplicated because Flow does not understand fall-through cases
	        return {
	          kind: 'Literal',
	          metadata: null,
	          value: ast.value
	        };
	      case 'EnumValue':
	        // Note: duplicated because Flow does not understand fall-through cases
	        return {
	          kind: 'Literal',
	          metadata: null,
	          value: ast.value
	        };
	      case 'ListValue':
	        var itemType = void 0;
	        if (type) {
	          var listType = getNullableType(type);
	          // The user entered a list, a `type` was expected; this is only valid
	          // if `type` is a List.
	          __webpack_require__(1)(listType instanceof GraphQLList, 'GraphQLParser: Expected a value matching type `%s`, but ' + 'got a list value. Source: %s.', type, this._getErrorContext());
	          itemType = assertInputType(listType.ofType);
	        }
	        var literalList = [];
	        var items = [];
	        var areAllItemsScalar = true;
	        ast.values.forEach(function (item) {
	          var itemValue = _this12._transformValue(item, itemType);
	          if (itemValue.kind === 'Literal') {
	            literalList.push(itemValue.value);
	          }
	          items.push(itemValue);
	          areAllItemsScalar = areAllItemsScalar && itemValue.kind === 'Literal';
	        });
	        if (areAllItemsScalar) {
	          return {
	            kind: 'Literal',
	            metadata: null,
	            value: literalList
	          };
	        } else {
	          return {
	            kind: 'ListValue',
	            metadata: null,
	            items: items
	          };
	        }
	      case 'NullValue':
	        return {
	          kind: 'Literal',
	          metadata: null,
	          value: null
	        };
	      case 'ObjectValue':
	        var literalObject = {};
	        var fields = [];
	        var areAllFieldsScalar = true;
	        ast.fields.forEach(function (field) {
	          var fieldName = getName(field);
	          var fieldType = void 0;
	          if (type) {
	            var objectType = getNullableType(type);
	            // The user entered an object, a `type` was expected; this is only
	            // valid if `type` is an Object.
	            __webpack_require__(1)(objectType instanceof GraphQLInputObjectType, 'GraphQLParser: Expected a value matching type `%s`, but ' + 'got an object value. Source: %s.', type, _this12._getErrorContext());
	            var fieldConfig = objectType.getFields()[fieldName];
	            __webpack_require__(1)(fieldConfig, 'GraphQLParser: Unknown field `%s` on type `%s`. Source: %s.', fieldName, type, _this12._getErrorContext());
	            fieldType = assertInputType(fieldConfig.type);
	          }
	          var fieldValue = _this12._transformValue(field.value, fieldType);
	          if (fieldValue.kind === 'Literal') {
	            literalObject[field.name.value] = fieldValue.value;
	          }
	          fields.push({
	            kind: 'ObjectFieldValue',
	            metadata: null,
	            name: fieldName,
	            value: fieldValue
	          });
	          areAllFieldsScalar = areAllFieldsScalar && fieldValue.kind === 'Literal';
	        });
	        if (areAllFieldsScalar) {
	          return {
	            kind: 'Literal',
	            metadata: null,
	            value: literalObject
	          };
	        } else {
	          return {
	            kind: 'ObjectValue',
	            metadata: null,
	            fields: fields
	          };
	        }
	      case 'Variable':
	        return this._transformVariable(ast, type);
	      default:
	        __webpack_require__(1)(false, 'GraphQLParser: Unknown ast kind: %s. Source: %s.', ast.kind, this._getErrorContext());
	    }
	  };

	  return GraphQLParser;
	}();

	function isScalarFieldType(type) {
	  var namedType = getNamedType(type);
	  return namedType instanceof GraphQLScalarType || namedType instanceof GraphQLEnumType;
	}

	function assertScalarFieldType(type) {
	  __webpack_require__(1)(isScalarFieldType(type), 'Expected %s to be a Scalar Field type.', type);
	  return type;
	}

	function applyConditions(conditions, selections) {
	  var nextSelections = selections;
	  conditions.forEach(function (condition) {
	    nextSelections = [(0, _extends3['default'])({}, condition, {
	      selections: nextSelections
	    })];
	  });
	  return nextSelections;
	}

	function getName(ast) {
	  var name = ast.name ? ast.name.value : null;
	  __webpack_require__(1)(typeof name === 'string', 'GraphQLParser: Expected ast node `%s` to have a name.', ast);
	  return name;
	}

	/**
	 * Partitions an array given a predicate. All elements satisfying the predicate
	 * are part of the first returned array, and all elements that don't are in the
	 * second.
	 */
	function partitionArray(array, predicate, context) {
	  var first = [];
	  var second = [];
	  array.forEach(function (element, index) {
	    if (predicate.call(context, element, index, array)) {
	      first.push(element);
	    } else {
	      second.push(element);
	    }
	  });
	  return [first, second];
	}

	module.exports = GraphQLParser;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var STATE = {};

	/**
	 * A transform that inlines all fragments and removes them.
	 */
	function inlineFragmentsTransform(context) {
	  return __webpack_require__(7).transform(context, {
	    Fragment: visitFragment,
	    FragmentSpread: visitFragmentSpread
	  }, function () {
	    return STATE;
	  });
	}

	function visitFragment(fragment, state) {
	  return null;
	}

	function visitFragmentSpread(fragmentSpread, state) {
	  __webpack_require__(1)(fragmentSpread.args.length === 0, 'InlineFragmentsTransform: Cannot flatten fragment spread `%s` with ' + 'arguments. Use the `ApplyFragmentArgumentTransform` before flattening', fragmentSpread.name);
	  var fragment = this.getContext().getFragment(fragmentSpread.name);
	  var result = {
	    kind: 'InlineFragment',
	    directives: fragmentSpread.directives,
	    metadata: fragmentSpread.metadata,
	    selections: fragment.selections,
	    typeCondition: fragment.type
	  };

	  return this.traverse(result, state);
	}

	module.exports = {
	  transform: inlineFragmentsTransform
	};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(8),
	    assertTypeWithFields = _require.assertTypeWithFields,
	    canHaveSelections = _require.canHaveSelections,
	    getRawType = _require.getRawType;

	var _require2 = __webpack_require__(5),
	    SchemaMetaFieldDef = _require2.SchemaMetaFieldDef,
	    TypeMetaFieldDef = _require2.TypeMetaFieldDef,
	    TypeNameMetaFieldDef = _require2.TypeNameMetaFieldDef;

	/**
	 * A transform that removes any selections that are not valid relative to the
	 * server schema. The primary use case is for fields added via client
	 * `extend type ...` definitions and for inline fragments / fragment spreads
	 * whose types are added with client `type ...` type extensions.
	 *
	 * Given a base schema:
	 *
	 * ```
	 * # Note: full schema definition elided for clarity
	 * interface Viewer {
	 *   name: String
	 * }
	 * type User implements Viewer {
	 *   name: String
	 * }
	 * ```
	 *
	 * And a fragment:
	 *
	 * ```
	 * fragment on Viewer {
	 *   name
	 *   ... on User {
	 *     clientField # (1)
	 *   }
	 *   ... on ClientType { # (2)
	 *     clientField
	 *   }
	 * }
	 * extend type User {
	 *   clientField: String
	 * }
	 * type ClientType implements Viewer {
	 *   name: String
	 *   clientField: String
	 * }
	 * ```
	 *
	 * This transform will output:
	 *
	 * ```
	 * fragment on Viewer {
	 *   name
	 * }
	 * ```
	 *
	 * Note that (1) is removed because this field does not exist on the base `User`
	 * type, and (2) is removed because the `ClientType` type does not exist in the
	 * base schema.
	 */
	function skipClientFieldTransform(context) {
	  return __webpack_require__(7).transform(context, {
	    FragmentSpread: visitFragmentSpread,
	    InlineFragment: visitInlineFragment,
	    LinkedField: visitField,
	    ScalarField: visitField
	  }, function (node) {
	    return buildState(context, node);
	  });
	}

	/**
	 * @internal
	 *
	 * Build the initial state, returning null for fragments whose type is not
	 * defined in the server schema.
	 */
	function buildState(context, node) {
	  var schema = context.serverSchema;
	  if (node.kind === 'Fragment') {
	    return schema.getType(node.type.name);
	  }
	  switch (node.operation) {
	    case 'query':
	      return schema.getQueryType();
	    case 'mutation':
	      return schema.getMutationType();
	    case 'subscription':
	      return schema.getSubscriptionType();
	  }
	  return null;
	}

	/**
	 * @internal
	 *
	 * Skip fields that were added via `extend type ...`.
	 */
	function visitField(field, parentType) {
	  if (
	  // Field is defined in the original parent type definition:
	  canHaveSelections(parentType) && assertTypeWithFields(parentType).getFields()[field.name] ||
	  // Allow metadata fields and fields defined on classic "fat" interfaces
	  field.name === SchemaMetaFieldDef.name || field.name === TypeMetaFieldDef.name || field.name === TypeNameMetaFieldDef.name || field.directives.some(function (_ref) {
	    var name = _ref.name;
	    return name === 'fixme_fat_interface';
	  })) {
	    var rawType = getRawType(field.type);
	    var type = this.getContext().serverSchema.getType(rawType.name);
	    __webpack_require__(1)(type, 'SkipClientFieldTransform: Expected type `%s` to be defined in ' + 'the server schema.', rawType.name);
	    return this.traverse(field, type);
	  }
	  return null;
	}

	/**
	 * @internal
	 *
	 * Skip fragment spreads where the referenced fragment is not defined in the
	 * original schema.
	 */
	function visitFragmentSpread(spread, parentType) {
	  var context = this.getContext();
	  var fragment = context.getFragment(spread.name);
	  if (context.serverSchema.getType(fragment.type.name)) {
	    return this.traverse(spread, parentType);
	  }
	  return null;
	}

	/**
	 * @internal
	 *
	 * Skip inline fragments where the type is not in the schema.
	 */
	function visitInlineFragment(fragment, parentType) {
	  var schema = this.getContext().serverSchema;
	  var type = schema.getType(fragment.typeCondition.name);
	  if (type) {
	    return this.traverse(fragment, type);
	  }
	  return null;
	}

	module.exports = {
	  transform: skipClientFieldTransform
	};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(11));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(12));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var IMap = __webpack_require__(17).Map;

	/**
	 * A transform that removes redundant fields and fragment spreads. Redundancy is
	 * defined in this context as any selection that is guaranteed to already be
	 * fetched by an ancestor selection. This can occur in two cases:
	 *
	 * 1. Simple duplicates at the same level of the document can always be skipped:
	 *
	 * ```
	 * fragment Foo on FooType {
	 *   id
	 *   id
	 *   ...Bar
	 *   ...Bar
	 * }
	 * ```
	 *
	 * Becomes
	 *
	 * ```
	 * fragment Foo on FooType {
	 *   id
	 *   ...Bar
	 * }
	 * ```
	 *
	 * 2. Inline fragments and conditions introduce the possibility for duplication
	 * at different levels of the tree. Whenever a selection is fetched in a parent,
	 * it is redundant to also fetch it in a child:
	 *
	 * ```
	 * fragment Foo on FooType {
	 *   id
	 *   ... on OtherType {
	 *     id # 1
	 *   }
	 *   ... on FooType @include(if: $cond) {
	 *     id # 2
	 *   }
	 * }
	 * ```
	 *
	 * Becomes:
	 *
	 * ```
	 * fragment Foo on FooType {
	 *   id
	 * }
	 * ```
	 *
	 * In this example:
	 * - 1 can be skipped because `id` is already fetched by the parent. Even
	 *   though the type is different (FooType/OtherType), the inline fragment
	 *   cannot match without the outer fragment matching so the outer `id` is
	 *   guaranteed to already be fetched.
	 * - 2 can be skipped for similar reasons: it doesn't matter if the condition
	 *   holds, `id` is already fetched by the parent regardless.
	 *
	 * This transform also handles more complicated cases in which selections are
	 * nested:
	 *
	 * ```
	 * fragment Foo on FooType {
	 *   a {
	 *     bb
	 *   }
	 *   ... on OtherType {
	 *     a {
	 *       bb # 1
	 *       cc
	 *     }
	 *   }
	 *  }
	 * ```
	 *
	 * Becomes
	 *
	 * ```
	 * fragment Foo on FooType {
	 *   a {
	 *     bb
	 *   }
	 *   ... on OtherType {
	 *     a {
	 *       cc
	 *     }
	 *   }
	 *  }
	 * ```
	 *
	 * 1 can be skipped because it is already fetched at the outer level.
	 */


	/**
	 * A simplified representation of a document: keys in the map are unique
	 * identifiers for the selections of a node, values are either null (for scalars)
	 * or nested maps for items with subselections (linked fields, inline fragments,
	 * etc).
	 */
	function skipRedundantNodesTransform(context) {
	  return __webpack_require__(7).transform(context, {
	    Root: visitNode,
	    Fragment: visitNode
	  });
	}

	function visitNode(node) {
	  return transformNode(node, new IMap()).node;
	}

	/**
	 * The most straightforward approach would be two passes: one to record the
	 * structure of the document, one to prune duplicates. This implementation uses
	 * a single pass. Selections are sorted with fields first, "conditionals"
	 * (inline fragments & conditions) last. This means that all fields that are
	 * guaranteed to be fetched are encountered prior to any duplicates that may be
	 * fetched within a conditional.
	 *
	 * Because selections fetched within a conditional are not guaranteed to be
	 * fetched in the parent, a fork of the selection map is created when entering a
	 * conditional. The sort ensures that guaranteed fields have already been seen
	 * prior to the clone.
	 */
	function transformNode(node, selectionMap) {
	  var selections = [];
	  sortSelections(node.selections).forEach(function (selection) {
	    var identifier = __webpack_require__(25)(selection);
	    switch (selection.kind) {
	      case 'ScalarField':
	      case 'DeferrableFragmentSpread':
	      case 'FragmentSpread':
	        {
	          if (!selectionMap.has(identifier)) {
	            selections.push(selection);
	            selectionMap = selectionMap.set(identifier, null);
	          }
	          break;
	        }
	      case 'LinkedField':
	        {
	          var transformed = transformNode(selection, selectionMap.get(identifier) || new IMap());
	          if (transformed.node) {
	            selections.push(transformed.node);
	            selectionMap = selectionMap.set(identifier, transformed.selectionMap);
	          }
	          break;
	        }
	      case 'InlineFragment':
	      case 'Condition':
	        {
	          // Fork the selection map to prevent conditional selections from
	          // affecting the outer "guaranteed" selections.
	          var _transformed = transformNode(selection, selectionMap.get(identifier) || selectionMap);
	          if (_transformed.node) {
	            selections.push(_transformed.node);
	            selectionMap = selectionMap.set(identifier, _transformed.selectionMap);
	          }
	          break;
	        }
	      default:
	        __webpack_require__(1)(false, 'SkipRedundantNodesTransform: Unexpected node kind `%s`.', selection.kind);
	    }
	  });
	  var nextNode = selections.length ? (0, _extends3['default'])({}, node, { selections: selections }) : null;
	  return { selectionMap: selectionMap, node: nextNode };
	}

	/**
	 * Sort inline fragments and conditions after other selections.
	 */
	function sortSelections(selections) {
	  return [].concat((0, _toConsumableArray3['default'])(selections)).sort(function (a, b) {
	    return a.kind === 'InlineFragment' || a.kind === 'Condition' ? 1 : b.kind === 'InlineFragment' || b.kind === 'Condition' ? -1 : 0;
	  });
	}

	module.exports = {
	  transform: skipRedundantNodesTransform
	};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(11));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(12));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var FAIL = 'fail';
	var PASS = 'pass';
	var VARIABLE = 'variable';

	/**
	 * A tranform that removes unreachable IR nodes from all documents in a corpus.
	 * The following nodes are removed:
	 * - Any node with `@include(if: false)`
	 * - Any node with `@skip(if: true)`
	 * - Any node with empty `selections`
	 */
	function skipUnreachableNodeTransform(context) {
	  var fragments = new Map();
	  var nextContext = __webpack_require__(7).transform(context, {
	    Root: function Root(node) {
	      return transformNode(context, fragments, node);
	    },
	    // Fragments are included below where referenced.
	    // Unreferenced fragments are not included.
	    Fragment: function Fragment(id) {
	      return null;
	    }
	  });
	  return Array.from(fragments.values()).reduce(function (ctx, fragment) {
	    return fragment ? ctx.add(fragment) : ctx;
	  }, nextContext);
	}

	function transformNode(context, fragments, node) {
	  var queue = [].concat((0, _toConsumableArray3['default'])(node.selections));
	  var selections = void 0;
	  while (queue.length) {
	    var selection = queue.shift();
	    var nextSelection = void 0;
	    switch (selection.kind) {
	      case 'Condition':
	        var match = testCondition(selection);
	        if (match === PASS) {
	          queue.unshift.apply(queue, (0, _toConsumableArray3['default'])(selection.selections));
	        } else if (match === VARIABLE) {
	          nextSelection = transformNode(context, fragments, selection);
	        }
	        break;
	      case 'DeferrableFragmentSpread':
	        // Skip deferred fragment spreads if the referenced fragment is empty
	        if (!fragments.has(selection.name)) {
	          var fragment = context.getFragment(selection.name);
	          var nextFragment = transformNode(context, fragments, fragment);
	          fragments.set(selection.name, nextFragment);
	        }
	        if (fragments.get(selection.name)) {
	          nextSelection = selection;
	        }
	        break;
	      case 'FragmentSpread':
	        // Skip fragment spreads if the referenced fragment is empty
	        if (!fragments.has(selection.name)) {
	          var _fragment = context.getFragment(selection.name);
	          var _nextFragment = transformNode(context, fragments, _fragment);
	          fragments.set(selection.name, _nextFragment);
	        }
	        if (fragments.get(selection.name)) {
	          nextSelection = selection;
	        }
	        break;
	      case 'LinkedField':
	        nextSelection = transformNode(context, fragments, selection);
	        break;
	      case 'InlineFragment':
	        // TODO combine with the LinkedField case when flow supports this
	        nextSelection = transformNode(context, fragments, selection);
	        break;
	      case 'ScalarField':
	        nextSelection = selection;
	        break;
	      default:
	        selection.kind;
	        __webpack_require__(1)(false, 'SkipUnreachableNodeTransform: Unexpected selection kind `%s`.', selection.kind);
	    }
	    if (nextSelection) {
	      selections = selections || [];
	      selections.push(nextSelection);
	    }
	  }
	  if (selections) {
	    return (0, _extends3['default'])({}, node, {
	      selections: selections
	    });
	  }
	  return null;
	}

	/**
	 * Determines whether a condition statically passes/fails or is unknown
	 * (variable).
	 */
	function testCondition(condition) {
	  if (condition.condition.kind === 'Variable') {
	    return VARIABLE;
	  }
	  return condition.condition.value === condition.passingValue ? PASS : FAIL;
	}

	module.exports = {
	  transform: skipUnreachableNodeTransform
	};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _asyncToGenerator2 = __webpack_require__(10);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(12));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function execFile(cmd, args) {
	  return new Promise(function (resolve, reject) {
	    __webpack_require__(45).execFile(cmd, args, function (err) {
	      if (err) {
	        reject(err);
	      } else {
	        resolve();
	      }
	    });
	  });
	}

	/**
	 * An abstraction over the source control system to make it injectable.
	 */


	var SourceControlMercurial = {
	  addRemove: (() => {
	    var _ref = (0, _asyncToGenerator3.default)(function* (added, removed) {
	      // NOTE: Not using `hg addremove` as that has a bug when deleting a file
	      // that was just added, but not yet committed: T10711513
	      if (added.length > 0) {
	        yield execFile('hg', ['add'].concat((0, _toConsumableArray3['default'])(added)));
	      }
	      if (removed.length > 0) {
	        yield execFile('hg', ['forget'].concat((0, _toConsumableArray3['default'])(removed)));
	      }
	    });

	    function addRemove(_x, _x2) {
	      return _ref.apply(this, arguments);
	    }

	    return addRemove;
	  })()
	};

	module.exports = {
	  SourceControlMercurial: SourceControlMercurial
	};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(11));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * A transform that removes variables from root queries that aren't referenced
	 * by the query itself.
	 */
	function stripUnusedVariablesTransform(context) {
	  var fragmentToVariables = new Map();
	  var fragmentToFragmentSpreads = new Map();
	  var rootToVariables = new Map();
	  var rootToFragmentSpreads = new Map();
	  context.forEachDocument(function (document) {
	    var fragmentVariables = void 0;
	    var fragmentFragmentSpreads = void 0;
	    var rootVariables = void 0;
	    var rootFragmentSpreads = void 0;
	    var insideDeferrableFragmentSpread = false;
	    __webpack_require__(19).visit(document, {
	      Root: {
	        enter: function enter(root) {
	          rootVariables = new Set();
	          rootToVariables.set(root.name, rootVariables);
	          rootFragmentSpreads = new Set();
	          rootToFragmentSpreads.set(root.name, rootFragmentSpreads);
	        },
	        leave: function leave(root) {
	          rootVariables = null;
	          rootFragmentSpreads = null;
	        }
	      },
	      Fragment: {
	        enter: function enter(fragment) {
	          fragmentVariables = new Set();
	          fragmentToVariables.set(fragment.name, fragmentVariables);
	          fragmentFragmentSpreads = new Set();
	          fragmentToFragmentSpreads.set(fragment.name, fragmentFragmentSpreads);
	        },
	        leave: function leave(fragment) {
	          fragmentVariables = null;
	          fragmentFragmentSpreads = null;
	        }
	      },
	      Variable: function Variable(variable) {
	        if (!insideDeferrableFragmentSpread) {
	          fragmentVariables && fragmentVariables.add(variable.variableName);
	          rootVariables && rootVariables.add(variable.variableName);
	        }
	      },
	      FragmentSpread: function FragmentSpread(spread) {
	        if (!insideDeferrableFragmentSpread) {
	          fragmentFragmentSpreads && fragmentFragmentSpreads.add(spread.name);
	          rootFragmentSpreads && rootFragmentSpreads.add(spread.name);
	        }
	      },

	      DeferrableFragmentSpread: {
	        enter: function enter() {
	          insideDeferrableFragmentSpread = true;
	        },
	        leave: function leave() {
	          insideDeferrableFragmentSpread = false;
	        }
	      }
	    });
	  });
	  var variablesMemo = new Map();
	  rootToVariables.forEach(function (variables, root) {
	    Array.from(__webpack_require__(9)(rootToFragmentSpreads.get(root), 'root ' + root + ' wasn\'t found in StripUnusedVariablesTransform')).forEach(function (spread) {
	      return into(variables, allVariablesReferencedInFragment(variablesMemo, spread, fragmentToVariables, fragmentToFragmentSpreads));
	    });
	  });
	  return __webpack_require__(7).transform(context, {
	    Root: function Root(root) {
	      return transformRoot(context, root, __webpack_require__(9)(rootToVariables.get(root.name), 'root ' + root.name + ' wasn\'t found in StripUnusedVariablesTransform'));
	    },
	    // Include fragments, but do not traverse into them.
	    Fragment: function Fragment(id) {
	      return id;
	    }
	  });
	}

	function allVariablesReferencedInFragment(variablesMemo, fragment, fragmentToVariables, fragmentToFragmentSpreads) {
	  var variables = variablesMemo.get(fragment);
	  if (!variables) {
	    var directVariables = __webpack_require__(9)(fragmentToVariables.get(fragment), 'fragment ' + fragment + ' wasn\'t found in StripUnusedVariablesTransform');
	    variables = Array.from(__webpack_require__(9)(fragmentToFragmentSpreads.get(fragment), 'fragment ' + fragment + ' wasn\'t found in StripUnusedVariablesTransform')).reduce(function (allVariables, fragmentSpread) {
	      return into(allVariables, allVariablesReferencedInFragment(variablesMemo, fragmentSpread, fragmentToVariables, fragmentToFragmentSpreads));
	    }, directVariables);
	    variablesMemo.set(fragment, variables);
	  }
	  return variables;
	}

	function transformRoot(context, root, variables) {
	  return (0, _extends3['default'])({}, root, {
	    argumentDefinitions: root.argumentDefinitions.filter(function (arg) {
	      return variables.has(arg.name);
	    })
	  });
	}

	// Returns the union of setA and setB. Modifies setA!
	function into(setA, setB) {
	  setB.forEach(function (item) {
	    return setA.add(item);
	  });
	  return setA;
	}

	module.exports = {
	  transform: stripUnusedVariablesTransform
	};

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */
	'use strict';

	var aStackPool = [];
	var bStackPool = [];

	/**
	 * Checks if two values are equal. Values may be primitives, arrays, or objects.
	 * Returns true if both arguments have the same keys and values.
	 *
	 * @see http://underscorejs.org
	 * @copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
	 * @license MIT
	 */
	function areEqual(a, b) {
	  var aStack = aStackPool.length ? aStackPool.pop() : [];
	  var bStack = bStackPool.length ? bStackPool.pop() : [];
	  var result = eq(a, b, aStack, bStack);
	  aStack.length = 0;
	  bStack.length = 0;
	  aStackPool.push(aStack);
	  bStackPool.push(bStack);
	  return result;
	}

	function eq(a, b, aStack, bStack) {
	  if (a === b) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    return a !== 0 || 1 / a === 1 / b;
	  }
	  if (a == null || b == null) {
	    // a or b can be `null` or `undefined`
	    return false;
	  }
	  if (typeof a !== 'object' || typeof b !== 'object') {
	    return false;
	  }
	  var objToStr = Object.prototype.toString;
	  var className = objToStr.call(a);
	  if (className !== objToStr.call(b)) {
	    return false;
	  }
	  switch (className) {
	    case '[object String]':
	      return a === String(b);
	    case '[object Number]':
	      return isNaN(a) || isNaN(b) ? false : a === Number(b);
	    case '[object Date]':
	    case '[object Boolean]':
	      return +a === +b;
	    case '[object RegExp]':
	      return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase;
	  }
	  // Assume equality for cyclic structures.
	  var length = aStack.length;
	  while (length--) {
	    if (aStack[length] === a) {
	      return bStack[length] === b;
	    }
	  }
	  aStack.push(a);
	  bStack.push(b);
	  var size = 0;
	  // Recursively compare objects and arrays.
	  if (className === '[object Array]') {
	    size = a.length;
	    if (size !== b.length) {
	      return false;
	    }
	    // Deep compare the contents, ignoring non-numeric properties.
	    while (size--) {
	      if (!eq(a[size], b[size], aStack, bStack)) {
	        return false;
	      }
	    }
	  } else {
	    if (a.constructor !== b.constructor) {
	      return false;
	    }
	    if (a.hasOwnProperty('valueOf') && b.hasOwnProperty('valueOf')) {
	      return a.valueOf() === b.valueOf();
	    }
	    var keys = Object.keys(a);
	    if (keys.length !== Object.keys(b).length) {
	      return false;
	    }
	    for (var i = 0; i < keys.length; i++) {
	      if (keys[i] === '_owner') {
	        // HACK: Comparing deeply nested React trees is slow since you end up
	        // comparing the entire tree (all ancestors and all children) and
	        // likely not what you want if you're comparing two elements with
	        // areEqual. We bail out here for now.
	        continue;
	      }
	      if (!b.hasOwnProperty(keys[i]) || !eq(a[keys[i]], b[keys[i]], aStack, bStack)) {
	        return false;
	      }
	    }
	  }
	  aStack.pop();
	  bStack.pop();
	  return true;
	}

	module.exports = areEqual;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(19),
	    visit = _require.visit;

	/**
	 * Returns a GraphQLCompilerContext containing only the documents referenced
	 * by and including the provided node.
	 */
	function filterContextForNode(node, context) {
	  var queue = [node];
	  var filteredContext = new (__webpack_require__(22))(context.serverSchema, context.clientSchema).add(node);
	  var visitorConfig = {
	    FragmentSpread: function FragmentSpread(fragmentSpread) {
	      var name = fragmentSpread.name;

	      if (!filteredContext.get(name)) {
	        var fragment = context.getFragment(name);
	        filteredContext = filteredContext.add(fragment);
	        queue.push(fragment);
	      }
	    }
	  };
	  while (queue.length) {
	    visit(queue.pop(), visitorConfig);
	  }
	  return filteredContext;
	}

	module.exports = filterContextForNode;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	/**
	 * Generates an identifier for an argument value. The identifier is based on the
	 * structure/order of items and keys in the value.
	 */
	function getIdentifierForArgumentValue(value) {
	  switch (value.kind) {
	    case 'Variable':
	      return { variable: value.variableName };
	    case 'Literal':
	      return { value: value.value };
	    case 'ListValue':
	      return {
	        list: value.items.map(function (item) {
	          return getIdentifierForArgumentValue(item);
	        })
	      };
	    case 'ObjectValue':
	      return {
	        object: value.fields.map(function (field) {
	          return {
	            name: field.name,
	            value: getIdentifierForArgumentValue(field.value)
	          };
	        })
	      };
	    default:
	      __webpack_require__(1)(false, 'getIdentifierForArgumentValue(): Unsupported AST kind `%s`.', value.kind);
	  }
	}

	module.exports = getIdentifierForArgumentValue;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	// Copy of Variables type from '../../../react-relay/classic/tools/RelayTypes'
	// Duplicating here rather than importing it since we can't take on a dependency
	// outside of graphql-compiler.
	function getLiteralArgumentValues(args) {
	  var values = {};
	  args.forEach(function (arg) {
	    __webpack_require__(1)(arg.value.kind === 'Literal', 'getLiteralArgumentValues(): Expected all args to be literals.');
	    values[arg.name] = arg.value.value;
	  });
	  return values;
	}

	module.exports = getLiteralArgumentValues;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _require = __webpack_require__(8),
	    getRawType = _require.getRawType;

	var _require2 = __webpack_require__(5),
	    GraphQLNonNull = _require2.GraphQLNonNull,
	    GraphQLList = _require2.GraphQLList;

	/**
	 * Determine if a type is the same type (same name and class) as another type.
	 * Needed if we're comparing IRs created at different times: we don't yet have
	 * an IR schema, so the type we assign to an IR field could be !== than
	 * what we assign to it after adding some schema definitions or extensions.
	 */
	function isEquivalentType(typeA, typeB) {
	  // Easy short-circuit: equal types are equal.
	  if (typeA === typeB) {
	    return true;
	  }

	  // If either type is non-null, the other must also be non-null.
	  if (typeA instanceof GraphQLNonNull && typeB instanceof GraphQLNonNull) {
	    return isEquivalentType(typeA.ofType, typeB.ofType);
	  }

	  // If either type is a list, the other must also be a list.
	  if (typeA instanceof GraphQLList && typeB instanceof GraphQLList) {
	    return isEquivalentType(typeA.ofType, typeB.ofType);
	  }

	  // Make sure the two types are of the same class
	  if (typeA.constructor.name === typeB.constructor.name) {
	    var rawA = getRawType(typeA);
	    var rawB = getRawType(typeB);

	    // And they must have the exact same name
	    return rawA.name === rawB.name;
	  }

	  // Otherwise the types are not equal.
	  return false;
	}

	module.exports = isEquivalentType;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

	module.exports = require("child_process");

/***/ }),
/* 46 */
/***/ (function(module, exports) {

	module.exports = require("crypto");

/***/ }),
/* 47 */
/***/ (function(module, exports) {

	module.exports = require("fb-watchman");

/***/ }),
/* 48 */
/***/ (function(module, exports) {

	module.exports = require("util");

/***/ })
/******/ ]);